{"version":3,"file":"moveable.cjs.js","sources":["../src/react-moveable/consts.ts","../src/react-moveable/matrix/index.ts","../src/react-moveable/DraggerUtils.ts","../src/react-moveable/utils.ts","../src/react-moveable/ables/triggerRender.ts","../src/react-moveable/getAbleDragger.ts","../src/react-moveable/ables/Pinchable.ts","../src/react-moveable/CustomDragger.ts","../src/react-moveable/groupUtils.ts","../src/react-moveable/ables/utils.ts","../src/react-moveable/ables/snappable/snap.ts","../src/react-moveable/ables/snappable/innerBounds.ts","../src/react-moveable/ables/snappable/bounds.ts","../src/react-moveable/ables/Snappable.tsx","../src/react-moveable/ables/Draggable.tsx","../src/react-moveable/ables/Rotatable.tsx","../src/react-moveable/renderDirection.tsx","../src/react-moveable/ables/Resizable.ts","../src/react-moveable/ables/Scalable.ts","../src/react-moveable/ables/Warpable.tsx","../src/react-moveable/classNames.ts","../src/react-moveable/ables/DragArea.tsx","../src/react-moveable/ables/Origin.tsx","../src/react-moveable/ables/Scrollable.ts","../src/react-moveable/ables/Default.ts","../src/react-moveable/ables/Padding.tsx","../src/react-moveable/ables/roundable/borderRadius.tsx","../src/react-moveable/ables/Clippable.tsx","../src/react-moveable/ables/OriginDraggable.tsx","../src/react-moveable/ables/Roundable.tsx","../src/react-moveable/ables/Groupable.tsx","../src/react-moveable/ables/consts.ts","../src/react-moveable/MoveableManager.tsx","../src/react-moveable/MoveableGroup.tsx","../src/react-moveable/Moveable.tsx","../src/react-moveable/index.umd.ts"],"sourcesContent":["import getAgent from \"@egjs/agent\";\nimport { IObject } from \"@daybrush/utils\";\nimport { MoveableInterface } from \"./types\";\n\nfunction getSVGCursor(scale: number, degree: number) {\n    return `data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${32 * scale}px\" height=\"${32 * scale}px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(${degree}deg);transform-origin: 16px 16px\"></path></svg>`;\n}\nfunction getCursorCSS(degree: number) {\n    const x1 = getSVGCursor(1, degree);\n    const x2 = getSVGCursor(2, degree);\n    const degree45 = (Math.round(degree / 45) * 45) % 180;\n    const defaultCursor\n        = degree45 === 135\n        ? \"nwse-resize\"\n        : degree45 === 45\n        ? \"nesw-resize\"\n        : degree45 === 90\n        ? \"ew-resize\"\n        : \"ns-resize\"; // 135\n\n    // tslint:disable-next-line: max-line-length\n    return `cursor:${defaultCursor};cursor: url('${x1}') 16 16, ${defaultCursor};cursor: -webkit-image-set(url('${x1}') 1x, url('${x2}') 2x) 16 16, ${defaultCursor};`;\n}\n\nexport const agent = getAgent((((typeof navigator !== \"undefined\" && navigator) || {} as any).userAgent) || \"\");\nexport const IS_WEBKIT\n    = agent.os.name.indexOf(\"ios\") > -1 || agent.browser.name.indexOf(\"safari\") > -1;\n\nexport const PREFIX = \"moveable-\";\nexport const MOVEABLE_CSS = `\n{\n\tposition: fixed;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --zoom: 1;\n    --zoompx: 1px;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\tposition: absolute;\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n\tbackground: #4af;\n\tmargin-top: -7px;\n    margin-left: -7px;\n    width: calc(14 * var(--zoompx));\n    height: calc(14 * var(--zoompx));\n    margin-top: calc(-7 * var(--zoompx));\n    margin-left: calc(-7 * var(--zoompx));\n    border: calc(2 * var(--zoompx)) solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\tposition: absolute;\n\twidth: 1px;\n    height: 1px;\n    width: var(--zoompx);\n    height: var(--zoompx);\n\tbackground: #4af;\n\ttransform-origin: 0px 50%;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top: var(--zoompx) dashed #4af;\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left: var(--zoompx) dashed #4af;\n}\n.line.dashed:before {\n    position: absolute;\n    content: attr(data-size);\n    color: #4af;\n    font-size: 12px;\n    font-weight: bold;\n}\n.line.dashed.horizontal:before, .line.gap.horizontal:before {\n    left: 50%;\n    transform: translateX(-50%);\n    bottom: 5px;\n}\n.line.dashed.vertical:before, .line.gap.vertical:before {\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.line.rotation-line {\n\theight: 40px;\n    width: 1px;\n    transform-origin: 50% calc(100% - 0.5px);\n    top: -40px;\n    width: var(--zoompx);\n    height: calc(40 * var(--zoompx));\n    top: calc(-40 * var(--zoompx));\n    transform-origin: 50% calc(100% - 0.5 * var(--zoompx));\n}\n.line.rotation-line .control {\n\tborder-color: #4af;\n\tbackground:#fff;\n    cursor: alias;\n    left: 50%;\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n    width: calc(2 * var(--zoompx));\n}\n.line.horizontal.bold {\n    height: 2px;\n    height: calc(2 * var(--zoompx));\n}\n\n.line.gap {\n    background: #f55;\n}\n.line.gap:before {\n    position: absolute;\n    content: attr(data-size);\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n    width: calc(12 * var(--zoompx));\n    height: calc(12 * var(--zoompx));\n    margin-top: calc(-6 * var(--zoompx));\n    margin-left: calc(-6 * var(--zoompx));\n\tpointer-events: none;\n}\n${[0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(degree => `\n.direction[data-rotation=\"${degree}\"] {\n\t${getCursorCSS(degree)}\n}\n`).join(\"\\n\")}\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n${IS_WEBKIT ? `:global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}` : \"\"}\n`;\nexport const DRAGGER_EVENTS = [\"dragstart\", \"drag\", \"dragend\", \"pinchstart\", \"pinch\", \"pinchend\"];\n\nexport const NEARBY_POS = [\n    [0, 1, 2],\n    [1, 0, 3],\n    [2, 0, 3],\n    [3, 1, 2],\n];\n\nexport const TINY_NUM = 0.0000001;\nexport const MIN_SCALE = 0.000000001;\nexport const MAX_NUM = Math.pow(10, 10);\nexport const MIN_NUM = -MAX_NUM;\n\nexport const DIRECTIONS = [\"nw\", \"ne\", \"sw\", \"se\", \"n\", \"w\", \"s\", \"e\"];\n\nexport const DIRECTION_INDEXES: IObject<number[]> = {\n    n: [0, 1],\n    s: [2, 3],\n    w: [2, 0],\n    e: [1, 3],\n    nw: [0],\n    ne: [1],\n    sw: [2],\n    se: [3],\n};\nexport const DIRECTION_ROTATIONS: IObject<number> = {\n    n: 0,\n    s: 180,\n    w: 270,\n    e: 90,\n    nw: 315,\n    ne: 45,\n    sw: 225,\n    se: 135,\n};\n\nexport const MOVEABLE_METHODS: Array<keyof MoveableInterface> = [\n    \"isMoveableElement\",\n    \"updateRect\",\n    \"updateTarget\",\n    \"destroy\",\n    \"dragStart\",\n    \"isInside\",\n    \"hitTest\",\n    \"setState\",\n    \"getRect\",\n    \"request\",\n    \"isDragging\",\n];\n","function add(\n    matrix: number[],\n    inverseMatrix: number[],\n    startIndex: number,\n    fromIndex: number,\n    n: number,\n    k: number,\n) {\n    for (let i = 0; i < n; ++i) {\n        const x = startIndex + i * n;\n        const fromX = fromIndex + i * n;\n        matrix[x] += matrix[fromX] * k;\n        inverseMatrix[x] += inverseMatrix[fromX] * k;\n    }\n}\n\nfunction swap(\n    matrix: number[],\n    inverseMatrix: number[],\n    startIndex: number,\n    fromIndex: number,\n    n: number,\n) {\n    for (let i = 0; i < n; ++i) {\n        const x = startIndex + i * n;\n        const fromX = fromIndex + i * n;\n        const v = matrix[x];\n        const iv = inverseMatrix[x];\n\n        matrix[x] = matrix[fromX];\n        matrix[fromX] = v;\n\n        inverseMatrix[x] = inverseMatrix[fromX];\n        inverseMatrix[fromX] = iv;\n    }\n}\n\nfunction divide(\n    matrix: number[],\n    inverseMatrix: number[],\n    startIndex: number,\n    n: number,\n    k: number,\n) {\n    for (let i = 0; i < n; ++i) {\n        const x = startIndex + i * n;\n\n        matrix[x] /= k;\n        inverseMatrix[x] /= k;\n    }\n}\n\nexport function ignoreDimension(\n    matrix: number[],\n    m: number,\n    n: number = Math.sqrt(matrix.length),\n) {\n    const newMatrix = matrix.slice();\n\n    for (let i = 0; i < n; ++i) {\n        newMatrix[i * n + m - 1] = 0;\n        newMatrix[(m - 1) * n + i] = 0;\n    }\n    newMatrix[(m - 1) * (n + 1)] = 1;\n\n    return newMatrix;\n}\n\nexport function invert(\n    matrix: number[],\n    n: number = Math.sqrt(matrix.length),\n) {\n    const newMatrix = matrix.slice();\n    const inverseMatrix = createIdentityMatrix(n);\n\n    for (let i = 0; i < n; ++i) {\n        // diagonal\n        const identityIndex = n * i + i;\n\n        if (newMatrix[identityIndex] === 0) {\n            for (let j = i + 1; j < n; ++j) {\n                if (newMatrix[n * i + j]) {\n                    swap(newMatrix, inverseMatrix, i, j, n);\n                    break;\n                }\n            }\n        }\n        if (newMatrix[identityIndex]) {\n            divide(newMatrix, inverseMatrix, i, n, newMatrix[identityIndex]);\n        } else {\n            // no inverse matrix\n            return [];\n        }\n        for (let j = 0; j < n; ++j) {\n            const targetStartIndex = j;\n            const targetIndex = j + i * n;\n            const target = newMatrix[targetIndex];\n\n            if (target === 0 || i === j) {\n                continue;\n            }\n            add(newMatrix, inverseMatrix, targetStartIndex, i, n, -target);\n        }\n    }\n\n    return inverseMatrix;\n}\n\nexport function transpose(matrix: number[], n: number = Math.sqrt(matrix.length)) {\n    const newMatrix: number[] = [];\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < n; ++j) {\n            newMatrix[j * n + i] = matrix[n * i + j];\n        }\n    }\n    return newMatrix;\n}\n\nexport function getRad(pos1: number[], pos2: number[]) {\n    const distX = pos2[0] - pos1[0];\n    const distY = pos2[1] - pos1[1];\n    const rad = Math.atan2(distY, distX);\n\n    return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n\nexport function getOrigin(matrix: number[], n: number = Math.sqrt(matrix.length)) {\n    const originMatrix: number[] = [];\n\n    for (let i = 0; i < n - 1; ++i) {\n        originMatrix[i] = matrix[n * (n - 1) + i];\n    }\n    originMatrix[n - 1] = 0;\n    return originMatrix;\n}\n\nexport function convertPositionMatrix(matrix: number[], n: number) {\n    const newMatrix = matrix.slice();\n\n    for (let i = matrix.length; i < n - 1; ++i) {\n        newMatrix[i] = 0;\n    }\n    newMatrix[n - 1] = 1;\n    return newMatrix;\n}\n\nexport function convertDimension(matrix: number[], n: number = Math.sqrt(matrix.length), m: number) {\n    // n < m\n    if (n === m) {\n        return matrix;\n    }\n    const newMatrix = createIdentityMatrix(m);\n\n    const length = Math.min(n, m);\n    for (let i = 0; i < length - 1; ++i) {\n        for (let j = 0; j < length - 1; ++j) {\n            newMatrix[i * m + j] = matrix[i * n + j];\n        }\n\n        newMatrix[(i + 1) * m - 1] = matrix[(i + 1) * n - 1];\n        newMatrix[(m - 1) * m + i] = matrix[(n - 1) * n + i];\n    }\n    newMatrix[m * m - 1] = matrix[n * n - 1];\n\n    return newMatrix;\n}\n\nexport function multiplies(n: number, ...matrixes: number[][]) {\n    let m: number[] = createIdentityMatrix(n);\n\n    matrixes.forEach(matrix => {\n        m = multiply(m, matrix, n);\n    });\n    return m;\n}\n\nexport function multiply(matrix: number[], matrix2: number[], n: number = Math.sqrt(matrix.length)) {\n    const newMatrix: number[] = [];\n    // 1 y: n\n    // 1 x: m\n    // 2 x: m\n    // 2 y: k\n    // n * m X m * k\n    const m = matrix.length / n;\n    const k = matrix2.length / m;\n\n    if (!m) {\n        return matrix2;\n    } else if (!k) {\n        return matrix;\n    }\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < k; ++j) {\n            newMatrix[j * n + i] = 0;\n            for (let l = 0; l < m; ++l) {\n                // m1 x: m(l), y: n(i)\n                // m2 x: k(j):  y: m(l)\n                // nw x: n(i), y: k(j)\n                newMatrix[j * n + i] += matrix[l * n + i] * matrix2[j * m + l];\n            }\n        }\n    }\n    // n * k\n    return newMatrix;\n}\n\nexport function sum(...nums: number[]) {\n    const length = nums.length;\n    let total = 0;\n\n    for (let i = length - 1; i >= 0; --i) {\n        total += nums[i];\n    }\n    return total;\n}\nexport function average(...nums: number[]) {\n    const length = nums.length;\n    let total = 0;\n\n    for (let i = length - 1; i >= 0; --i) {\n        total += nums[i];\n    }\n    return length ? total / length : 0;\n}\nexport function plus(pos1: number[], pos2: number[]) {\n    const length = Math.min(pos1.length, pos2.length);\n    const nextPos = pos1.slice();\n\n    for (let i = 0; i < length; ++i) {\n        nextPos[i] = nextPos[i] + pos2[i];\n    }\n    return nextPos;\n}\n\nexport function minus(pos1: number[], pos2: number[]) {\n    const length = Math.min(pos1.length, pos2.length);\n    const nextPos = pos1.slice();\n\n    for (let i = 0; i < length; ++i) {\n        nextPos[i] = nextPos[i] - pos2[i];\n    }\n    return nextPos;\n}\n\nexport function convertCSStoMatrix(a: number[], is2d: boolean = a.length === 6) {\n    if (is2d) {\n        return [\n            a[0], a[1], 0,\n            a[2], a[3], 0,\n            a[4], a[5], 1,\n        ];\n    }\n    return a;\n}\nexport function convertMatrixtoCSS(a: number[], is2d: boolean = a.length === 9) {\n    if (is2d) {\n        return [\n            a[0], a[1],\n            a[3], a[4],\n            a[6], a[7],\n        ];\n    }\n    return a;\n}\n\nexport function caculate(matrix: number[], matrix2: number[], n: number = matrix2.length) {\n    const result = multiply(matrix, matrix2, n);\n    const k = result[n - 1];\n    return result.map(v => v / k);\n}\n\nexport function rotate(pos: number[], rad: number) {\n    return caculate(\n        createRotateMatrix(rad, 3),\n        convertPositionMatrix(pos, 3),\n    );\n}\n\nexport function createRotateMatrix(rad: number, n: number) {\n    const cos = Math.cos(rad);\n    const sin = Math.sin(rad);\n    const m = createIdentityMatrix(n);\n\n    // cos -sin\n    // sin cos\n    m[0] = cos;\n    m[1] = sin;\n    m[n] = -sin;\n    m[n + 1] = cos;\n\n    return m;\n}\n\nexport function createIdentityMatrix(n: number) {\n    const length = n * n;\n    const matrix: number[] = [];\n\n    for (let i = 0; i < length; ++i) {\n        matrix[i] = i % (n + 1) ? 0 : 1;\n    }\n    return matrix;\n}\nexport function createScaleMatrix(scale: number[], n: number) {\n    const m = createIdentityMatrix(n);\n    const length = Math.min(scale.length, n - 1);\n\n    for (let i = 0; i < length; ++i) {\n        m[(n + 1) * i] = scale[i];\n    }\n    return m;\n}\nexport function createOriginMatrix(origin: number[], n: number) {\n    const m = createIdentityMatrix(n);\n    const length = Math.min(origin.length, n - 1);\n\n    for (let i = 0; i < length; ++i) {\n        m[n * (n - 1) + i] = origin[i];\n    }\n    return m;\n}\n\nexport function createWarpMatrix(\n    pos0: number[],\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    nextPos0: number[],\n    nextPos1: number[],\n    nextPos2: number[],\n    nextPos3: number[],\n) {\n    const [x0, y0] = pos0;\n    const [x1, y1] = pos1;\n    const [x2, y2] = pos2;\n    const [x3, y3] = pos3;\n\n    const [u0, v0] = nextPos0;\n    const [u1, v1] = nextPos1;\n    const [u2, v2] = nextPos2;\n    const [u3, v3] = nextPos3;\n\n    const matrix = [\n        x0, 0, x1, 0, x2, 0, x3, 0,\n        y0, 0, y1, 0, y2, 0, y3, 0,\n        1, 0, 1, 0, 1, 0, 1, 0,\n        0, x0, 0, x1, 0, x2, 0, x3,\n        0, y0, 0, y1, 0, y2, 0, y3,\n        0, 1, 0, 1, 0, 1, 0, 1,\n        -u0 * x0, -v0 * x0, -u1 * x1, -v1 * x1, -u2 * x2, -v2 * x2, -u3 * x3, -v3 * x3,\n        -u0 * y0, -v0 * y0, -u1 * y1, -v1 * y1, -u2 * y2, -v2 * y2, -u3 * y3, -v3 * y3,\n    ];\n    const inverseMatrix = invert(matrix, 8);\n\n    if (!inverseMatrix.length) {\n        return [];\n    }\n    const h = multiply(inverseMatrix, [u0, v0, u1, v1, u2, v2, u3, v3], 8);\n\n    h[8] = 1;\n    return convertDimension(transpose(h), 3, 4);\n}\n","import {\n    invert, caculate, minus, plus,\n    convertPositionMatrix, average,\n    createScaleMatrix, multiply,\n} from \"./matrix\";\nimport { caculatePoses, getAbsoluteMatrix, getAbsolutePosesByState } from \"./utils\";\nimport { splitUnit } from \"@daybrush/utils\";\nimport { MoveableManagerState, ResizableProps, MoveableManagerInterface } from \"./types\";\n\nexport function setDragStart(moveable: MoveableManagerInterface<any>, { datas }: any) {\n    const {\n        matrix,\n        beforeMatrix,\n        is3d,\n        left,\n        top,\n        origin,\n        offsetMatrix,\n        targetMatrix,\n        transformOrigin,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n\n    datas.is3d = is3d;\n    datas.matrix = matrix;\n    datas.targetMatrix = targetMatrix;\n    datas.beforeMatrix = beforeMatrix;\n    datas.offsetMatrix = offsetMatrix;\n    datas.transformOrigin = transformOrigin;\n    datas.inverseMatrix = invert(matrix, n);\n    datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n    datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n    datas.startDragBeforeDist = caculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n    datas.startDragDist = caculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\nexport function getDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        inverseBeforeMatrix,\n        inverseMatrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        caculate(\n            isBefore ? inverseBeforeMatrix : inverseMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        isBefore ? startDragBeforeDist : startDragDist,\n    );\n}\nexport function getInverseDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        beforeMatrix,\n        matrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        caculate(\n            isBefore ? beforeMatrix : matrix,\n            plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]),\n            n,\n        ),\n        absoluteOrigin,\n    );\n}\n\nexport function caculateTransformOrigin(\n    transformOrigin: string[],\n    width: number,\n    height: number,\n    prevWidth: number = width,\n    prevHeight: number = height,\n    prevOrigin: number[] = [0, 0],\n) {\n\n    if (!transformOrigin) {\n        return prevOrigin;\n    }\n    return transformOrigin.map((pos, i) => {\n        const { value, unit } = splitUnit(pos);\n\n        const prevSize = (i ? prevHeight : prevWidth);\n        const size = (i ? height : width);\n        if (pos === \"%\" || isNaN(value)) {\n            // no value but %\n\n            const measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n\n            return size * measureRatio;\n        } else if (unit !== \"%\") {\n            return value;\n        }\n        return size * value / 100;\n    });\n}\nexport function getPosIndexesByDirection(direction: number[]) {\n    const indexes: number[] = [];\n\n    if (direction[1] >= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(3);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(2);\n        }\n    }\n    if (direction[1] <= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(1);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(0);\n        }\n    }\n    return indexes;\n}\nexport function getPosesByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n    return getPosIndexesByDirection(direction).map(index => poses[index]);\n}\nexport function getPosByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n    const nextPoses = getPosesByDirection(poses, direction);\n\n    return [\n        average(...nextPoses.map(pos => pos[0])),\n        average(...nextPoses.map(pos => pos[1])),\n    ];\n}\nexport function getPosByReverseDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos4)       [0, -1](pos3,pos4)       [1, -1](pos3)\n    [-1, 0](pos2, pos4)                           [1, 0](pos3, pos1)\n    [-1, 1](pos2)        [0, 1](pos1, pos2)       [1, 1](pos1)\n    */\n\n    return getPosByDirection(poses, direction.map(dir => -dir));\n}\n\nfunction getDist(\n    startPos: number[],\n    matrix: number[],\n    width: number,\n    height: number,\n    n: number,\n    direction: number[],\n) {\n    const poses = caculatePoses(matrix, width, height, n);\n    const pos = getPosByReverseDirection(poses, direction);\n    const distX = startPos[0] - pos[0];\n    const distY = startPos[1] - pos[1];\n\n    return [distX, distY];\n}\nexport function getNextMatrix(\n    offsetMatrix: number[],\n    targetMatrix: number[],\n    origin: number[],\n    n: number,\n) {\n    return multiply(\n        offsetMatrix,\n        getAbsoluteMatrix(targetMatrix, n, origin),\n        n,\n    );\n}\nexport function scaleMatrix(\n    state: MoveableManagerState<any>,\n    scale: number[],\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n        targetMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    return getNextMatrix(\n        offsetMatrix,\n        multiply(targetMatrix, createScaleMatrix(scale, n), n),\n        transformOrigin,\n        n,\n    );\n}\nexport function getScaleDist(\n    moveable: MoveableManagerInterface<any>,\n    scale: number[],\n    direction: number[],\n    fixedPosition: number[],\n) {\n    const state = moveable.state;\n    const {\n        is3d,\n        left,\n        top,\n        width,\n        height,\n    } = state;\n\n    const n = is3d ? 4 : 3;\n    const groupable = moveable.props.groupable;\n    const nextMatrix = scaleMatrix(moveable.state, scale);\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n\n    const dist = getDist(fixedPosition, nextMatrix, width, height, n, direction);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\n\nexport function getResizeDist(\n    moveable: MoveableManagerInterface<any>,\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPosition: number[],\n    transformOrigin: string[],\n) {\n    const {\n        groupable,\n    } = moveable.props;\n    const {\n        transformOrigin: prevOrigin,\n        targetMatrix,\n        offsetMatrix,\n        is3d,\n        width: prevWidth,\n        height: prevHeight,\n        left,\n        top,\n    } = moveable.state;\n\n    const n = is3d ? 4 : 3;\n    const nextOrigin = caculateTransformOrigin(\n        transformOrigin!,\n        width,\n        height,\n        prevWidth,\n        prevHeight,\n        prevOrigin,\n    );\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n    const dist = getDist(fixedPosition, nextMatrix, width, height, n, direction);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getStartDirection(\n    moveable: MoveableManagerInterface<ResizableProps>,\n    direction: number[],\n) {\n    if (!direction[0] && !direction[1]) {\n        return [0, 0];\n    }\n    const baseDirection = [-1, -1];\n    return [\n        direction[0] ? direction[0] : baseDirection[0] * -1,\n        direction[1] ? direction[1] : baseDirection[1] * -1,\n    ];\n}\nexport function getAbsoluteFixedPosition(\n    moveable: MoveableManagerInterface<ResizableProps>,\n    direction: number[],\n) {\n    return getPosByReverseDirection(getAbsolutePosesByState(moveable.state), direction);\n}\n","import { PREFIX, IS_WEBKIT, TINY_NUM } from \"./consts\";\nimport { prefixNames } from \"framework-utils\";\nimport { splitBracket, isUndefined, isObject, splitUnit, IObject } from \"@daybrush/utils\";\nimport {\n    multiply, invert,\n    convertDimension, createIdentityMatrix,\n    createOriginMatrix, convertPositionMatrix, caculate,\n    multiplies,\n    minus,\n    getOrigin,\n    createScaleMatrix,\n    plus,\n    getRad,\n    ignoreDimension,\n    convertCSStoMatrix,\n    convertMatrixtoCSS,\n} from \"./matrix\";\n\nimport MoveableManager from \"./MoveableManager\";\nimport {\n    MoveableManagerState, Able, MoveableClientRect,\n    MoveableProps, ControlPose, MoveableManagerInterface\n} from \"./types\";\nimport { getDragDist } from \"./DraggerUtils\";\n\nexport function round(num: number) {\n    return Math.round(num);\n}\nexport function multiply2(pos1: number[], pos2: number[]) {\n    return [\n        pos1[0] * pos2[0],\n        pos1[1] * pos2[1],\n    ];\n}\nexport function prefix(...classNames: string[]) {\n    return prefixNames(PREFIX, ...classNames);\n}\n\nexport function createIdentityMatrix3() {\n    return createIdentityMatrix(3);\n}\n\nexport function getTransformMatrix(transform: string | number[]) {\n    if (!transform || transform === \"none\") {\n        return [1, 0, 0, 1, 0, 0];\n\n    }\n    if (isObject(transform)) {\n        return transform;\n    }\n    const value = splitBracket(transform).value!;\n    return value.split(/s*,\\s*/g).map(v => parseFloat(v));\n}\nexport function getAbsoluteMatrix(matrix: number[], n: number, origin: number[]) {\n    return multiplies(\n        n,\n        createOriginMatrix(origin, n),\n        matrix,\n        createOriginMatrix(origin.map(a => -a), n),\n    );\n}\nexport function measureSVGSize(el: SVGElement, unit: string, isHorizontal: boolean) {\n    if (unit === \"%\") {\n        const viewBox = getSVGViewBox(el.ownerSVGElement!);\n        return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n    }\n    return 1;\n}\nexport function getBeforeTransformOrigin(el: SVGElement) {\n    const relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\n\n    return relativeOrigin.map((o, i) => {\n        const { value, unit } = splitUnit(o);\n\n        return value * measureSVGSize(el, unit, i === 0);\n    });\n}\nexport function getTransformOrigin(style: CSSStyleDeclaration) {\n    const transformOrigin = style.transformOrigin;\n\n    return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\nexport function getOffsetInfo(\n    el: SVGElement | HTMLElement | null | undefined,\n    lastParent: SVGElement | HTMLElement | null | undefined,\n    isParent?: boolean,\n) {\n    const body = document.body;\n    let target = !el || isParent ? el : el.parentElement;\n    let isEnd = false;\n    let position = \"relative\";\n\n    while (target && target !== body) {\n        if (lastParent === target) {\n            isEnd = true;\n        }\n        const style = getComputedStyle(target);\n        const transform = style.transform;\n        position = style.position!;\n\n        if (position !== \"static\" || (transform && transform !== \"none\")) {\n            break;\n        }\n        target = target.parentElement;\n        position = \"relative\";\n    }\n    return {\n        isStatic: position === \"static\",\n        isEnd: isEnd || !target || target === body,\n        offsetParent: target as HTMLElement || body,\n    };\n\n}\nexport function getOffsetPosInfo(\n    el: HTMLElement | SVGElement,\n    container: SVGElement | HTMLElement | null,\n    style: CSSStyleDeclaration,\n    isFixed: boolean,\n) {\n    const tagName = el.tagName.toLowerCase();\n    let offsetLeft = (el as HTMLElement).offsetLeft;\n    let offsetTop = (el as HTMLElement).offsetTop;\n\n    if (isFixed) {\n        const containerClientRect = (container || document.documentElement).getBoundingClientRect();\n\n        offsetLeft -= containerClientRect.left;\n        offsetTop -= containerClientRect.top;\n    }\n    // svg\n    const isSVG = isUndefined(offsetLeft);\n    let hasOffset = !isSVG;\n    let origin: number[];\n    let targetOrigin: number[];\n    // inner svg element\n    if (!hasOffset && tagName !== \"svg\") {\n        origin = IS_WEBKIT\n            ? getBeforeTransformOrigin(el as SVGElement)\n            : getTransformOrigin(style).map(pos => parseFloat(pos));\n\n        targetOrigin = origin.slice();\n        hasOffset = true;\n\n        if (tagName === \"g\") {\n            offsetLeft = 0;\n            offsetTop = 0;\n        } else {\n            [\n                offsetLeft, offsetTop, origin[0], origin[1],\n            ] = getSVGGraphicsOffset(el as SVGGraphicsElement, origin);\n        }\n    } else {\n        origin = getTransformOrigin(style).map(pos => parseFloat(pos));\n        targetOrigin = origin.slice();\n    }\n    return {\n        isSVG,\n        hasOffset,\n        offset: [offsetLeft, offsetTop],\n        origin,\n        targetOrigin,\n    };\n}\nexport function getMatrixStackInfo(\n    target: SVGElement | HTMLElement,\n    container: SVGElement | HTMLElement | null,\n    prevMatrix?: number[],\n) {\n    let el: SVGElement | HTMLElement | null = target;\n    const matrixes: number[][] = [];\n    let isEnd = false;\n    let is3d = false;\n    let n = 3;\n    let transformOrigin!: number[];\n    let targetTransformOrigin!: number[];\n    let targetMatrix!: number[];\n\n    const offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n\n    if (prevMatrix) {\n        isEnd = target === container;\n        if (prevMatrix.length > 10) {\n            is3d = true;\n            n = 4;\n        }\n        container = target.parentElement;\n    }\n\n    while (el && !isEnd) {\n        const style: CSSStyleDeclaration = getComputedStyle(el);\n        const tagName = el.tagName.toLowerCase();\n        const position = style.position;\n        const isFixed = position === \"fixed\";\n        let matrix: number[] = convertCSStoMatrix(getTransformMatrix(style.transform!));\n\n        // convert 3 to 4\n        const length = matrix.length;\n        if (!is3d && length === 16) {\n            is3d = true;\n            n = 4;\n            const matrixesLength = matrixes.length;\n\n            for (let i = 0; i < matrixesLength; ++i) {\n                matrixes[i] = convertDimension(matrixes[i], 3, 4);\n            }\n        }\n        if (is3d && length === 9) {\n            matrix = convertDimension(matrix, 3, 4);\n        }\n        const {\n            hasOffset,\n            isSVG,\n            origin,\n            targetOrigin,\n            offset: offsetPos,\n        } = getOffsetPosInfo(el, container, style, isFixed);\n        let [\n            offsetLeft,\n            offsetTop,\n        ] = offsetPos;\n        if (tagName === \"svg\" && targetMatrix) {\n            matrixes.push(\n                // scale matrix for svg's SVGElements.\n                getSVGMatrix(el as SVGSVGElement, n),\n                createIdentityMatrix(n),\n            );\n        }\n        const {\n            offsetParent,\n            isEnd: isOffsetEnd,\n            isStatic,\n        } = getOffsetInfo(el, container);\n\n        if (IS_WEBKIT && hasOffset && !isSVG && isStatic && (position === \"relative\" || position === \"static\")) {\n            offsetLeft -= offsetParent.offsetLeft;\n            offsetTop -= offsetParent.offsetTop;\n            isEnd = isEnd || isOffsetEnd;\n        }\n        let parentClientLeft = 0;\n        let parentClientTop = 0;\n\n        if (hasOffset && offsetContainer !== offsetParent) {\n            // border\n            parentClientLeft = offsetParent.clientLeft;\n            parentClientTop = offsetParent.clientTop;\n        }\n        matrixes.push(\n            // absolute matrix\n            getAbsoluteMatrix(matrix, n, origin),\n            // offset matrix (offsetPos + clientPos(border))\n            createOriginMatrix(hasOffset ? [\n                offsetLeft - el.scrollLeft + parentClientLeft,\n                offsetTop - el.scrollTop + parentClientTop,\n            ] : [el, origin] as any, n),\n        );\n        if (!targetMatrix) {\n            targetMatrix = matrix;\n        }\n        if (!transformOrigin) {\n            transformOrigin = origin;\n        }\n        if (!targetTransformOrigin) {\n            targetTransformOrigin = targetOrigin;\n        }\n        if (isEnd || isFixed) {\n            break;\n        } else {\n            el = offsetParent;\n            isEnd = isOffsetEnd;\n        }\n    }\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(n);\n    }\n    if (!transformOrigin) {\n        transformOrigin = [0, 0];\n    }\n    if (!targetTransformOrigin) {\n        targetTransformOrigin = [0, 0];\n    }\n    return {\n        offsetContainer,\n        matrixes,\n        targetMatrix,\n        transformOrigin,\n        targetTransformOrigin,\n        is3d,\n    };\n}\nexport function caculateMatrixStack(\n    target: SVGElement | HTMLElement,\n    container: SVGElement | HTMLElement | null,\n    rootContainer: SVGElement | HTMLElement | null,\n    prevMatrix?: number[],\n    prevRootMatrix?: number[],\n    prevN?: number,\n): [number[], number[], number[], number[], number[], string, number[], number[], boolean] {\n    const {\n        matrixes,\n        is3d,\n        targetMatrix: prevTargetMatrix,\n        transformOrigin,\n        targetTransformOrigin,\n        offsetContainer,\n    } = getMatrixStackInfo(target, container, prevMatrix);\n    const {\n        matrixes: rootMatrixes,\n        is3d: isRoot3d,\n    } = getMatrixStackInfo(offsetContainer, rootContainer, prevRootMatrix);\n\n    const n = isRoot3d || is3d ? 4 : 3;\n    const isSVGGraphicElement = target.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in target;\n    const originalContainer = container || document.body;\n    let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let targetMatrix = prevTargetMatrix;\n    let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);\n    let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let offsetMatrix = createIdentityMatrix(n);\n    const length = matrixes.length;\n    const endContainer = getOffsetInfo(originalContainer, originalContainer, true).offsetParent;\n\n    rootMatrixes.reverse();\n    matrixes.reverse();\n\n    if (!is3d && isRoot3d) {\n        targetMatrix = convertDimension(targetMatrix, 3, 4);\n        matrixes.forEach((matrix, i) => {\n            matrixes[i] = convertDimension(matrix, 3, 4);\n        });\n    }\n    if (is3d && !isRoot3d) {\n        rootMatrixes.forEach((matrix, i) => {\n            rootMatrixes[i] = convertDimension(matrix, 3, 4);\n        });\n    }\n\n    // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)\n    // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)\n    // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)\n\n    if (!prevRootMatrix) {\n        rootMatrixes.forEach(matrix => {\n            rootMatrix = multiply(rootMatrix, matrix, n);\n        });\n    }\n    matrixes.forEach((matrix, i) => {\n        if (length - 2 === i) {\n            // length - 3\n            beforeMatrix = allMatrix.slice();\n        }\n        if (length - 1 === i) {\n            // length - 2\n            offsetMatrix = allMatrix.slice();\n        }\n\n        // caculate for SVGElement\n        if (isObject(matrix[n * (n - 1)])) {\n            [matrix[n * (n - 1)], matrix[n * (n - 1) + 1]] =\n                getSVGOffset(\n                    matrix[n * (n - 1)] as any,\n                    endContainer,\n                    n,\n                    matrix[n * (n - 1) + 1] as any,\n                    allMatrix,\n                    matrixes[i + 1],\n                );\n        }\n        allMatrix = multiply(allMatrix, matrix, n);\n    });\n    const isMatrix3d = !isSVGGraphicElement && is3d;\n\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);\n    }\n    const transform = makeMatrixCSS(\n        isSVGGraphicElement && targetMatrix.length === 16\n            ? convertDimension(targetMatrix, 4, 3) : targetMatrix,\n        isMatrix3d,\n    );\n\n    rootMatrix = ignoreDimension(rootMatrix, n, n);\n    return [\n        rootMatrix,\n        beforeMatrix,\n        offsetMatrix,\n        allMatrix,\n        targetMatrix,\n        transform,\n        transformOrigin,\n        targetTransformOrigin,\n        is3d || isRoot3d,\n    ];\n}\nexport function makeMatrixCSS(matrix: number[], is3d: boolean = matrix.length > 9) {\n    return `${is3d ? \"matrix3d\" : \"matrix\"}(${convertMatrixtoCSS(matrix, !is3d).join(\",\")})`;\n}\nexport function getSVGViewBox(el: SVGSVGElement) {\n    const clientWidth = el.clientWidth;\n    const clientHeight = el.clientHeight;\n    const viewBox = el.viewBox;\n    const baseVal = (viewBox && viewBox.baseVal) || { x: 0, y: 0, width: 0, height: 0 };\n\n    return {\n        x: baseVal.x,\n        y: baseVal.y,\n        width: baseVal.width || clientWidth,\n        height: baseVal.height || clientHeight,\n    };\n}\nexport function getSVGMatrix(\n    el: SVGSVGElement,\n    n: number,\n) {\n    const clientWidth = el.clientWidth;\n    const clientHeight = el.clientHeight;\n    const {\n        width: viewBoxWidth,\n        height: viewBoxHeight,\n    } = getSVGViewBox(el);\n    const scaleX = clientWidth / viewBoxWidth;\n    const scaleY = clientHeight / viewBoxHeight;\n\n    const preserveAspectRatio = el.preserveAspectRatio.baseVal;\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n    const align = preserveAspectRatio.align;\n    // 1 : meet 2: slice\n    const meetOrSlice = preserveAspectRatio.meetOrSlice;\n    const svgOrigin = [0, 0];\n    const scale = [scaleX, scaleY];\n    const translate = [0, 0];\n\n    if (align !== 1) {\n        const xAlign = (align - 2) % 3;\n        const yAlign = Math.floor((align - 2) / 3);\n\n        svgOrigin[0] = viewBoxWidth * xAlign / 2;\n        svgOrigin[1] = viewBoxHeight * yAlign / 2;\n\n        const scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n\n        scale[0] = scaleDimension;\n        scale[1] = scaleDimension;\n\n        translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n        translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n    }\n    const scaleMatrix = createScaleMatrix(scale, n);\n    [\n        scaleMatrix[n * (n - 1)],\n        scaleMatrix[n * (n - 1) + 1],\n    ] = translate;\n\n    return getAbsoluteMatrix(\n        scaleMatrix,\n        n,\n        svgOrigin,\n    );\n}\nexport function getSVGGraphicsOffset(\n    el: SVGGraphicsElement,\n    origin: number[],\n) {\n    if (!el.getBBox) {\n        return [0, 0];\n    }\n    const bbox = el.getBBox();\n    const viewBox = getSVGViewBox(el.ownerSVGElement!);\n    const left = bbox.x - viewBox.x;\n    const top = bbox.y - viewBox.y;\n\n    return [\n        left,\n        top,\n        origin[0] - left,\n        origin[1] - top,\n    ];\n}\nexport function caculatePosition(matrix: number[], pos: number[], n: number) {\n    return caculate(matrix, convertPositionMatrix(pos, n), n);\n}\nexport function caculatePoses(matrix: number[], width: number, height: number, n: number) {\n    return [[0, 0], [width, 0], [0, height], [width, height]].map(pos => caculatePosition(matrix, pos, n));\n}\nexport function getRect(poses: number[][]) {\n    const posesX = poses.map(pos => pos[0]);\n    const posesY = poses.map(pos => pos[1]);\n    const left = Math.min(...posesX);\n    const top = Math.min(...posesY);\n    const right = Math.max(...posesX);\n    const bottom = Math.max(...posesY);\n    const rectWidth = right - left;\n    const rectHeight = bottom - top;\n\n    return {\n        left, top,\n        right, bottom,\n        width: rectWidth,\n        height: rectHeight,\n    };\n}\nexport function caculateRect(matrix: number[], width: number, height: number, n: number) {\n    const poses = caculatePoses(matrix, width, height, n);\n\n    return getRect(poses);\n}\nexport function getSVGOffset(\n    el: SVGElement,\n    container: HTMLElement | SVGElement,\n    n: number, origin: number[], beforeMatrix: number[], absoluteMatrix: number[]) {\n\n    const [width, height] = getSize(el, undefined, true);\n    const containerClientRect = container.getBoundingClientRect();\n    const rect = el.getBoundingClientRect();\n    const rectLeft = rect.left - containerClientRect.left + container.scrollLeft - (container.clientLeft || 0);\n    const rectTop = rect.top - containerClientRect.top + container.scrollTop - (container.clientTop || 0);\n    const rectWidth = rect.width;\n    const rectHeight = rect.height;\n    const mat = multiplies(\n        n,\n        beforeMatrix,\n        absoluteMatrix,\n    );\n    const {\n        left: prevLeft,\n        top: prevTop,\n        width: prevWidth,\n        height: prevHeight,\n    } = caculateRect(mat, width, height, n);\n    const posOrigin = caculatePosition(mat, origin, n);\n    const prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n    const rectOrigin = [\n        rectLeft + prevOrigin[0] * rectWidth / prevWidth,\n        rectTop + prevOrigin[1] * rectHeight / prevHeight,\n    ];\n    const offset = [0, 0];\n    let count = 0;\n\n    while (++count < 10) {\n        const inverseBeforeMatrix = invert(beforeMatrix, n);\n        [offset[0], offset[1]] = minus(\n            caculatePosition(inverseBeforeMatrix, rectOrigin, n),\n            caculatePosition(inverseBeforeMatrix, posOrigin, n),\n        );\n        const mat2 = multiplies(\n            n,\n            beforeMatrix,\n            createOriginMatrix(offset, n),\n            absoluteMatrix,\n        );\n        const {\n            left: nextLeft,\n            top: nextTop,\n        } = caculateRect(mat2, width, height, n);\n        const distLeft = nextLeft - rectLeft;\n        const distTop = nextTop - rectTop;\n\n        if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {\n            break;\n        }\n        rectOrigin[0] -= distLeft;\n        rectOrigin[1] -= distTop;\n    }\n    return offset.map(p => Math.round(p));\n}\nexport function caculateMoveablePosition(matrix: number[], origin: number[], width: number, height: number): [\n    number[],\n    number[],\n    number[][],\n    1 | -1,\n] {\n    const is3d = matrix.length === 16;\n    const n = is3d ? 4 : 3;\n    let [\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n        [x4, y4],\n    ] = caculatePoses(matrix, width, height, n);\n    let [originX, originY] = caculatePosition(matrix, origin, n);\n\n    const left = Math.min(x1, x2, x3, x4);\n    const top = Math.min(y1, y2, y3, y4);\n    const right = Math.max(x1, x2, x3, x4);\n    const bottom = Math.max(y1, y2, y3, y4);\n\n    x1 = (x1 - left) || 0;\n    x2 = (x2 - left) || 0;\n    x3 = (x3 - left) || 0;\n    x4 = (x4 - left) || 0;\n\n    y1 = (y1 - top) || 0;\n    y2 = (y2 - top) || 0;\n    y3 = (y3 - top) || 0;\n    y4 = (y4 - top) || 0;\n\n    originX = (originX - left) || 0;\n    originY = (originY - top) || 0;\n\n    const center = [\n        (x1 + x2 + x3 + x4) / 4,\n        (y1 + y2 + y3 + y4) / 4,\n    ];\n    const pos1Rad = getRad(center, [x1, y1]);\n    const pos2Rad = getRad(center, [x2, y2]);\n    const direction =\n        (pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI) || (pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI)\n            ? 1 : -1;\n\n    return [\n        [left, top, right, bottom],\n        [originX, originY],\n        [[x1, y1], [x2, y2], [x3, y3], [x4, y4]],\n        direction,\n    ];\n}\nexport function getDistSize(vec: number[]) {\n    return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nexport function getDiagonalSize(pos1: number[], pos2: number[]) {\n    return getDistSize([\n        pos2[0] - pos1[0],\n        pos2[1] - pos1[1],\n    ]);\n}\nexport function getLineStyle(pos1: number[], pos2: number[], rad: number = getRad(pos1, pos2)) {\n    const width = getDiagonalSize(pos1, pos2);\n\n    return {\n        transform: `translateY(-50%) translate(${pos1[0]}px, ${pos1[1]}px) rotate(${rad}rad)`,\n        width: `${width}px`,\n    };\n}\nexport function getControlTransform(rotation: number, ...poses: number[][]) {\n    const length = poses.length;\n\n    const x = poses.reduce((prev, pos) => prev + pos[0], 0) / length;\n    const y = poses.reduce((prev, pos) => prev + pos[1], 0) / length;\n    return {\n        transform: `translate(${x}px, ${y}px) rotate(${rotation}rad)`,\n    };\n}\nexport function getCSSSize(target: SVGElement | HTMLElement) {\n    const style = window.getComputedStyle(target);\n\n    return [\n        parseFloat(style.width!),\n        parseFloat(style.height!),\n    ];\n}\nexport function getSize(\n    target: SVGElement | HTMLElement,\n    style: CSSStyleDeclaration = window.getComputedStyle(target),\n    isOffset?: boolean,\n    isBoxSizing: boolean = isOffset || style.boxSizing === \"border-box\",\n) {\n    let width = (target as HTMLElement).offsetWidth;\n    let height = (target as HTMLElement).offsetHeight;\n    const hasOffset = !isUndefined(width);\n\n    if ((isOffset || isBoxSizing) && hasOffset) {\n        return [width, height];\n    }\n    if (!hasOffset && target.tagName.toLowerCase() !== \"svg\") {\n        const bbox = (target as SVGGraphicsElement).getBBox();\n        return [bbox.width, bbox.height];\n    }\n\n    width = target.clientWidth;\n    height = target.clientHeight;\n\n    if (isOffset || isBoxSizing) {\n        const borderLeft = parseFloat(style.borderLeftWidth!) || 0;\n        const borderRight = parseFloat(style.borderRightWidth!) || 0;\n        const borderTop = parseFloat(style.borderTopWidth!) || 0;\n        const borderBottom = parseFloat(style.borderBottomWidth!) || 0;\n\n        return [\n            width + borderLeft + borderRight,\n            height + borderTop + borderBottom,\n        ];\n    } else {\n        const paddingLeft = parseFloat(style.paddingLeft!) || 0;\n        const paddingRight = parseFloat(style.paddingRight!) || 0;\n        const paddingTop = parseFloat(style.paddingTop!) || 0;\n        const paddingBottom = parseFloat(style.paddingBottom!) || 0;\n\n        return [\n            width - paddingLeft - paddingRight,\n            height - paddingTop - paddingBottom,\n        ];\n    }\n}\nexport function getRotationRad(\n    poses: number[][],\n    direction: number,\n) {\n    return getRad(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\nexport function getTargetInfo(\n    moveableElement?: HTMLElement,\n    target?: HTMLElement | SVGElement,\n    container?: HTMLElement | SVGElement | null,\n    parentContainer?: HTMLElement | SVGElement | null,\n    rootContainer?: HTMLElement | SVGElement | null,\n    state?: Partial<MoveableManagerState> | false | undefined,\n): Partial<MoveableManagerState> {\n    let left = 0;\n    let top = 0;\n    let right = 0;\n    let bottom = 0;\n    let origin = [0, 0];\n    let poses = [[0, 0], [0, 0], [0, 0], [0, 0]];\n    let rootMatrix = createIdentityMatrix3();\n    let offsetMatrix = createIdentityMatrix3();\n    let beforeMatrix = createIdentityMatrix3();\n    let matrix = createIdentityMatrix3();\n    let targetMatrix = createIdentityMatrix3();\n    let width = 0;\n    let height = 0;\n    let transformOrigin = [0, 0];\n    let direction: 1 | -1 = 1;\n    let beforeDirection: 1 | -1 = 1;\n    let is3d = false;\n    let targetTransform = \"\";\n    let beforeOrigin = [0, 0];\n    let targetClientRect = resetClientRect();\n    let containerClientRect = resetClientRect();\n    let moveableClientRect = resetClientRect();\n    let targetOrigin = [0, 0];\n    let rotation = 0;\n\n    const prevMatrix = state ? state.beforeMatrix : undefined;\n    const prevRootMatrix = state ? state.rootMatrix : undefined;\n    const prevN = state ? (state.is3d ? 4 : 3) : undefined;\n\n    if (target) {\n        if (state) {\n            width = state.width!;\n            height = state.height!;\n        } else {\n            const style = getComputedStyle(target);\n\n            width = (target as HTMLElement).offsetWidth;\n            height = (target as HTMLElement).offsetHeight;\n\n            if (isUndefined(width)) {\n                [width, height] = getSize(target, style, true);\n            }\n        }\n        [\n            rootMatrix,\n            beforeMatrix,\n            offsetMatrix,\n            matrix,\n            targetMatrix,\n            targetTransform,\n            transformOrigin,\n            targetOrigin,\n            is3d,\n        ] = caculateMatrixStack(\n            target, container!, rootContainer!,\n            prevMatrix, prevRootMatrix, prevN,\n        );\n\n        [\n            [left, top, right, bottom],\n            origin,\n            poses,\n            direction,\n        ] = caculateMoveablePosition(matrix, transformOrigin, width, height);\n\n        const n = is3d ? 4 : 3;\n        let beforePos = [0, 0];\n\n        [\n            beforePos, beforeOrigin, , beforeDirection,\n        ] = caculateMoveablePosition(offsetMatrix, plus(transformOrigin, getOrigin(targetMatrix, n)), width, height);\n\n        beforeOrigin = [\n            beforeOrigin[0] + beforePos[0] - left,\n            beforeOrigin[1] + beforePos[1] - top,\n        ];\n\n        targetClientRect = getClientRect(target);\n        containerClientRect = getClientRect(\n            getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body,\n            true,\n        );\n        if (moveableElement) {\n            moveableClientRect = getClientRect(moveableElement);\n        }\n        rotation = getRotationRad([poses[0], poses[1]], direction);\n    }\n\n    return {\n        rotation,\n        targetClientRect,\n        containerClientRect,\n        moveableClientRect,\n        beforeDirection,\n        direction,\n        target,\n        left,\n        top,\n        right,\n        bottom,\n        pos1: poses[0],\n        pos2: poses[1],\n        pos3: poses[2],\n        pos4: poses[3],\n        width,\n        height,\n        rootMatrix,\n        beforeMatrix,\n        offsetMatrix,\n        targetMatrix,\n        matrix,\n        targetTransform,\n        is3d,\n        beforeOrigin,\n        origin,\n        transformOrigin,\n        targetOrigin,\n    };\n}\nexport function resetClientRect(): MoveableClientRect {\n    return {\n        left: 0, right: 0,\n        top: 0, bottom: 0,\n        width: 0, height: 0,\n        clientLeft: 0, clientTop: 0,\n        clientWidth: 0, clientHeight: 0,\n        scrollWidth: 0, scrollHeight: 0,\n    };\n}\nexport function getClientRect(el: HTMLElement | SVGElement, isExtends?: boolean) {\n    const { left, width, top, bottom, right, height } = el.getBoundingClientRect();\n\n    const rect: MoveableClientRect = {\n        left,\n        right,\n        top,\n        bottom,\n        width,\n        height,\n    };\n\n    if (isExtends) {\n        rect.clientLeft = el.clientLeft;\n        rect.clientTop = el.clientTop;\n        rect.clientWidth = el.clientWidth;\n        rect.clientHeight = el.clientHeight;\n        rect.scrollWidth = el.scrollWidth;\n        rect.scrollHeight = el.scrollHeight;\n    }\n    return rect;\n}\nexport function getDirection(target: SVGElement | HTMLElement) {\n    if (!target) {\n        return;\n    }\n    const direciton = target.getAttribute(\"data-direction\")!;\n\n    if (!direciton) {\n        return;\n    }\n    const dir = [0, 0];\n\n    (direciton.indexOf(\"w\") > -1) && (dir[0] = -1);\n    (direciton.indexOf(\"e\") > -1) && (dir[0] = 1);\n    (direciton.indexOf(\"n\") > -1) && (dir[1] = -1);\n    (direciton.indexOf(\"s\") > -1) && (dir[1] = 1);\n\n    return dir;\n}\nexport function getAbsolutePoses(poses: number[][], dist: number[]) {\n    return [\n        plus(dist, poses[0]),\n        plus(dist, poses[1]),\n        plus(dist, poses[2]),\n        plus(dist, poses[3]),\n    ];\n}\nexport function getAbsolutePosesByState({\n    left,\n    top,\n    pos1,\n    pos2,\n    pos3,\n    pos4,\n}: {\n    left: number,\n    top: number,\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    pos4: number[],\n}) {\n    return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\nexport function roundSign(num: number) {\n    return Math.round(num % 1 === -0.5 ? num - 1 : num);\n}\nexport function throttle(num: number, unit: number) {\n    if (!unit) {\n        return num;\n    }\n    return Math.round(num / unit) * unit;\n}\nexport function throttleArray(nums: number[], unit: number) {\n    nums.forEach((_, i) => {\n        nums[i] = throttle(nums[i], unit);\n    });\n    return nums;\n}\n\nexport function unset(self: any, name: string) {\n    if (self[name]) {\n        self[name].unset();\n        self[name] = null;\n    }\n}\n\nexport function getOrientationDirection(pos: number[], pos1: number[], pos2: number[]) {\n    return (pos[0] - pos1[0]) * (pos2[1] - pos1[1]) - (pos[1] - pos1[1]) * (pos2[0] - pos1[0]);\n}\nexport function isInside(pos: number[], pos1: number[], pos2: number[], pos3: number[], pos4: number[]) {\n    const k1 = getOrientationDirection(pos, pos1, pos2);\n    const k2 = getOrientationDirection(pos, pos2, pos3);\n    const k3 = getOrientationDirection(pos, pos3, pos1);\n\n    const k4 = getOrientationDirection(pos, pos2, pos3);\n    const k5 = getOrientationDirection(pos, pos3, pos4);\n    const k6 = getOrientationDirection(pos, pos4, pos2);\n    const signs1 = [k1, k2, k3];\n    const signs2 = [k4, k5, k6];\n\n    if (\n        signs1.every(sign => sign >= 0)\n        || signs1.every(sign => sign <= 0)\n        || signs2.every(sign => sign >= 0)\n        || signs2.every(sign => sign <= 0)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nexport function fillParams<T extends IObject<any>>(\n    moveable: any,\n    e: any,\n    params: Pick<T, Exclude<keyof T, \"target\" | \"clientX\" | \"clientY\" | \"inputEvent\" | \"datas\" | \"currentTarget\">>,\n): T {\n    const datas = e.datas;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n    const nextParams = {\n        ...params,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        datas: datas.datas,\n    } as any;\n\n    if (datas.isStartEvent) {\n        datas.lastEvent = nextParams;\n    } else {\n        datas.isStartEvent = true;\n    }\n    return nextParams;\n}\nexport function fillEndParams<T extends IObject<any>>(\n    moveable: any,\n    e: any,\n    params: Pick<T, Exclude<\n        keyof T,\n        \"target\" | \"clientX\" | \"clientY\" | \"inputEvent\" |\n        \"datas\" | \"currentTarget\" | \"lastEvent\" | \"isDrag\" | \"isDouble\">\n    > & { isDrag?: boolean },\n): T {\n    const datas = e.datas;\n    const isDrag = \"isDrag\" in params ? params.isDrag : e.isDrag;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n\n    return {\n        isDrag,\n        ...params,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        lastEvent: datas.lastEvent,\n        isDouble: e.isDouble,\n        datas: datas.datas,\n    } as any;\n}\n\nexport function triggerEvent<T extends IObject<any> = MoveableProps, U extends keyof T = string>(\n    moveable: any,\n    name: U & string,\n    params: T[U] extends ((e: infer P) => any) | undefined ? P : IObject<any>,\n    isManager?: boolean,\n): any {\n    if (isManager) {\n        MoveableManager.prototype.triggerEvent.call(moveable, name, params);\n    }\n    return moveable.triggerEvent(name, params);\n}\n\nexport function getComputedStyle(el: HTMLElement | SVGElement, pseudoElt?: string | null) {\n    return window.getComputedStyle(el, pseudoElt);\n}\n\nexport function filterAbles(\n    ables: Able[], methods: Array<keyof Able>,\n    triggerAblesSimultaneously?: boolean,\n) {\n    const enabledAbles: IObject<boolean> = {};\n    const ableGroups: IObject<boolean> = {};\n\n    return ables.filter(able => {\n        const name = able.name;\n\n        if (enabledAbles[name] || !methods.some(method => able[method])) {\n            return false;\n        }\n        if (!triggerAblesSimultaneously && able.ableGroup) {\n            if (ableGroups[able.ableGroup]) {\n                return false;\n            }\n            ableGroups[able.ableGroup] = true;\n        }\n        enabledAbles[name] = true;\n        return true;\n    });\n}\n\nexport function getKeepRatioHeight(width: number, isWidth: boolean, ratio: number) {\n    return width * (isWidth ? ratio : 1 / ratio);\n}\nexport function getKeepRatioWidth(height: number, isWidth: boolean, ratio: number) {\n    return height * (isWidth ? 1 / ratio : ratio);\n}\n\nexport function equals(a1: any, a2: any) {\n    return a1 === a2 || (a1 == null && a2 == null);\n}\n\nexport function selectValue<T = any>(...values: any[]): T {\n    const length = values.length - 1;\n    for (let i = 0; i < length; ++i) {\n        const value = values[i];\n\n        if (!isUndefined(value)) {\n            return value;\n        }\n    }\n\n    return values[length];\n}\n\nexport function groupBy<T>(arr: T[], func: (el: T, index: number, arr: T[]) => any) {\n    const groups: T[][] = [];\n    const groupKeys: any[] = [];\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n        const keyIndex = groupKeys.indexOf(groupKey);\n        const group = groups[keyIndex] || [];\n\n        if (keyIndex === -1) {\n            groupKeys.push(groupKey);\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nexport function groupByMap<T>(arr: T[], func: (el: T, index: number, arr: T[]) => string | number) {\n    const groups: T[][] = [];\n    const groupKeys: IObject<T[]> = {};\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n        let group = groupKeys[groupKey];\n\n        if (!group) {\n            group = [];\n            groupKeys[groupKey] = group;\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nexport function flat<T>(arr: T[][]): T[] {\n    return arr.reduce((prev, cur) => {\n        return prev.concat(cur);\n    }, []);\n}\n\nexport function equalSign(a: number, b: number) {\n    return (a >= 0 && b >= 0) || (a < 0 && b < 0);\n}\n\nexport function maxOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(b) - Math.abs(a));\n\n    return args[0];\n}\nexport function minOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(a) - Math.abs(b));\n\n    return args[0];\n}\n\nexport function caculateInversePosition(matrix: number[], pos: number[], n: number) {\n    return caculate(\n        invert(matrix, n),\n        convertPositionMatrix(pos, n),\n        n,\n    );\n}\nexport function convertDragDist(state: MoveableManagerState, e: any) {\n    const {\n        is3d,\n        rootMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n    [\n        e.distX, e.distY,\n    ] = caculateInversePosition(rootMatrix, [e.distX, e.distY], n);\n\n    return e;\n}\n\nexport function caculatePadding(\n    matrix: number[], pos: number[],\n    transformOrigin: number[], origin: number[], n: number,\n) {\n    return minus(caculatePosition(matrix, plus(transformOrigin, pos), n), origin);\n}\nexport function checkSize(targetSize: number[], compareSize: number[], isMax: boolean) {\n    return [\n        [compareSize[0], compareSize[0] * targetSize[1] / targetSize[0]],\n        [compareSize[1] * targetSize[0] / targetSize[1], compareSize[1]],\n    ].filter(size => size.every((value, i) => {\n        return isMax ? value <= compareSize[i] : value >= compareSize[i];\n    }))[0] || targetSize;\n}\nexport function caculateBoundSize(\n    size: number[], minSize: number[],\n    maxSize: number[], keepRatio?: boolean,\n) {\n    if (!keepRatio) {\n        return size.map((value, i) => Math.min(maxSize[i], Math.max(value, minSize[i])));\n    }\n    let [width, height] = size;\n    // width : height = minWidth : minHeight;\n    const [minWidth, minHeight] = checkSize(size, minSize, false);\n    const [maxWidth, maxHeight] = checkSize(size, maxSize, true);\n\n    if (width < minWidth || height < minHeight) {\n        width = minWidth;\n        height = minHeight;\n    } else if (width > maxWidth || height > maxHeight) {\n        width = maxWidth;\n        height = maxHeight;\n    }\n    return [width, height];\n}\n\nexport function getUnitSize(pos: string, size: number) {\n    const { value, unit } = splitUnit(pos);\n\n    return unit === \"%\" ? value * size / 100 : value;\n}\n\nexport function convertCSSSize(value: number, size: number, isRelative?: boolean) {\n    return isRelative ? `${value / size * 100}%` : `${value}px`;\n}\n\nexport function moveControlPos(\n    controlPoses: ControlPose[],\n    nextPoses: number[][],\n    index: number,\n    distX: number,\n    distY: number,\n) {\n    const { direction, pos, horizontal, vertical, sub } = controlPoses[index];\n    const dist = [\n        distX * Math.abs(horizontal),\n        distY * Math.abs(vertical),\n    ];\n    if (direction && !sub) {\n        direction.split(\"\").forEach(dir => {\n            const isVertical = dir === \"n\" || dir === \"s\";\n\n            controlPoses.forEach((controlPose, i) => {\n                const {\n                    direction: dirDir,\n                    horizontal: dirHorizontal,\n                    vertical: dirVertical,\n                    pos: controlPos,\n                } = controlPose;\n\n                if (!dirDir || dirDir.indexOf(dir) === -1) {\n                    return;\n                }\n                nextPoses[i] = plus(controlPos, [\n                    isVertical || !dirHorizontal ? 0 : dist[0],\n                    !isVertical || !dirVertical ? 0 : dist[1],\n                ]);\n            });\n        });\n    } else {\n        nextPoses[index] = plus(pos, dist);\n    }\n}\n\nexport function caculatePointerDist(moveable: MoveableManagerInterface, e: any) {\n    const { clientX, clientY, datas } = e;\n    const {\n        moveableClientRect,\n        rootMatrix,\n        is3d,\n        pos1,\n    } = moveable.state;\n    const { left, top } = moveableClientRect;\n    const n = is3d ? 4 : 3;\n    const [posX, posY] = minus(caculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1);\n    const [distX, distY] = getDragDist({ datas, distX: posX, distY: posY });\n\n    return [distX, distY];\n}\n\nexport function getTinyDist(v: number) {\n    return  Math.abs(v) <= TINY_NUM ? 0 : v;\n}\n","import { triggerEvent, fillParams } from \"../utils\";\nimport { IObject } from \"@daybrush/utils\";\nimport { MoveableManagerInterface } from \"../types\";\n\nexport function triggerRenderStart(\n    moveable: MoveableManagerInterface<any, any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.isPinch,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent<any>(moveable, `onRender${eventAffix}Start`, params);\n}\nexport function triggerRender(\n    moveable: MoveableManagerInterface<any, any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.isPinch,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent<any>(moveable, `onRender${eventAffix}`, params);\n}\nexport function triggerRenderEnd(\n    moveable: MoveableManagerInterface<any, any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.sPinch,\n        isDrag: e.isDrag,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent<any>(moveable, `onRender${eventAffix}End`, params);\n}\n","import { Able, MoveableManagerInterface, MoveableGroupInterface } from \"./types\";\nimport { IObject } from \"@daybrush/utils\";\nimport { triggerRenderStart, triggerRenderEnd, triggerRender } from \"./ables/triggerRender\";\nimport { convertDragDist } from \"./utils\";\nimport Dragger from \"@daybrush/drag\";\n\nexport function triggerAble<T extends IObject<any>>(\n    moveable: MoveableManagerInterface<any, any>,\n    ableType: string,\n    eventOperation: string,\n    eventAffix: string,\n    eventType: any,\n    e: any,\n    requestInstant?: boolean,\n) {\n    const isStart = eventType === \"Start\";\n    const target = moveable.state.target;\n\n    if (\n        !target\n        || (isStart && eventAffix.indexOf(\"Control\") > -1\n            && !e.isRequest && moveable.areaElement === e.inputEvent.target)\n    ) {\n        return false;\n    }\n    const eventName = `${eventOperation}${eventAffix}${eventType}`;\n    const conditionName = `${eventOperation}${eventAffix}Condition`;\n    const isEnd = eventType === \"End\";\n    const isAfter = eventType.indexOf(\"After\") > -1;\n    const isFirstStart = isStart && (\n        !moveable.targetDragger || !moveable.controlDragger\n        || (!moveable.targetDragger.isFlag() || !moveable.controlDragger.isFlag())\n    );\n\n    if (isFirstStart) {\n        moveable.updateRect(eventType, true, false);\n    }\n    if (eventType === \"\" && !isAfter) {\n        convertDragDist(moveable.state, e);\n    }\n    const isGroup = eventAffix.indexOf(\"Group\") > -1;\n    const ables: Able[] = (moveable as any)[ableType].slice();\n\n    if (e.isRequest) {\n        const requestAble = e.requestAble;\n        if (!ables.some(able => able.name === requestAble)) {\n            ables.push(...moveable.props.ables!.filter(able => able.name === requestAble));\n        }\n    }\n\n    if (!ables.length) {\n        return false;\n    }\n    const events = ables.filter((able: any) => able[eventName]);\n    const datas = e.datas;\n    const renderDatas = datas.render || (datas.render = {});\n    const renderEvent = { ...e, datas: renderDatas, originalDatas: datas };\n\n    if (isFirstStart) {\n        events.forEach(able => {\n            able.unset && able.unset(moveable);\n        });\n    }\n    const results = events.filter((able: any) => {\n        const hasCondition = isStart && able[conditionName];\n        const ableName = able.name;\n        const nextDatas = datas[ableName] || (datas[ableName] = {});\n\n        if (!hasCondition || able[conditionName](e, moveable)) {\n            return able[eventName](moveable, { ...e, datas: nextDatas, originalDatas: datas });\n        }\n        return false;\n    });\n    const isUpdate = results.length;\n\n    if (isStart) {\n        if (events.length && !isUpdate) {\n            moveable.state.dragger = null;\n\n            if ((moveable as MoveableGroupInterface).moveables) {\n                (moveable as MoveableGroupInterface).moveables.forEach(childeMoveable => {\n                    childeMoveable.state.dragger = null;\n                });\n            }\n\n            return false;\n        }\n        triggerRenderStart(moveable, isGroup, renderEvent);\n    } else if (isEnd) {\n        triggerRenderEnd(moveable, isGroup, renderEvent);\n    } else if (!isAfter || isUpdate) {\n        triggerRender(moveable, isGroup, renderEvent);\n    }\n    if (isEnd) {\n        moveable.state.dragger = null;\n    }\n    if (moveable.isUnmounted) {\n        return false;\n    }\n    if ((!isStart && isUpdate && !requestInstant) || isEnd) {\n        if (results.some(able => able.updateRect) && !isGroup) {\n            moveable.updateRect(eventType, false, false);\n        } else {\n            moveable.updateRect(eventType, true, false);\n        }\n        moveable.forceUpdate();\n    }\n    if (!isStart && !isEnd && !isAfter && isUpdate) {\n        triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + \"After\", e);\n    }\n}\n\nexport function getTargetAbleDragger<T>(\n    moveable: MoveableManagerInterface<T>,\n    moveableTarget: HTMLElement | SVGElement,\n    eventAffix: string,\n) {\n    const controlBox = moveable.controlBox.getElement();\n    const targets: Array<HTMLElement | SVGElement> = [];\n\n    targets.push(controlBox);\n\n    if (!moveable.props.dragArea) {\n        targets.push(moveableTarget);\n    }\n\n    const startFunc = (e: any) => {\n        const eventTarget = e.inputEvent.target;\n        const areaElement = moveable.areaElement;\n\n        return eventTarget === areaElement\n            || !moveable.isMoveableElement(eventTarget)\n            || eventTarget.className.indexOf(\"moveable-area\") > -1\n            || eventTarget.className.indexOf(\"moveable-padding\") > -1;\n    };\n\n    return getAbleDragger(moveable, targets, \"targetAbles\", eventAffix, {\n        dragstart: startFunc,\n        pinchstart: startFunc,\n    });\n}\nexport function getAbleDragger<T>(\n    moveable: MoveableManagerInterface<T>,\n    target: HTMLElement | SVGElement | Array<HTMLElement | SVGElement>,\n    ableType: string,\n    eventAffix: string,\n    conditionFunctions: IObject<any> = {},\n) {\n    const {\n        pinchOutside,\n        pinchThreshold,\n    } = moveable.props;\n    const options: IObject<any> = {\n        container: window,\n        pinchThreshold,\n        pinchOutside,\n    };\n    [\"drag\", \"pinch\"].forEach(eventOperation => {\n        [\"Start\", \"\", \"End\"].forEach(eventType => {\n            const eventName = `${eventOperation}${eventType.toLowerCase()}`;\n            options[eventName]\n                = (e: any) => {\n                    if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {\n                        return false;\n                    }\n                    return triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);\n                };\n        });\n    });\n\n    return new Dragger(target!, options);\n}\n","import { triggerEvent, fillParams, fillEndParams } from \"../utils\";\nimport {\n    PinchableProps, Able, SnappableState,\n    OnPinchStart, OnPinch, OnPinchEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\n\n/**\n * @namespace Moveable.Pinchable\n * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n */\nexport default {\n    name: \"pinchable\",\n    updateRect: true,\n    props: {\n        pinchable: Boolean,\n    } as const,\n    events: {\n        onPinchStart: \"pinchStart\",\n        onPinch: \"pinch\",\n        onPinchEnd: \"pinchEnd\",\n        onPinchGroupStart: \"pinchGroupStart\",\n        onPinchGroup: \"pinchGroup\",\n        onPinchGroupEnd: \"pinchGroupEnd\",\n    } as const,\n    pinchStart(\n        moveable: MoveableManagerInterface<PinchableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, targets, angle } = e;\n        const { pinchable, ables } = moveable.props;\n\n        if (!pinchable) {\n            return false;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}Start` as \"onPinchStart\";\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlStart` as \"dragControlStart\";\n\n        const pinchAbles = (pinchable === true ? moveable.controlAbles : ables!.filter(able => {\n            return pinchable.indexOf(able.name as any) > -1;\n        })).filter(able => able.canPinch && able[controlEventName]);\n\n        const params = fillParams<OnPinchStart>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const result = triggerEvent(moveable, eventName, params);\n\n        datas.isPinch = result !== false;\n        datas.ables = pinchAbles;\n\n        const isPinch = datas.isPinch;\n\n        if (!isPinch) {\n            return false;\n        }\n        pinchAbles.forEach(able => {\n            datas[able.name + \"Datas\"] = {};\n\n            if (!able[controlEventName]) {\n                return;\n            }\n            const ableEvent: any = {\n                ...e,\n                datas: datas[able.name + \"Datas\"],\n                parentRotate: angle,\n                isPinch: true,\n            };\n            able[controlEventName]!(moveable, ableEvent);\n        });\n\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            direction: [0, 0],\n        };\n        return isPinch;\n    },\n    pinch(\n        moveable: MoveableManagerInterface<PinchableProps>,\n        e: any,\n    ) {\n        const {\n            datas, scale: pinchScale, distance,\n            inputEvent, targets,\n            angle,\n        } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const parentDistance = distance * (1 - 1 / pinchScale);\n        const params = fillParams<OnPinch>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}` as \"onPinch\";\n        triggerEvent(moveable, eventName, params);\n\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}Control` as \"dragControl\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                datas: datas[able.name + \"Datas\"],\n                inputEvent,\n                parentDistance,\n                parentRotate: angle,\n                isPinch: true,\n            } as any);\n        });\n        return params;\n    },\n    pinchEnd(\n        moveable: MoveableManagerInterface<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, isPinch, inputEvent, targets } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}End` as \"onPinchEnd\";\n\n        const params = fillEndParams<OnPinchEnd>(moveable, e, { isDrag: isPinch }) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlEnd` as \"dragControlEnd\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                isDrag: isPinch,\n                datas: datas[able.name + \"Datas\"],\n                inputEvent,\n                isPinch: true,\n            } as any);\n        });\n        return isPinch;\n    },\n    pinchGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        return this.pinchStart(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.pinch(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroupEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.pinchEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n};\n\n/**\n * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n * @name Moveable.Pinchable#pinchable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.pinchable = true;\n */\n\n/**\n * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart\n * @memberof Moveable.Pinchable\n * @event pinchStart\n * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When pinching, the pinch event is called with part of scale, rotate, resize\n * @memberof Moveable.Pinchable\n * @event pinch\n * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinch\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotate\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scale\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When the pinch finishes, the pinchEnd event is called.\n * @memberof Moveable.Pinchable\n * @event pinchEnd\n * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleEnd\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When the group pinch starts, the `pinchGroupStart` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupStart\n * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupStart\", ({ targets }) => {\n *     console.log(\"onPinchGroupStart\", targets);\n * });\n */\n\n/**\n * When the group pinch, the `pinchGroup` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroup\n * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroup\", ({ targets, events }) => {\n *     console.log(\"onPinchGroup\", targets);\n * });\n */\n\n/**\n * When the group pinch finishes, the `pinchGroupEnd` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupEnd\n * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onPinchGroupEnd\", targets, isDrag);\n * });\n */\n","import { MoveableManagerState, OnCustomDrag } from \"./types\";\nimport { convertDragDist } from \"./utils\";\n\nexport function setCustomDrag(\n    state: MoveableManagerState<any>,\n    delta: number[],\n    inputEvent: any,\n    isPinch: boolean,\n    isConvert: boolean,\n) {\n    const result = state.dragger!.move(delta, inputEvent);\n    const datas = result.originalDatas || result.datas;\n    const draggableDatas = datas.draggable || (datas.draggable = {});\n\n    return {\n        ...(isConvert ? convertDragDist(state, result) : result),\n        isDrag: true,\n        isPinch: !!isPinch,\n        parentEvent: true,\n        datas: draggableDatas,\n    };\n}\n\nexport default class CustomDragger {\n    private prevX = 0;\n    private prevY = 0;\n    private startX = 0;\n    private startY = 0;\n    private isDrag = false;\n    private isFlag = false;\n    private datas: any = {\n        draggable: {},\n    };\n\n    public dragStart(client: number[], inputEvent: any) {\n        this.isDrag = false;\n        this.isFlag = false;\n        this.datas = {\n            draggable: {},\n        };\n        return {\n            ...this.move(client, inputEvent),\n            type: \"dragstart\",\n        };\n    }\n    public drag(client: number[], inputEvent: any) {\n        return this.move([\n            client[0] - this.prevX,\n            client[1] - this.prevY,\n        ], inputEvent);\n    }\n    public move(delta: number[], inputEvent: any): OnCustomDrag {\n        let clientX!: number;\n        let clientY!: number;\n        if (!this.isFlag) {\n            this.prevX = delta[0];\n            this.prevY = delta[1];\n            this.startX = delta[0];\n            this.startY = delta[1];\n\n            clientX = delta[0];\n            clientY = delta[1];\n\n            this.isFlag = true;\n        } else {\n\n            clientX = this.prevX + delta[0];\n            clientY = this.prevY + delta[1];\n            this.isDrag = true;\n        }\n\n        this.prevX = clientX;\n        this.prevY = clientY;\n\n        return {\n            type: \"drag\",\n            clientX,\n            clientY,\n            inputEvent,\n            isDrag: this.isDrag,\n            distX: clientX - this.startX,\n            distY: clientY - this.startY,\n            deltaX: delta[0],\n            deltaY: delta[1],\n            datas: this.datas.draggable,\n            originalDatas: this.datas,\n            parentEvent: true,\n            parentDragger: this,\n        };\n    }\n}\n","import { Able, MoveableGroupInterface, MoveableManagerInterface } from \"./types\";\nimport { IObject, isFunction } from \"@daybrush/utils\";\nimport CustomDragger, { setCustomDrag } from \"./CustomDragger\";\nexport function triggerChildDragger(\n    moveable: MoveableGroupInterface<any, any>,\n    able: Able,\n    type: string,\n    delta: number[],\n    e: any,\n    isConvert: boolean,\n) {\n    const isStart = !!type.match(/Start$/g);\n    const isEnd = !!type.match(/End$/g);\n    const inputEvent = e.inputEvent;\n    const isPinch = e.isPinch;\n    const datas = e.datas;\n    const childs = moveable.moveables.map((child, i) => {\n        let childEvent = {};\n\n        if (isStart) {\n            childEvent = new CustomDragger().dragStart(delta, inputEvent);\n        } else {\n            if (!child.state.dragger) {\n                child.state.dragger = datas.childDraggers[i];\n            }\n            childEvent = setCustomDrag(child.state, delta, inputEvent, isPinch, isConvert);\n        }\n        const result = (able as any)[type]!(child,  { ...childEvent, parentFlag: true });\n\n        if (isEnd) {\n            child.state.dragger = null;\n        }\n        return result;\n    });\n    if (isStart) {\n        datas.childDraggers = moveable.moveables.map(child => child.state.dragger);\n    }\n    return childs;\n}\nexport function triggerChildAble<T extends Able>(\n    moveable: MoveableGroupInterface<any, any>,\n    able: T,\n    type: keyof T & string,\n    datas: IObject<any>,\n    eachEvent: ((movebale: MoveableManagerInterface<any, any>, datas: IObject<any>) => any) | IObject<any>,\n    callback?: (moveable: MoveableManagerInterface<any, any>, datas: IObject<any>, result: any, index: number) => any,\n) {\n    const name = able.name!;\n    const ableDatas = datas[name] || (datas[name] = []);\n    const isEnd = !!type.match(/End$/g);\n    const childs = moveable.moveables.map((child, i) => {\n        const childDatas = ableDatas[i] || (ableDatas[i] = {});\n\n        const childEvent = isFunction(eachEvent) ? eachEvent(child, childDatas) : eachEvent;\n        const result = (able as any)[type]!(child,  { ...childEvent, datas: childDatas, parentFlag: true });\n\n        result && callback && callback(child, childDatas, result, i);\n\n        if (isEnd) {\n            child.state.dragger = null;\n        }\n        return result;\n    });\n\n    return childs;\n}\n","import { prefix } from \"../utils\";\nimport { hasClass, IObject } from \"@daybrush/utils\";\nimport { InvertTypes } from \"../types\";\n\nexport function directionCondition(e: any) {\n    if (e.isRequest) {\n        if (e.requestAble === \"resizable\" || e.requestAble === \"scalable\") {\n            return e.parentDirection!;\n        } else {\n            return false;\n        }\n    }\n    return hasClass(e.inputEvent.target, prefix(\"direction\"));\n}\n\n// MatchTypes<typeof Draggable[\"props\"], AnyProps<DraggableOptions>>;\n// MatchTypes<typeof Resizable[\"events\"], DraggableEvents>;\nexport function invert<T extends IObject<any>>(obj: T): InvertTypes<T> {\n    const nextObj: IObject<any> = {};\n\n    for (const name in obj) {\n        nextObj[obj[name]] = name;\n    }\n    return nextObj as any;\n}\n","import {\n    SnapInfo, SnappableProps, SnappableState,\n    Guideline, ResizableProps, ScalableProps, SnapOffsetInfo, MoveableManagerInterface\n} from \"../../types\";\nimport { selectValue, throttle, getAbsolutePosesByState, getRect, groupBy, getTinyDist } from \"../../utils\";\nimport { getPosByDirection, getPosesByDirection } from \"../../DraggerUtils\";\nimport { TINY_NUM } from \"../../consts\";\nimport { minus } from \"../../matrix\";\n\nexport function getGapGuidelines(\n    guidelines: Guideline[],\n    type: \"vertical\" | \"horizontal\",\n    snapThreshold: number,\n    index: number,\n    [start, end]: number[],\n    [otherStart, otherEnd]: number[],\n) {\n    const totalGuidelines: Guideline[] = [];\n    const otherIndex = index ? 0 : 1;\n    const otherType = type === \"vertical\" ? \"horizontal\" : \"vertical\";\n\n    const elementGuidelines\n        = groupBy(guidelines.filter(({ type: guidelineType }) => guidelineType === type), ({ element }) => element)\n            .map(group => group[0])\n            .filter(({ pos, sizes }) => pos[otherIndex] <= otherEnd\n                && otherStart <= pos[otherIndex] + sizes![otherIndex]);\n\n    elementGuidelines.forEach(guideline1 => {\n        const elementStart = guideline1.pos[index];\n        const elementEnd = elementStart + guideline1.sizes![index];\n\n        elementGuidelines.forEach(({\n            pos: guideline2Pos,\n            sizes: guideline2Sizes,\n            element: guideline2Element,\n        }) => {\n            const targetStart = guideline2Pos[index];\n            const targetEnd = targetStart + guideline2Sizes![index];\n            let pos = 0;\n            let gap = 0;\n            let canSnap = true;\n\n            if (elementEnd <= targetStart) {\n                // gap -\n                gap = elementEnd - targetStart;\n                pos = targetEnd - gap;\n\n                if (start < pos - snapThreshold) {\n                    canSnap = false;\n                }\n                // element target moveable\n            } else if (targetEnd <= elementStart) {\n                // gap +\n                gap = elementStart - targetEnd;\n                pos = targetStart - gap;\n\n                if (end > pos + snapThreshold) {\n                    canSnap = false;\n                }\n                // moveable target element\n            } else {\n                return;\n            }\n            if (canSnap) {\n                totalGuidelines.push({\n                    pos: otherType === \"vertical\" ? [pos, guideline2Pos[1]] : [guideline2Pos[0], pos],\n                    element: guideline2Element,\n                    sizes: guideline2Sizes,\n                    size: 0,\n                    type: otherType,\n                    gap,\n                    gapGuidelines: elementGuidelines,\n                });\n            }\n            if (elementEnd <= start && end <= targetStart) {\n                // elementEnd   moveable   target\n                const centerPos = ((targetStart + elementEnd) - (end - start)) / 2;\n\n                if (throttle(start - (centerPos - snapThreshold), 0.1) >= 0) {\n                    totalGuidelines.push({\n                        pos: otherType === \"vertical\" ? [centerPos, guideline2Pos[1]] : [guideline2Pos[0], centerPos],\n                        element: guideline2Element,\n                        sizes: guideline2Sizes,\n                        size: 0,\n                        type: otherType,\n                        gap: elementEnd - start,\n                        gapGuidelines: elementGuidelines,\n                    });\n                }\n            }\n        });\n    });\n    return totalGuidelines;\n}\nexport function getTotalGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n) {\n    const {\n        guidelines,\n        containerClientRect: {\n            scrollHeight: containerHeight,\n            scrollWidth: containerWidth,\n        },\n    } = moveable.state;\n    const props = moveable.props;\n    const {\n        snapHorizontal = true,\n        snapVertical = true,\n        snapGap = true,\n        verticalGuidelines,\n        horizontalGuidelines,\n        snapThreshold = 5,\n    } = props;\n    const totalGuidelines: Guideline[] = [...guidelines];\n\n    if (snapGap) {\n        const { top, left, bottom, right } = getRect(getAbsolutePosesByState(moveable.state));\n        const elementGuidelines = (guidelines as Guideline[]).filter(({ element }) => element);\n\n        totalGuidelines.push(...getGapGuidelines(\n            elementGuidelines,\n            \"horizontal\",\n            snapThreshold,\n            0,\n            [left, right],\n            [top, bottom],\n        ), ...getGapGuidelines(\n            elementGuidelines,\n            \"vertical\",\n            snapThreshold,\n            1,\n            [top, bottom],\n            [left, right],\n        ));\n    }\n\n    if (snapHorizontal && horizontalGuidelines) {\n        horizontalGuidelines!.forEach(pos => {\n            totalGuidelines.push({ type: \"horizontal\", pos: [0, throttle(pos, 0.1)], size: containerWidth! });\n        });\n    }\n    if (snapVertical && verticalGuidelines) {\n        verticalGuidelines!.forEach(pos => {\n            totalGuidelines.push({ type: \"vertical\", pos: [throttle(pos, 0.1), 0], size: containerHeight! });\n        });\n    }\n\n    return totalGuidelines;\n}\nexport function checkSnapPoses(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    posesX: number[],\n    posesY: number[],\n    snapCenter?: boolean,\n    customSnapThreshold?: number,\n) {\n    const totalGuidelines = getTotalGuidelines(moveable);\n    const props = moveable.props;\n    const {\n        snapElement = true,\n    } = props;\n    const snapThreshold = selectValue<number>(customSnapThreshold, props.snapThreshold, 5);\n\n    return {\n        vertical: checkSnap(\n            totalGuidelines,\n            \"vertical\", posesX, snapThreshold,\n            snapCenter!,\n            snapElement,\n        ),\n        horizontal: checkSnap(\n            totalGuidelines,\n            \"horizontal\", posesY, snapThreshold,\n            snapCenter!,\n            snapElement,\n        ),\n    };\n}\n\nexport function checkSnapKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n): {\n    vertical: SnapOffsetInfo,\n    horizontal: SnapOffsetInfo,\n} {\n    const [endX, endY] = endPos;\n    const [startX, startY] = startPos;\n    let [dx, dy] = minus(endPos, startPos);\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    dx = getTinyDist(dx);\n    dy = getTinyDist(dy);\n\n    const verticalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    }\n    const {\n        vertical: verticalSnapInfo,\n        horizontal: horizontalSnapInfo,\n    } = checkSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []);\n\n    verticalSnapInfo.posInfos.filter(({ pos }) => {\n        return isRight ? pos >= startX : pos <= startX;\n    });\n    horizontalSnapInfo.posInfos.filter(({ pos }) => {\n        return isBottom ? pos >= startY : pos <= startY;\n    });\n    verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\n    horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\n\n    const {\n        isSnap: isVerticalSnap,\n        guideline: verticalGuideline,\n    } = getNearestSnapGuidelineInfo(verticalSnapInfo);\n    const {\n        isSnap: isHorizontalSnap,\n        guideline: horizontalGuideline,\n    } = getNearestSnapGuidelineInfo(horizontalSnapInfo);\n    const horizontalPos = isHorizontalSnap ? horizontalGuideline!.pos[1] : 0;\n    const verticalPos = isVerticalSnap ? verticalGuideline!.pos[0] : 0;\n\n    if (dx === 0) {\n        if (isHorizontalSnap) {\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = horizontalGuideline!.pos[1];\n            horizontalInfo.offset = endY - horizontalInfo.pos;\n        }\n    } else if (dy === 0) {\n        if (isVerticalSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = verticalPos;\n            verticalInfo.offset = endX - verticalPos;\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isSnap = false;\n\n        if (isVerticalSnap) {\n            x = verticalPos;\n            y = a * x + b;\n            isSnap = true;\n        } else if (isHorizontalSnap) {\n            y = horizontalPos;\n            x = (y - b) / a;\n            isSnap = true;\n        }\n        if (isSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\n\nexport function checkSnaps(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    rect: {\n        left?: number,\n        top?: number,\n        bottom?: number,\n        right?: number,\n        center?: number,\n        middle?: number,\n    },\n    isCenter: boolean,\n    customSnapThreshold?: number,\n) {\n    const snapCenter = moveable.props.snapCenter;\n    const isSnapCenter = snapCenter! && isCenter;\n\n    let verticalNames: Array<\"left\" | \"center\" | \"right\"> = [\"left\", \"right\"];\n    let horizontalNames: Array<\"top\" | \"middle\" | \"bottom\"> = [\"top\", \"bottom\"];\n\n    if (isSnapCenter) {\n        verticalNames.push(\"center\");\n        horizontalNames.push(\"middle\");\n    }\n    verticalNames = verticalNames.filter(name => name in rect);\n    horizontalNames = horizontalNames.filter(name => name in rect);\n\n    return checkSnapPoses(\n        moveable,\n        verticalNames.map(name => rect[name]!),\n        horizontalNames.map(name => rect[name]!),\n        isSnapCenter,\n        customSnapThreshold,\n    );\n}\n\nexport function getNearestSnapGuidelineInfo(\n    snapInfo: SnapInfo,\n) {\n    const isSnap = snapInfo.isSnap;\n\n    if (!isSnap) {\n        return {\n            isSnap: false,\n            offset: 0,\n            dist: -1,\n            pos: 0,\n            guideline: null,\n        };\n    }\n    const posInfo = snapInfo.posInfos[0];\n    const guidelineInfo = posInfo!.guidelineInfos[0];\n    const offset = guidelineInfo!.offset;\n    const dist = guidelineInfo!.dist;\n    const guideline = guidelineInfo!.guideline;\n\n    return {\n        isSnap,\n        offset,\n        dist,\n        pos: posInfo!.pos,\n        guideline,\n    };\n}\n\nfunction checkSnap(\n    guidelines: Guideline[],\n    targetType: \"horizontal\" | \"vertical\",\n    targetPoses: number[],\n    snapThreshold: number,\n    snapCenter: boolean,\n    snapElement: boolean,\n): SnapInfo {\n    if (!guidelines || !guidelines.length) {\n        return {\n            isSnap: false,\n            posInfos: [],\n        };\n    }\n    const isVertical = targetType === \"vertical\";\n    const posType = isVertical ? 0 : 1;\n\n    const snapPosInfos = targetPoses.map(targetPos => {\n        const guidelineInfos = guidelines.map(guideline => {\n            const { pos } = guideline;\n            const offset = targetPos - pos[posType];\n\n            return {\n                offset,\n                dist: Math.abs(offset),\n                guideline,\n            };\n        }).filter(({ guideline, dist }) => {\n            const { type, center, element } = guideline;\n            if (\n                (!snapElement && element)\n                || (!snapCenter && center)\n                || type !== targetType\n                || dist > snapThreshold\n            ) {\n                return false;\n            }\n            return true;\n        }).sort(\n            (a, b) => a.dist - b.dist,\n        );\n\n        return {\n            pos: targetPos,\n            guidelineInfos,\n        };\n    }).filter(snapPosInfo => {\n        return snapPosInfo.guidelineInfos.length > 0;\n    }).sort((a, b) => {\n        return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\n    });\n\n    return {\n        isSnap: snapPosInfos.length > 0,\n        posInfos: snapPosInfos,\n    };\n}\n\nexport function getSnapInfosByDirection(\n    moveable: MoveableManagerInterface<SnappableProps & (ResizableProps | ScalableProps), SnappableState>,\n    poses: number[][],\n    snapDirection: number[],\n) {\n    let nextPoses: number[][] = [];\n    if (snapDirection[0] && snapDirection[1]) {\n        nextPoses = [\n            snapDirection,\n            [-snapDirection[0], snapDirection[1]],\n            [snapDirection[0], -snapDirection[1]],\n        ].map(direction => getPosByDirection(poses, direction));\n    } else if (!snapDirection[0] && !snapDirection[1]) {\n        const alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];\n\n        for (let i = 0; i < 4; ++i) {\n            nextPoses.push(alignPoses[i]);\n            nextPoses.push([\n                (alignPoses[i][0] + alignPoses[i + 1][0]) / 2,\n                (alignPoses[i][1] + alignPoses[i + 1][1]) / 2,\n            ]);\n        }\n    } else {\n        if (moveable.props.keepRatio) {\n            nextPoses = [\n                [-1, -1],\n                [-1, 1],\n                [1, -1],\n                [1, 1],\n                snapDirection,\n            ].map(dir => getPosByDirection(poses, dir));\n        } else {\n            nextPoses = getPosesByDirection(poses, snapDirection);\n\n            if (nextPoses.length > 1) {\n                nextPoses.push([\n                    (nextPoses[0][0] + nextPoses[1][0]) / 2,\n                    (nextPoses[0][1] + nextPoses[1][1]) / 2,\n                ]);\n            }\n        }\n    }\n    return checkSnapPoses(moveable, nextPoses.map(pos => pos[0]), nextPoses.map(pos => pos[1]), true, 1);\n}\n\nexport function getNearOffsetInfo<T extends { offset: number[], isBound: boolean, isSnap: boolean, sign: number[] }>(\n    offsets: T[],\n    index: number,\n) {\n    return offsets.slice().sort((a, b) => {\n        const aSign = a.sign[index];\n        const bSign = b.sign[index];\n        const aOffset = a.offset[index];\n        const bOffset = b.offset[index];\n        const aDist = Math.abs(aOffset);\n        const bDist = Math.abs(bOffset);\n        // -1 The positions of a and b do not change.\n        // 1 The positions of a and b are reversed.\n        if (!aSign) {\n            return 1;\n        } else if (!bSign) {\n            return -1;\n        } else if (a.isBound && b.isBound) {\n            return bDist - aDist;\n        } else if (a.isBound) {\n            return -1;\n        } else if (b.isBound) {\n            return 1;\n        } else if (a.isSnap && b.isSnap) {\n            return aDist - bDist;\n        } else if (a.isSnap) {\n            return -1;\n        } else if (b.isSnap) {\n            return 1;\n        } else if (aDist < TINY_NUM) {\n            return 1;\n        } else if (bDist < TINY_NUM) {\n            return -1;\n        }\n        return aDist - bDist;\n    })[0];\n}\n","import { maxOffset, getDistSize, throttle, getTinyDist } from \"../../utils\";\nimport { average, rotate, getRad } from \"../../matrix\";\nimport { SnappableProps, DraggableProps, RotatableProps, MoveableManagerInterface } from \"../../types\";\nimport { getDragDist, getPosByDirection, getInverseDragDist } from \"../../DraggerUtils\";\nimport { getNearOffsetInfo } from \"./snap\";\nimport { TINY_NUM } from \"../../consts\";\n\nfunction isStartLine(dot: number[], line: number[][]) {\n    // l    o     => true\n    // o    l    => false\n    const cx = average(line[0][0], line[1][0]);\n    const cy = average(line[0][1], line[1][1]);\n\n    return {\n        vertical: cx <= dot[0],\n        horizontal: cy <= dot[1],\n    };\n}\nfunction hitTestLine(\n    dot: number[],\n    [pos1, pos2]: number[][],\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    let test1: number;\n    let test2: number;\n    if (!dx) {\n        test1 = pos1[0];\n        test2 = dot[0];\n    } else if (!dy) {\n        test1 = pos1[1];\n        test2 = dot[1];\n    } else {\n        const a = dy / dx;\n\n        // y = a * (x - pos1) + pos1\n        test1 = a * (dot[0] - pos1[0]) + pos1[1];\n        test2 = dot[1];\n    }\n    return test1 - test2;\n}\nfunction isSameStartLine(dots: number[][], line: number[][], error: number = TINY_NUM) {\n    const centerSign = hitTestLine(dots[0], line) <= 0;\n\n    return dots.slice(1).every(dot => {\n        const value = hitTestLine(dot, line);\n        const sign = value <= 0;\n        return sign === centerSign || Math.abs(value) <= error;\n    });\n}\nfunction checkInnerBoundDot(\n    pos: number,\n    start: number,\n    end: number,\n    isStart: boolean,\n    threshold: number = 0,\n) {\n    if (\n        (isStart && start - threshold <= pos)\n        || (!isStart && pos <= end + threshold)\n    ) {\n        // false 402 565 602 => 37 ([0, 37])\n        // true 400 524.9712603540036 600 => 124 ([124, 0])\n        // true 400 410 600 => 10 ([10, 0])\n        return {\n            isBound: true,\n            offset: isStart ? start - pos : end - pos,\n        };\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\n\nfunction checkInnerBound(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    line: number[][],\n    center: number[],\n) {\n    const bounds = moveable.props.innerBounds;\n\n    if (!bounds) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n    const { left, top, width, height } = bounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n    const {\n        horizontal: isHorizontalStart,\n        vertical: isVerticalStart,\n    } = isStartLine(center, line);\n\n    if (isSameStartLine([\n        center,\n        [left, top],\n        [left + width, top],\n        [left, top + height],\n        [left + width, top + height],\n    ], line)) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n\n    // test vertical\n    const topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart);\n    const bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart);\n\n    // test horizontal\n    const leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart);\n    const rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart);\n\n    const isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\n    const isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\n    const isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\n    const isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\n    const verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\n    const horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);\n\n    let offset = [0, 0];\n    let isBound = false;\n    let isAllBound = false;\n\n    if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {\n        offset = [verticalOffset, 0];\n        isBound = isVerticalBound;\n        isAllBound = isAllVerticalBound;\n    } else {\n        offset = [0, horizontalOffset];\n        isBound = isHorizontalBound;\n        isAllBound = isAllHorizontalBound;\n    }\n    return {\n        isAllBound,\n        isVerticalBound,\n        isHorizontalBound,\n        isBound,\n        offset,\n    };\n}\n\nfunction checkLineBoundCollision(\n    line: number[][],\n    boundLine: number[][],\n    isStart: boolean,\n    threshold?: number,\n    isRender?: boolean,\n) {\n    const dot1 = line[0];\n    const dot2 = line[1];\n    const boundDot1 = boundLine[0];\n    const boundDot2 = boundLine[1];\n    const dy1 = getTinyDist(dot2[1] - dot1[1]);\n    const dx1 = getTinyDist(dot2[0] - dot1[0]);\n\n    const dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);\n    const dx2 = getTinyDist(boundDot2[0] - boundDot1[0]);\n\n    // dx2 or dy2 is zero\n    if (!dx2) {\n        // vertical\n        if (isRender && !dy1) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0,\n            };\n        } else if (dx1) {\n            // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];\n            const y = dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1];\n\n            // boundDot1[1] <= y  <= boundDot2[1]\n            return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);\n        } else {\n            const offset = boundDot1[0] - dot1[0];\n\n            const isBound = Math.abs(offset) <= (threshold || 0);\n\n            return {\n                isBound,\n                offset: isBound ? offset : 0,\n            };\n        }\n    } else if (!dy2) {\n        // horizontal\n        if (isRender && !dx1) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0,\n            };\n        } else if (dy1) {\n            // y = a * (x - x1) + y1\n            // x = (y - y1) / a + x1\n            // const a = dy1 / dx1;\n            // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];\n            const x = (boundDot1[1] - dot1[1]) / (dy1 / dx1) + dot1[0];\n\n            // boundDot1[0] <= x && x <= boundDot2[0]\n            return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);\n        } else {\n            const offset = boundDot1[1] - dot1[1];\n\n            const isBound = Math.abs(offset) <= (threshold || 0);\n\n            return {\n                isBound,\n                offset: isBound ? offset : 0,\n            };\n        }\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\nexport function getInnerBoundInfo(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    lines: number[][][],\n    center: number[],\n    datas: any,\n) {\n    return lines.map(([multiple, pos1, pos2]) => {\n        const {\n            isBound,\n            offset,\n            isVerticalBound,\n            isHorizontalBound,\n        } = checkInnerBound(moveable, [pos1, pos2], center);\n\n        const sizeOffset = getDragDist({\n            datas,\n            distX: offset[0],\n            distY: offset[1],\n        }).map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n        return {\n            sign: multiple,\n            isBound,\n            isVerticalBound,\n            isHorizontalBound,\n            isSnap: false,\n            offset: sizeOffset,\n        };\n    });\n}\n\nexport function getInnerBoundDragInfo(\n    moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n    poses: number[][],\n    datas: any,\n) {\n    const lines = getCheckSnapLines(poses, [0, 0], false).map(([sign, pos1, pos2]) => {\n        return [\n            sign.map(dir => Math.abs(dir) * 2),\n            pos1,\n            pos2,\n        ];\n    });\n    const innerBoundInfo = getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas);\n    const widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\n    const heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\n    let verticalOffset = 0;\n    let horizontalOffset = 0;\n    const isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\n    const isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\n\n    if (isVerticalBound || isHorizontalBound) {\n        [verticalOffset, horizontalOffset] = getInverseDragDist({\n            datas,\n            distX: -widthOffsetInfo.offset[0],\n            distY: -heightOffsetInfo.offset[1],\n        });\n    }\n\n    return {\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalOffset,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalOffset,\n        },\n    };\n}\nexport function getCheckSnapLineDirections(\n    direction: number[],\n    keepRatio: boolean,\n) {\n    const lineDirections: number[][][] = [];\n    const x = direction[0];\n    const y = direction[1];\n    if (x && y) {\n        lineDirections.push(\n            [[0, y * 2], direction, [-x, y]],\n            [[x * 2, 0], direction, [x, -y]],\n        );\n    } else if (x) {\n        // vertcal\n        lineDirections.push(\n            [[x * 2, 0], [x, 1], [x, -1]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[0, -1], [x, -1], [-x, -1]],\n                [[0, 1], [x, 1], [-x, 1]],\n            );\n        }\n    } else if (y) {\n        // horizontal\n        lineDirections.push(\n            [[0, y * 2], [1, y], [-1, y]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[-1, 0], [-1, y], [-1, -y]],\n                [[1, 0], [1, y], [1, -y]],\n            );\n        }\n    } else {\n        // [0, 0] to all direction\n        lineDirections.push(\n            [[-1, 0], [-1, -1], [-1, 1]],\n            [[1, 0], [1, -1], [1, 1]],\n            [[0, -1], [-1, -1], [1, -1]],\n            [[0, 1], [-1, 1], [1, 1]],\n        );\n    }\n\n    return lineDirections;\n}\nexport function getCheckSnapLines(\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n) {\n    return getCheckSnapLineDirections(direction, keepRatio).map(([sign, dir1, dir2]) => {\n        return [\n            sign,\n            getPosByDirection(poses, dir1),\n            getPosByDirection(poses, dir2),\n        ];\n    });\n}\n\nfunction isBoundRotate(\n    relativePoses: number[][],\n    boundDots: number[][],\n    center: number[],\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n    const dots = [\n        center,\n        ...boundDots,\n    ];\n    return [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].some((line, i) => !isSameStartLine(dots, line));\n}\nfunction getDistPointLine([pos1, pos2]: number[][]) {\n    // x = 0, y = 0\n    // d = (ax + by + c) / root(a2 + b2)\n\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return Math.abs(pos1[0]);\n    }\n    if (!dy) {\n        return Math.abs(pos1[1]);\n    }\n    // y - y1 = a(x - x1)\n    // 0 = ax -y + -a * x1 + y1\n\n    const a = dy / dx;\n\n    return Math.abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));\n}\nfunction solveReverseLine([pos1, pos2]: number[][]) {\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return [pos1[0], 0];\n    }\n    if (!dy) {\n        return [0, pos1[1]];\n    }\n    const a = dy / dx;\n    // y - y1 = a (x  - x1)\n    // y = ax - a * x1 + y1\n    const b = -a * pos1[0] + pos1[1];\n    // y = ax + b = -1/a x\n    // x = -b / (a + 1 / a)\n    // y = b / (1 + 1 / a^2)\n\n    return [\n        -b / (a + 1 / a),\n        b / ((a * a) + 1),\n    ];\n}\nexport function checkRotateInnerBounds(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    const bounds = moveable.props.innerBounds;\n    const rad = rotation * Math.PI / 180;\n\n    if (!bounds) {\n        return [];\n    }\n    const {\n        left,\n        top,\n        width,\n        height,\n    } = bounds;\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = left + width - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = top + height - origin[1];\n    const dots = [\n        [relativeLeft, relativeTop],\n        [relativeRight, relativeTop],\n        [relativeLeft, relativeBottom],\n        [relativeRight, relativeBottom],\n    ];\n    const center = getPosByDirection(nextPoses, [0, 0]);\n\n    if (!isBoundRotate(nextPoses, dots, center, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    const dotInfos = dots.map(dot => [\n        getDistSize(dot),\n        getRad([0, 0], dot),\n    ]);\n    [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].forEach(line => {\n        const lineRad = getRad([0, 0], solveReverseLine(line));\n        const lineDist = getDistPointLine(line);\n\n        result.push(...dotInfos\n            .filter(([dotDist]) => {\n                return dotDist && lineDist <= dotDist;\n            })\n            .map(([dotDist, dotRad]) => {\n                const distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\n                const nextRad1 = dotRad + distRad;\n                const nextRad2 = dotRad - distRad;\n\n                return [\n                    rad + nextRad1 - lineRad,\n                    rad + nextRad2 - lineRad,\n                ];\n            })\n            .reduce<number[]>((prev, cur) => {\n                prev.push(...cur);\n                return prev;\n            }, [])\n            .filter(nextRad => !isBoundRotate(prevPoses, dots, center, nextRad))\n            .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n    });\n    return result;\n}\n\nexport function checkInnerBoundPoses(\n    moveable: MoveableManagerInterface<SnappableProps>,\n) {\n    const innerBounds = moveable.props.innerBounds;\n\n    if (!innerBounds) {\n        return {\n            vertical: [],\n            horizontal: [],\n        };\n    }\n    const {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = moveable.getRect();\n    const poses = [pos1, pos2, pos3, pos4];\n    const center = getPosByDirection(poses, [0, 0]);\n    const { left, top, width, height } = innerBounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n\n    const lines = [\n        [pos1, pos2],\n        [pos2, pos4],\n        [pos4, pos3],\n        [pos3, pos1],\n    ];\n\n    const horizontalPoses: number[] = [];\n    const verticalPoses: number[] = [];\n\n    const boundMap = {\n        top: false,\n        bottom: false,\n        left: false,\n        right: false,\n    };\n\n    lines.forEach(line => {\n        const {\n            horizontal: isHorizontalStart,\n            vertical: isVerticalStart,\n        } = isStartLine(center, line);\n\n        // test vertical\n        const topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart, 1, true);\n        const bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart, 1, true);\n\n        // test horizontal\n        const leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart, 1, true);\n        const rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart, 1, true);\n\n        if (topBoundInfo.isBound && !boundMap.top) {\n            horizontalPoses.push(top);\n            boundMap.top = true;\n        }\n        if (bottomBoundInfo.isBound && !boundMap.bottom) {\n            horizontalPoses.push(top + height);\n            boundMap.bottom = true;\n        }\n        if (leftBoundInfo.isBound && !boundMap.left) {\n            verticalPoses.push(left);\n            boundMap.left = true;\n        }\n        if (rightBoundInfo.isBound && !boundMap.right) {\n            verticalPoses.push(left + width);\n            boundMap.right = true;\n        }\n    });\n\n    return {\n        horizontal: horizontalPoses,\n        vertical: verticalPoses,\n    };\n}\n","import { BoundInfo, SnappableProps, BoundType, RotatableProps, MoveableManagerInterface } from \"../../types\";\nimport { rotate, getRad, minus } from \"../../matrix\";\nimport { getDistSize, throttle } from \"../../utils\";\nimport { TINY_NUM } from \"../../consts\";\n\nexport function checkBoundPoses(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n) {\n    const {\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = moveable.props.bounds || {};\n    const bounds = { left, top, right, bottom };\n\n    return {\n        vertical: checkBound(bounds, verticalPoses, true),\n        horizontal: checkBound(bounds, horizontalPoses, false),\n    };\n}\n\nexport function checkBoundKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    startPos: number[],\n    endPos: number[],\n) {\n    const {\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = moveable.props.bounds || {};\n\n    const [endX, endY] = endPos;\n    let [dx, dy] = minus(endPos, startPos);\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    const verticalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    } else if (dx === 0) {\n        if (isBottom) {\n            if (bottom < endY) {\n                horizontalInfo.pos = bottom;\n                horizontalInfo.offset = endY - bottom;\n            }\n        } else {\n            if (top > endY) {\n                horizontalInfo.pos = top;\n                horizontalInfo.offset = endY - top;\n            }\n        }\n    } else if (dy === 0) {\n        if (isRight) {\n            if (right < endX) {\n                verticalInfo.pos = right;\n                verticalInfo.offset = endX - right;\n            }\n        } else {\n            if (left > endX) {\n                verticalInfo.pos = left;\n                verticalInfo.offset = endX - left;\n            }\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isBound = false;\n\n        if (isRight && right <= endX) {\n            y = a * right + b;\n            x = right;\n            isBound = true;\n        } else if (!isRight && endX <= left) {\n            y = a * left + b;\n            x = left;\n            isBound = true;\n        }\n        if (isBound) {\n            if (y < top || y > bottom) {\n                isBound = false;\n            }\n        }\n        if (!isBound) {\n            if (isBottom && bottom <= endY) {\n                y = bottom;\n                x = (y - b) / a;\n                isBound = true;\n            } else if (!isBottom &&  endY <= top) {\n                y = top;\n                x = (y - b) / a;\n                isBound = true;\n            }\n        }\n        if (isBound) {\n            verticalInfo.isBound = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isBound = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\nfunction checkBound(\n    bounds: Required<BoundType>,\n    poses: number[],\n    isVertical: boolean,\n): BoundInfo {\n    // 0   [100 - 200]  300\n    const startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\n    const endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"];\n\n    // 450\n    const minPos = Math.min(...poses);\n    const maxPos = Math.max(...poses);\n\n    if (startBoundPos + 1 > minPos) {\n        return {\n            isBound: true,\n            offset: minPos - startBoundPos,\n            pos: startBoundPos,\n        };\n    }\n    if (endBoundPos - 1 < maxPos) {\n        return {\n            isBound: true,\n            offset: maxPos - endBoundPos,\n            pos: endBoundPos,\n        };\n    }\n\n    return {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n}\nexport function isBoundRotate(\n    relativePoses: number[][],\n    boundRect: { left: number, top: number, right: number, bottom: number },\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n\n    return nextPoses.some(pos => {\n        return (pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1)\n            || (pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1)\n            || (pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1)\n            || (pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1);\n    });\n}\nexport function boundRotate(\n    vec: number[],\n    boundPos: number,\n    index: number,\n) {\n    const r = getDistSize(vec);\n    const nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;\n\n    return [nextPos, -nextPos].sort((a, b) => {\n        return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);\n    }).map(pos => {\n        return getRad([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\n    });\n}\n\nexport function checkRotateBounds(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    const bounds = moveable.props.bounds;\n    const rad = rotation * Math.PI / 180;\n\n    if (!bounds) {\n        return [];\n    }\n    const {\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = bounds;\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = right - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = bottom - origin[1];\n    const boundRect = {\n        left: relativeLeft,\n        top: relativeTop,\n        right: relativeRight,\n        bottom: relativeBottom,\n    };\n\n    if (!isBoundRotate(nextPoses, boundRect, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    [\n        [relativeLeft, 0],\n        [relativeRight, 0],\n        [relativeTop, 1],\n        [relativeBottom, 1],\n    ].forEach(([boundPos, index], i) => {\n        nextPoses.forEach(nextPos => {\n            const relativeRad1 = getRad([0, 0], nextPos);\n\n            result.push(...boundRotate(nextPos, boundPos, index)\n                .map(relativeRad2 => rad + relativeRad2 - relativeRad1)\n                .filter(nextRad => !isBoundRotate(prevPoses, boundRect, nextRad))\n                .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n        });\n    });\n\n    return result;\n}\n","\nimport {\n    Renderer,\n    SnappableProps,\n    SnappableState, Guideline,\n    SnapInfo, BoundInfo,\n    ScalableProps, SnapPosInfo, RotatableProps,\n    RectInfo, DraggableProps, SnapOffsetInfo, GapGuideline,\n    SnappableOptions, MoveableClientRect, MoveableManagerInterface, SnappableRenderType,\n} from \"../types\";\nimport {\n    prefix, caculatePoses, getRect,\n    getAbsolutePosesByState, getAbsolutePoses, throttle, roundSign,\n    getDistSize, groupBy, flat, maxOffset, minOffset, triggerEvent, caculateInversePosition, caculatePosition,\n} from \"../utils\";\nimport { IObject, find, findIndex } from \"@daybrush/utils\";\nimport {\n    getPosByReverseDirection,\n    getDragDist, scaleMatrix, getPosByDirection,\n} from \"../DraggerUtils\";\nimport { minus, rotate, plus, getRad } from \"../matrix\";\nimport {\n    dragControlCondition as rotatableDragControlCondtion,\n} from \"./Rotatable\";\nimport { TINY_NUM } from \"../consts\";\nimport { directionCondition } from \"./utils\";\nimport {\n    getInnerBoundInfo, getCheckSnapLines,\n    getInnerBoundDragInfo, checkRotateInnerBounds, checkInnerBoundPoses,\n} from \"./snappable/innerBounds\";\nimport { checkBoundPoses, checkRotateBounds, checkBoundKeepRatio } from \"./snappable/bounds\";\nimport {\n    checkSnaps, getSnapInfosByDirection,\n    checkSnapPoses, getNearestSnapGuidelineInfo,\n    getNearOffsetInfo,\n    checkSnapKeepRatio,\n} from \"./snappable/snap\";\n\nexport function caculateContainerPos(\n    rootMatrix: number[],\n    containerRect: MoveableClientRect,\n    n: number,\n) {\n    const clientPos = caculatePosition(\n        rootMatrix, [containerRect.clientLeft!, containerRect.clientTop!], n);\n\n    return [\n        containerRect.left + clientPos[0],\n        containerRect.top + clientPos[1],\n    ];\n}\nexport function snapStart(moveable: MoveableManagerInterface<SnappableProps, SnappableState>) {\n    const state = moveable.state;\n    if (state.guidelines && state.guidelines.length) {\n        return;\n    }\n\n    const {\n        horizontalGuidelines = [],\n        verticalGuidelines = [],\n        elementGuidelines = [],\n        bounds,\n        innerBounds,\n        snapCenter,\n    } = moveable.props;\n\n    if (\n        !innerBounds && !bounds\n        && !horizontalGuidelines.length\n        && !verticalGuidelines.length && !elementGuidelines.length\n    ) {\n        return;\n    }\n\n    const {\n        containerClientRect,\n        targetClientRect: {\n            top: clientTop,\n            left: clientLeft,\n        },\n        rootMatrix,\n        is3d,\n    } = state;\n    const n = is3d ? 4 : 3;\n    const [containerLeft, containerTop] = caculateContainerPos(rootMatrix, containerClientRect, n);\n    const poses = getAbsolutePosesByState(state);\n    const targetLeft = Math.min(...poses.map(pos => pos[0]));\n    const targetTop = Math.min(...poses.map(pos => pos[1]));\n    const [distLeft, distTop] = minus([targetLeft, targetTop], caculateInversePosition(rootMatrix, [\n        clientLeft - containerLeft,\n        clientTop - containerTop,\n    ], n)).map(pos => roundSign(pos));\n\n    const guidelines: Guideline[] = [];\n\n    elementGuidelines!.forEach(el => {\n        const rect = el.getBoundingClientRect();\n        const left = rect.left - containerLeft;\n        const top = rect.top - containerTop;\n        const bottom = top + rect.height;\n        const right = left + rect.width;\n        const [elementLeft, elementTop] = caculateInversePosition(rootMatrix, [left, top], n);\n        const [elementRight, elementBottom] = caculateInversePosition(rootMatrix, [right, bottom], n);\n        const width = elementRight - elementLeft;\n        const height = elementBottom - elementTop;\n        const sizes = [width, height];\n\n        guidelines.push({\n            type: \"vertical\", element: el, pos: [\n                throttle(elementLeft + distLeft, 0.1),\n                elementTop,\n            ], size: height,\n            sizes,\n        });\n        guidelines.push({\n            type: \"vertical\", element: el, pos: [\n                throttle(elementRight + distLeft, 0.1),\n                elementTop,\n            ], size: height,\n            sizes,\n        });\n        guidelines.push({\n            type: \"horizontal\", element: el, pos: [\n                elementLeft,\n                throttle(elementTop + distTop, 0.1),\n            ], size: width,\n            sizes,\n        });\n        guidelines.push({\n            type: \"horizontal\", element: el, pos: [\n                elementLeft,\n                throttle(elementBottom + distTop, 0.1),\n            ], size: width,\n            sizes,\n        });\n\n        if (snapCenter) {\n            guidelines.push({\n                type: \"vertical\",\n                element: el,\n                pos: [\n                    throttle((elementLeft + elementRight) / 2 + distLeft, 0.1),\n                    elementTop,\n                ],\n                size: height,\n                sizes,\n                center: true,\n            });\n            guidelines.push({\n                type: \"horizontal\",\n                element: el,\n                pos: [\n                    elementLeft,\n                    throttle((elementTop + elementBottom) / 2 + distTop, 0.1),\n                ],\n                size: width,\n                sizes,\n                center: true,\n            });\n        }\n    });\n\n    state.guidelines = guidelines;\n    state.enableSnap = true;\n}\n\nexport function hasGuidelines(\n    moveable: MoveableManagerInterface<any, any>,\n    ableName: string,\n): moveable is MoveableManagerInterface<SnappableProps, SnappableState> {\n    const {\n        props: {\n            snappable,\n            bounds,\n            innerBounds,\n            verticalGuidelines,\n            horizontalGuidelines,\n        },\n        state: {\n            guidelines,\n            enableSnap,\n        },\n    } = moveable;\n\n    if (\n        !snappable\n        || !enableSnap\n        || (ableName && snappable !== true && snappable.indexOf(ableName) < 0)\n    ) {\n        return false;\n    }\n    if (\n        bounds || innerBounds\n        || (guidelines && guidelines.length)\n        || (verticalGuidelines && verticalGuidelines.length)\n        || (horizontalGuidelines && horizontalGuidelines.length)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nfunction solveNextOffset(\n    pos1: number[],\n    pos2: number[],\n    offset: number,\n    isVertical: boolean,\n    datas: IObject<any>,\n) {\n    const sizeOffset = solveEquation(\n        pos1,\n        pos2,\n        offset,\n        isVertical,\n    );\n\n    if (!sizeOffset) {\n        return [0, 0];\n    }\n    const [widthOffset, heightOffset] = getDragDist({\n        datas,\n        distX: sizeOffset[0],\n        distY: sizeOffset[1],\n    });\n\n    return [widthOffset, heightOffset];\n}\nfunction getNextFixedPoses(\n    matrix: number[],\n    width: number,\n    height: number,\n    fixedPos: number[],\n    direction: number[],\n    is3d: boolean,\n) {\n    const nextPoses = caculatePoses(matrix, width, height, is3d ? 4 : 3);\n    const nextPos = getPosByReverseDirection(nextPoses, direction);\n\n    return getAbsolutePoses(nextPoses, minus(fixedPos, nextPos));\n}\nfunction getSnapBoundOffset(boundInfo: BoundInfo, snapInfo: SnapOffsetInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return snapInfo.offset;\n    }\n    return 0;\n}\nfunction getSnapBound(boundInfo: BoundInfo, snapInfo: SnapInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return getNearestSnapGuidelineInfo(snapInfo).offset;\n    }\n    return 0;\n}\nexport function checkSnapBoundsKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n    isRequest: boolean,\n) {\n    const {\n        horizontal: horizontalBoundInfo,\n        vertical: verticalBoundInfo,\n    } = checkBoundKeepRatio(\n        moveable,\n        startPos,\n        endPos,\n    );\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = isRequest ? {\n        horizontal: { isSnap: false },\n        vertical: { isSnap: false },\n    } as any : checkSnapKeepRatio(\n        moveable,\n        startPos,\n        endPos,\n    );\n\n    const horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);\n    const verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfo.isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n        },\n        vertical: {\n            isBound: verticalBoundInfo.isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            offset: verticalOffset,\n            dist: verticalDist,\n        },\n    };\n}\nexport function checkSnapBounds(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    isRequest: boolean,\n    poses: number[][],\n    boundPoses: number[][] = poses,\n) {\n    const {\n        horizontal: horizontalBoundInfo,\n        vertical: verticalBoundInfo,\n    } = checkBoundPoses(\n        moveable,\n        boundPoses.map(pos => pos[0]),\n        boundPoses.map(pos => pos[1]),\n    );\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = isRequest ? {\n        horizontal: { isSnap: false },\n        vertical: { isSnap: false },\n    } as any : checkSnapPoses(\n        moveable,\n        poses.map(pos => pos[0]),\n        poses.map(pos => pos[1]),\n    );\n\n    const horizontalOffset = getSnapBound(horizontalBoundInfo, horizontalSnapInfo);\n    const verticalOffset = getSnapBound(verticalBoundInfo, verticalSnapInfo);\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfo.isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n        },\n        vertical: {\n            isBound: verticalBoundInfo.isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            offset: verticalOffset,\n            dist: verticalDist,\n        },\n    };\n}\nexport function normalized(value: number) {\n    return value ? value / Math.abs(value) : 0;\n}\nexport function checkMaxBounds(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    poses: number[][],\n    direction: number[],\n    fixedPos: number[],\n    datas: any,\n) {\n    const fixedDirection = [-direction[0], -direction[1]];\n    const {\n        width,\n        height,\n    } = moveable.state;\n    const bounds = moveable.props.bounds;\n    let maxWidth = Infinity;\n    let maxHeight = Infinity;\n\n    if (bounds) {\n        const directions = [\n            [direction[0], -direction[1]],\n            [-direction[0], direction[1]],\n        ];\n        const {\n            left = -Infinity,\n            top = -Infinity,\n            right = Infinity,\n            bottom = Infinity,\n        } = bounds;\n\n        directions.forEach(otherDirection => {\n            const isCheckVertical = otherDirection[0] !== fixedDirection[0];\n            const isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\n            const otherPos = getPosByDirection(poses, otherDirection);\n\n            const verticalDirection = normalized(otherDirection[1] - fixedDirection[1]);\n            const horizontalDirection = normalized(otherDirection[0] - fixedDirection[0]);\n            const deg = getRad(fixedPos, otherPos) * 360 / Math.PI;\n\n            if (isCheckHorizontal) {\n                const nextOtherPos = otherPos.slice();\n\n                if (Math.abs(deg - 360) < 2 || Math.abs(deg - 180) < 2) {\n                    nextOtherPos[1] = fixedPos[1];\n                }\n                const [\n                    ,\n                    heightOffset,\n                ] = solveNextOffset(\n                    fixedPos, nextOtherPos,\n                    (fixedPos[1] < otherPos[1] ? bottom : top) - otherPos[1],\n                    false, datas,\n                );\n                if (!isNaN(heightOffset)) {\n                    maxHeight = height + verticalDirection * heightOffset;\n                }\n            }\n            if (isCheckVertical) {\n                const nextOtherPos = otherPos.slice();\n\n                if (Math.abs(deg - 90) < 2 || Math.abs(deg - 270) < 2) {\n                    nextOtherPos[0] = fixedPos[0];\n                }\n                const [\n                    widthOffset,\n                ] = solveNextOffset(\n                    fixedPos, nextOtherPos,\n                    (fixedPos[0] < otherPos[0] ? right : left) - otherPos[0],\n                    true, datas,\n                );\n                if (!isNaN(widthOffset)) {\n                    maxWidth = width + horizontalDirection * widthOffset;\n                }\n            }\n        });\n    }\n    return {\n        maxWidth,\n        maxHeight,\n    };\n}\nfunction getSnapBoundInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    directions: number[][][],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any,\n) {\n    return directions.map(([startDirection, endDirection]) => {\n        const otherStartPos = getPosByDirection(poses, startDirection);\n        const otherEndPos = getPosByDirection(poses, endDirection);\n        const snapBoundInfo\n            = keepRatio\n                ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos, isRequest)\n                : checkSnapBounds(moveable, isRequest, [otherEndPos]);\n\n        const {\n            horizontal: {\n                dist: otherHorizontalDist,\n                offset: otherHorizontalOffset,\n                isBound: isOtherHorizontalBound,\n                isSnap: isOtherHorizontalSnap,\n            },\n            vertical: {\n                dist: otherVerticalDist,\n                offset: otherVerticalOffset,\n                isBound: isOtherVerticalBound,\n                isSnap: isOtherVerticalSnap,\n            },\n        } = snapBoundInfo;\n\n        const multiple = minus(endDirection, startDirection);\n\n        if (!otherVerticalOffset && !otherHorizontalOffset) {\n            return {\n                isBound: isOtherVerticalBound || isOtherHorizontalBound,\n                isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\n                sign: multiple,\n                offset: [0, 0],\n            };\n        }\n        const isVertical = otherHorizontalDist < otherVerticalDist;\n        const sizeOffset = solveNextOffset(\n            otherStartPos,\n            otherEndPos,\n            -(isVertical ? otherVerticalOffset : otherHorizontalOffset),\n            isVertical,\n            datas,\n        ).map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n        return {\n            sign: multiple,\n            isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\n            isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\n            offset: sizeOffset,\n        };\n    });\n}\nexport function getCheckSnapDirections(\n    direction: number[],\n    keepRatio: boolean,\n) {\n    const directions: number[][][] = [];\n    const fixedDirection = [-direction[0], -direction[1]];\n\n    if (direction[0] && direction[1]) {\n        directions.push(\n            [fixedDirection, [direction[0], -direction[1]]],\n            [fixedDirection, [-direction[0], direction[1]]],\n        );\n        if (keepRatio) {\n            // pass two direction condition\n            directions.push(\n                [fixedDirection, direction],\n            );\n        }\n    } else if (direction[0]) {\n        // vertcal\n        if (keepRatio) {\n            directions.push(\n                [fixedDirection, [fixedDirection[0], -1]],\n                [fixedDirection, [fixedDirection[0], 1]],\n                [fixedDirection, [direction[0], -1]],\n                [fixedDirection, direction],\n                [fixedDirection, [direction[0], 1]],\n            );\n        } else {\n            directions.push(\n                [[fixedDirection[0], -1], [direction[0], -1]],\n                [[fixedDirection[0], 0], [direction[0], 0]],\n                [[fixedDirection[0], 1], [direction[0], 1]],\n            );\n        }\n    } else if (direction[1]) {\n        // horizontal\n        if (keepRatio) {\n            directions.push(\n                [fixedDirection, [-1, fixedDirection[1]]],\n                [fixedDirection, [1, fixedDirection[1]]],\n                [fixedDirection, [-1, direction[1]]],\n                [fixedDirection, [1, direction[1]]],\n                [fixedDirection, direction],\n            );\n        } else {\n            directions.push(\n                [[-1, fixedDirection[1]], [-1, direction[1]]],\n                [[0, fixedDirection[1]], [0, direction[1]]],\n                [[1, fixedDirection[1]], [1, direction[1]]],\n            );\n        }\n    } else {\n        // [0, 0] to all direction\n        directions.push(\n            [fixedDirection, [1, 0]],\n            [fixedDirection, [-1, 0]],\n            [fixedDirection, [0, -1]],\n            [fixedDirection, [0, 1]],\n\n            [[1, 0], [1, -1]],\n            [[1, 0], [1, 1]],\n            [[0, 1], [1, 1]],\n            [[0, 1], [-1, 1]],\n\n            [[-1, 0], [-1, -1]],\n            [[-1, 0], [-1, 1]],\n            [[0, -1], [1, -1]],\n            [[0, -1], [-1, -1]],\n        );\n    }\n\n    return directions;\n}\nexport function getSizeOffsetInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any,\n) {\n    const directions = getCheckSnapDirections(direction, keepRatio);\n    const lines = getCheckSnapLines(poses, direction, keepRatio);\n    const offsets = [\n        ...getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas),\n        ...getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas),\n    ];\n    const widthOffsetInfo = getNearOffsetInfo(offsets, 0);\n    const heightOffsetInfo = getNearOffsetInfo(offsets, 1);\n\n    return {\n        width: {\n            isBound: widthOffsetInfo.isBound,\n            offset: widthOffsetInfo.offset[0],\n        },\n        height: {\n            isBound: heightOffsetInfo.isBound,\n            offset: heightOffsetInfo.offset[1],\n        },\n    };\n}\nexport function recheckSizeByTwoDirection(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    width: number,\n    height: number,\n    maxWidth: number,\n    maxHeight: number,\n    direction: number[],\n    isRequest: boolean,\n    datas: any,\n) {\n    const snapPos = getPosByDirection(poses, direction);\n\n    const {\n        horizontal: {\n            offset: horizontalOffset,\n        },\n        vertical: {\n            offset: verticalOffset,\n        },\n    } = checkSnapBounds(moveable, isRequest, [snapPos]);\n\n    if (verticalOffset || horizontalOffset) {\n        const [nextWidthOffset, nextHeightOffset] = getDragDist({\n            datas,\n            distX: -verticalOffset,\n            distY: -horizontalOffset,\n        });\n\n        const nextWidth\n            = Math.min(maxWidth || Infinity, width + direction[0] * nextWidthOffset);\n        const nextHeight\n            = Math.min(maxHeight || Infinity, height + direction[1] * nextHeightOffset);\n\n        return [\n            nextWidth - width,\n            nextHeight - height,\n        ];\n    }\n    return [\n        0,\n        0,\n    ];\n}\nexport function checkSizeDist(\n    moveable: MoveableManagerInterface<any, any>,\n    getNextPoses: (widthOffset: number, heightOffset: number) => number[][],\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPos: number[],\n    isRequest: boolean,\n    datas: any,\n) {\n    const poses = getAbsolutePosesByState(moveable.state);\n    const keepRatio = moveable.props.keepRatio;\n\n    let widthOffset = 0;\n    let heightOffset = 0;\n\n    for (let i = 0; i < 2; ++i) {\n        const nextPoses = getNextPoses(widthOffset, heightOffset);\n        const {\n            width: widthOffsetInfo,\n            height: heightOffsetInfo,\n        } = getSizeOffsetInfo(\n            moveable,\n            nextPoses,\n            direction,\n            keepRatio,\n            isRequest,\n            datas,\n        );\n\n        const isWidthBound = widthOffsetInfo.isBound;\n        const isHeightBound = heightOffsetInfo.isBound;\n        let nextWidthOffset = widthOffsetInfo.offset;\n        let nextHeightOffset = heightOffsetInfo.offset;\n\n        if (i === 1) {\n            if (!isWidthBound) {\n                nextWidthOffset = 0;\n            }\n            if (!isHeightBound) {\n                nextHeightOffset = 0;\n            }\n        }\n        if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {\n            return [0, 0];\n        }\n        if (keepRatio) {\n            const widthDist = Math.abs(nextWidthOffset) * (width ? 1 / width : 1);\n            const heightDist = Math.abs(nextHeightOffset) * (height ? 1 / height : 1);\n            const isGetWidthOffset\n                = isWidthBound && isHeightBound ? widthDist < heightDist\n                    : isHeightBound || (!isWidthBound && widthDist < heightDist);\n\n            // height * widthOffset = width * heighOffset\n            if (isGetWidthOffset) {\n                // width : height = ? : heightOffset\n                nextWidthOffset = width * nextHeightOffset / height;\n            } else {\n                // width : height = widthOffset : ?\n                nextHeightOffset = height * nextWidthOffset / width;\n            }\n        }\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    if (direction[0] && direction[1]) {\n        const {\n            maxWidth,\n            maxHeight,\n        } = checkMaxBounds(moveable, poses, direction, fixedPos, datas);\n\n        const [nextWidthOffset, nextHeightOffset] = recheckSizeByTwoDirection(\n            moveable,\n            getNextPoses(widthOffset, heightOffset),\n            width + widthOffset,\n            height + heightOffset,\n            maxWidth,\n            maxHeight,\n            direction,\n            isRequest,\n            datas,\n        );\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    return [\n        widthOffset,\n        heightOffset,\n    ];\n}\n\nexport function checkSnapRotate(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    rect: RectInfo,\n    origin: number[],\n    rotation: number,\n) {\n    if (!hasGuidelines(moveable, \"rotatable\")) {\n        return rotation;\n    }\n\n    const {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = rect;\n    const rad = rotation * Math.PI / 180;\n    const prevPoses = [pos1, pos2, pos3, pos4].map(pos => minus(pos, origin));\n    const nextPoses = prevPoses.map(pos => rotate(pos, rad));\n\n    const result = [\n        ...checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation),\n        ...checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation),\n    ];\n    result.sort((a, b) => Math.abs(a - rotation) - Math.abs(b - rotation));\n\n    if (result.length) {\n        return result[0];\n    } else {\n        return rotation;\n    }\n}\nexport function checkSnapSize(\n    moveable: MoveableManagerInterface<any, any>,\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPos: number[],\n    isRequest: boolean,\n    datas: any,\n) {\n    if (!hasGuidelines(moveable, \"resizable\")) {\n        return [0, 0];\n    }\n    const {\n        matrix,\n        is3d,\n    } = moveable.state;\n    return checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                matrix,\n                width + widthOffset,\n                height + heightOffset,\n                fixedPos,\n                direction,\n                is3d,\n            );\n        }, width, height, direction, fixedPos, isRequest, datas,\n    );\n}\nexport function checkSnapScale(\n    moveable: MoveableManagerInterface<ScalableProps, any>,\n    scale: number[],\n    direction: number[],\n    fixedPos: number[],\n    isRequest: boolean,\n    datas: any,\n) {\n    const {\n        width,\n        height,\n    } = datas;\n    if (!hasGuidelines(moveable, \"scalable\")) {\n        return [0, 0];\n    }\n    const is3d = datas.is3d;\n    const sizeDist = checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                scaleMatrix(datas, plus(scale, [widthOffset / width, heightOffset / height])),\n                width,\n                height,\n                fixedPos,\n                direction,\n                is3d,\n            );\n        },\n        width, height,\n        direction,\n        fixedPos,\n        isRequest,\n        datas,\n    );\n\n    return [\n        sizeDist[0] / width,\n        sizeDist[1] / height,\n    ];\n}\nexport function solveEquation(\n    pos1: number[],\n    pos2: number[],\n    snapOffset: number,\n    isVertical: boolean,\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    if (!dx) {\n        // y = 0 * x + b\n        // only horizontal\n        if (!isVertical) {\n            return [0, snapOffset];\n        }\n        return [0, 0];\n    }\n    if (!dy) {\n        // only vertical\n        if (isVertical) {\n            return [snapOffset, 0];\n        }\n        return [0, 0];\n    }\n    // y = ax + b\n    const a = dy / dx;\n    const b = pos1[1] - a * pos1[0];\n\n    if (isVertical) {\n        // y = a * x + b\n        const y = a * (pos2[0] + snapOffset) + b;\n\n        return [snapOffset, y - pos2[1]];\n    } else {\n        // x = (y - b) / a\n        const x = (pos2[1] + snapOffset - b) / a;\n\n        return [x - pos2[0], snapOffset];\n    }\n}\n\nexport function startCheckSnapDrag(\n    moveable: MoveableManagerInterface<any, any>,\n    datas: any,\n) {\n    datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\n\nexport function checkThrottleDragRotate(\n    throttleDragRotate: number,\n    [distX, distY]: number[],\n    [isVerticalBound, isHorizontalBound]: boolean[],\n    [isVerticalSnap, isHorizontalSnap]: boolean[],\n    [verticalOffset, horizontalOffset]: number[],\n) {\n    let offsetX = -verticalOffset;\n    let offsetY = -horizontalOffset;\n\n    if (throttleDragRotate && distX && distY) {\n        offsetX = 0;\n        offsetY = 0;\n        const adjustPoses: number[][] = [];\n        if (isVerticalBound && isHorizontalBound) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n                [verticalOffset, 0],\n            );\n        } else if (isVerticalBound) {\n            adjustPoses.push(\n                [verticalOffset, 0],\n            );\n        } else if (isHorizontalBound) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n            );\n        } else if (isVerticalSnap && isHorizontalSnap) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n                [verticalOffset, 0],\n            );\n        } else if (isVerticalSnap) {\n            adjustPoses.push(\n                [verticalOffset, 0],\n            );\n        } else if (isHorizontalSnap) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n            );\n        }\n        if (adjustPoses.length) {\n            adjustPoses.sort((a, b) => {\n                return getDistSize(minus([distX, distY], a)) - getDistSize(minus([distX, distY], b));\n            });\n            const adjustPos = adjustPoses[0];\n\n            if (adjustPos[0] && Math.abs(distX) > TINY_NUM) {\n                offsetX = -adjustPos[0];\n                offsetY = distY * Math.abs(distX + offsetX) / Math.abs(distX) - distY;\n            } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM) {\n                const prevDistY = distY;\n                offsetY = -adjustPos[1];\n                offsetX = distX * Math.abs(distY + offsetY) / Math.abs(prevDistY) - distX;\n            }\n            if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\n                if (Math.abs(offsetX) > TINY_NUM && Math.abs(offsetX) < Math.abs(verticalOffset)) {\n                    const scale = Math.abs(verticalOffset) / Math.abs(offsetX);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else if (Math.abs(offsetY) > TINY_NUM && Math.abs(offsetY) < Math.abs(horizontalOffset)) {\n                    const scale = Math.abs(horizontalOffset) / Math.abs(offsetY);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else {\n                    offsetX = maxOffset(-verticalOffset, offsetX);\n                    offsetY = maxOffset(-horizontalOffset, offsetY);\n                }\n            }\n        }\n    } else {\n        offsetX = (distX || isVerticalBound) ? -verticalOffset : 0;\n        offsetY = (distY || isHorizontalBound) ? -horizontalOffset : 0;\n    }\n    return [offsetX, offsetY];\n}\nexport function checkSnapDrag(\n    moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n    distX: number,\n    distY: number,\n    throttleDragRotate: number,\n    isRequest: boolean,\n    datas: any,\n) {\n\n    if (!hasGuidelines(moveable, \"draggable\")) {\n        return [\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n        ];\n    }\n    const poses = getAbsolutePoses(\n        datas.absolutePoses,\n        [distX, distY],\n    );\n    const { left, right, top, bottom } = getRect(poses);\n    const snapCenter = moveable.props.snapCenter;\n    const snapPoses = [\n        [left, top],\n        [right, top],\n        [left, bottom],\n        [right, bottom],\n    ];\n\n    if (snapCenter) {\n        snapPoses.push([(left + right) / 2, (top + bottom) / 2]);\n    }\n    const {\n        vertical: verticalSnapBoundInfo,\n        horizontal: horizontalSnapBoundInfo,\n    } = checkSnapBounds(moveable, isRequest, snapPoses, poses);\n    const {\n        vertical: verticalInnerBoundInfo,\n        horizontal: horizontalInnerBoundInfo,\n    } = getInnerBoundDragInfo(moveable, poses, datas);\n\n    const isVerticalSnap = verticalSnapBoundInfo.isSnap;\n    const isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\n    const isVerticalBound\n        = verticalSnapBoundInfo.isBound\n        || verticalInnerBoundInfo.isBound;\n    const isHorizontalBound\n        = horizontalSnapBoundInfo.isBound\n        || horizontalInnerBoundInfo.isBound;\n    const verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);\n    const horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);\n    const [offsetX, offsetY] = checkThrottleDragRotate(\n        throttleDragRotate,\n        [distX, distY],\n        [isVerticalBound, isHorizontalBound],\n        [isVerticalSnap, isHorizontalSnap],\n        [verticalOffset, horizontalOffset],\n    );\n    return [\n        {\n            isBound: isVerticalBound,\n            isSnap: isVerticalSnap,\n            offset: offsetX,\n        },\n        {\n            isBound: isHorizontalBound,\n            isSnap: isHorizontalSnap,\n            offset: offsetY,\n        },\n    ];\n}\n\nfunction getSnapGuidelines(posInfos: SnapPosInfo[]) {\n    const guidelines: Guideline[] = [];\n\n    posInfos.forEach(posInfo => {\n        posInfo.guidelineInfos.forEach(({ guideline }) => {\n            if (guidelines.indexOf(guideline) > -1) {\n                return;\n            }\n            guidelines.push(guideline);\n        });\n    });\n\n    return guidelines;\n}\n\nfunction getElementGuidelineDist(\n    elementPos: number,\n    elementSize: number,\n    targetPos: number,\n    targetSize: number,\n) {\n    // relativePos < 0  => element(l)  ---  (r)target\n    // relativePos > 0  => target(l)   ---  (r)element\n    const relativePos = elementPos - targetPos;\n    const startPos = relativePos < 0 ? relativePos + elementSize : targetSize;\n    const endPos = relativePos < 0 ? 0 : relativePos;\n    const size = endPos - startPos;\n\n    return {\n        size,\n        pos: startPos,\n    };\n}\nfunction groupByElementGuidelines(\n    guidelines: Guideline[],\n    clientPos: number,\n    size: number,\n    index: number,\n) {\n    const groupInfos: Array<[Element, number, any]> = [];\n\n    const group = groupBy(guidelines.filter(({ element, gap }) => element && !gap), ({ element, pos }) => {\n        const elementPos = pos[index];\n        const sign = Math.min(0, elementPos - clientPos) < 0 ? -1 : 1;\n        const groupKey = `${sign}_${pos[index ? 0 : 1]}`;\n        const groupInfo = find(groupInfos, ([groupElement, groupPos]) => {\n            return element === groupElement && elementPos === groupPos;\n        });\n        if (groupInfo) {\n            return groupInfo[2];\n        }\n        groupInfos.push([element!, elementPos, groupKey]);\n        return groupKey;\n    });\n    group.forEach(elementGuidelines => {\n        elementGuidelines.sort((a, b) => {\n            const result = getElementGuidelineDist(a.pos[index], a.size, clientPos, size).size\n                - getElementGuidelineDist(b.pos[index], a.size, clientPos, size).size;\n\n            return result || a.pos[index ? 0 : 1] - b.pos[index ? 0 : 1];\n        });\n    });\n    return group;\n}\nfunction renderElementGroup(\n    group: Guideline[][],\n    [directionName, posName1, posName2, sizeName]: readonly [string, string, string, string],\n    minPos: number,\n    clientPos: number,\n    clientSize: number,\n    targetPos: number,\n    snapThreshold: number,\n    isDisplaySnapDigit: boolean,\n    snapDigit: number,\n    index: number,\n    snapDistFormat: Required<SnappableOptions>[\"snapDistFormat\"],\n    React: Renderer,\n) {\n    return flat(group.map((elementGuidelines, i) => {\n        let isFirstRenderSize = true;\n\n        return elementGuidelines.map(({ pos, size }, j) => {\n            const {\n                pos: linePos,\n                size: lineSize,\n            } = getElementGuidelineDist(pos[index], size, clientPos, clientSize);\n\n            if (lineSize < snapThreshold) {\n                return null;\n            }\n            const isRenderSize = isFirstRenderSize;\n\n            isFirstRenderSize = false;\n            const snapSize = isDisplaySnapDigit && isRenderSize ? parseFloat(lineSize.toFixed(snapDigit)) : 0;\n\n            return <div className={prefix(\n                \"line\",\n                directionName,\n                \"guideline\",\n                \"dashed\",\n            )}\n                data-size={snapSize > 0 ? snapDistFormat(snapSize) : \"\"}\n                key={`${directionName}LinkGuidline${i}-${j}`} style={{\n                    [posName1]: `${minPos + linePos}px`,\n                    [posName2]: `${-targetPos + pos[index ? 0 : 1]}px`,\n                    [sizeName]: `${lineSize}px`,\n                }} />;\n        });\n    }));\n}\nfunction renderSnapPoses(\n    snapPoses: SnappableRenderType[],\n    [directionName, posName1, posName2, sizeName]: readonly [string, string, string, string],\n    minPos: number,\n    targetPos: number,\n    size: number,\n    React: Renderer,\n) {\n    return snapPoses.map(({ type, pos }, i) => {\n        return <div className={prefix(\n            \"line\",\n            directionName,\n            \"guideline\",\n            \"target\",\n            \"bold\",\n            type,\n        )} key={`${directionName}TargetGuidline${i}`} style={{\n            [posName1]: `${minPos}px`,\n            [posName2]: `${-targetPos + pos}px`,\n            [sizeName]: `${size}px`,\n        }} />;\n    });\n}\nfunction renderGuidelines(\n    guidelines: Guideline[],\n    [directionName, posName1, posName2, sizeName]: readonly [string, string, string, string],\n    targetPos1: number,\n    targetPos2: number,\n    index: number,\n    React: Renderer,\n) {\n    return guidelines.map((guideline, i) => {\n        const { pos, size, element } = guideline;\n\n        return <div className={prefix(\n            \"line\",\n            directionName,\n            \"guideline\",\n            element ? \"bold\" : \"\",\n        )} key={`${directionName}Guidline${i}`} style={{\n            [posName1]: `${-targetPos1 + pos[index]}px`,\n            [posName2]: `${-targetPos2 + pos[index ? 0 : 1]}px`,\n            [sizeName]: `${size}px`,\n        }} />;\n    });\n}\n\nfunction getGapGuidelinesToStart(\n    guidelines: Guideline[],\n    index: number,\n    targetPos: number[],\n    targetSizes: number[],\n    guidelinePos: number[],\n    gap: number,\n    otherPos: number,\n): GapGuideline[] {\n    const absGap = Math.abs(gap);\n    let start = guidelinePos[index] + (gap > 0 ? targetSizes[0] : 0);\n\n    return guidelines.filter(({ pos: gapPos }) => gapPos[index] <= targetPos[index])\n        .sort(({ pos: aPos }, { pos: bPos }) => bPos[index] - aPos[index])\n        .filter(({ pos: gapPos, sizes: gapSizes }) => {\n            const nextPos = gapPos[index];\n\n            if (throttle(nextPos + gapSizes![index], 0.0001) === throttle(start - absGap, 0.0001)) {\n                start = nextPos;\n                return true;\n            }\n            return false;\n        }).map(gapGuideline => {\n            const renderPos = -targetPos[index] + gapGuideline.pos[index] + gapGuideline.sizes![index];\n\n            return {\n                ...gapGuideline,\n                gap,\n                renderPos: index ? [otherPos, renderPos] : [renderPos, otherPos],\n            };\n        });\n}\nfunction getGapGuidelinesToEnd(\n    guidelines: Guideline[],\n    index: number,\n    targetPos: number[],\n    targetSizes: number[],\n    guidelinePos: number[],\n    gap: number,\n    otherPos: number,\n): GapGuideline[] {\n    const absGap = Math.abs(gap);\n    let start = guidelinePos[index] + (gap < 0 ? targetSizes[index] : 0);\n\n    return guidelines.filter(({ pos: gapPos }) => gapPos[index] > targetPos[index])\n        .sort(({ pos: aPos }, { pos: bPos }) => aPos[index] - bPos[index])\n        .filter(({ pos: gapPos, sizes: gapSizes }) => {\n            const nextPos = gapPos[index];\n\n            if (throttle(nextPos, 0.0001) === throttle(start + absGap, 0.0001)) {\n                start = nextPos + gapSizes![index];\n                return true;\n            }\n            return false;\n        }).map(gapGuideline => {\n            const renderPos = -targetPos[index] + gapGuideline.pos[index] - absGap;\n\n            return {\n                ...gapGuideline,\n                gap,\n                renderPos: index ? [otherPos, renderPos] : [renderPos, otherPos],\n            };\n        });\n}\nfunction getGapGuidelines(\n    guidelines: Guideline[],\n    type: \"vertical\" | \"horizontal\",\n    targetPos: number[],\n    targetSizes: number[],\n): GapGuideline[] {\n    const elementGuidelines = guidelines.filter(\n        ({ element, gap, type: guidelineType }) => element && gap && guidelineType === type);\n    const [index, otherIndex] = type === \"vertical\" ? [0, 1] : [1, 0];\n\n    return flat(elementGuidelines.map((guideline, i) => {\n        const pos = guideline.pos;\n        const gap = guideline.gap!;\n        const gapGuidelines = guideline.gapGuidelines!;\n        const sizes = guideline.sizes!;\n\n        let offset = minOffset(\n            pos[otherIndex] + sizes[otherIndex] - targetPos[otherIndex],\n            pos[otherIndex] - targetPos[otherIndex] - targetSizes[otherIndex],\n        );\n        const minSize = Math.min(sizes[otherIndex], targetSizes[otherIndex]);\n\n        if (offset > 0 && offset > minSize) {\n            offset = (offset - minSize / 2) * 2;\n        } else if (offset < 0 && offset < -minSize) {\n            offset = (offset + minSize / 2) * 2;\n        }\n\n        const otherPos = (offset > 0 ? 0 : targetSizes[otherIndex]) + offset / 2;\n        return [\n            ...getGapGuidelinesToStart(gapGuidelines, index, targetPos, targetSizes, pos, gap, otherPos),\n            ...getGapGuidelinesToEnd(gapGuidelines, index, targetPos, targetSizes, pos, gap, otherPos),\n        ];\n    }));\n}\nfunction renderGapGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    gapGuidelines: GapGuideline[],\n    type: \"vertical\" | \"horizontal\",\n    [directionName, posName1, posName2, sizeName]: readonly [string, string, string, string],\n    snapDistFormat: Required<SnappableOptions>[\"snapDistFormat\"],\n    React: any,\n) {\n    const {\n        snapDigit = 0,\n        isDisplaySnapDigit = true,\n    } = moveable.props;\n\n    const otherType = type === \"vertical\" ? \"horizontal\" : \"vertical\";\n    const [index, otherIndex] = type === \"vertical\" ? [0, 1] : [1, 0];\n\n    return gapGuidelines.map(({ renderPos, gap }, i) => {\n        const absGap = Math.abs(gap!);\n        const snapSize = isDisplaySnapDigit ? parseFloat(absGap.toFixed(snapDigit)) : 0;\n\n        return <div className={prefix(\n            \"line\",\n            directionName,\n            \"guideline\",\n            \"gap\",\n        )}\n            data-size={snapSize > 0 ? snapDistFormat(snapSize) : \"\"}\n            key={`${otherType}GapGuideline${i}`} style={{\n                [posName1]: `${renderPos[index]}px`,\n                [posName2]: `${renderPos[otherIndex]}px`,\n                [sizeName]: `${absGap}px`,\n            }} />;\n    });\n}\n\nfunction addBoundGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n    verticalSnapPoses: SnappableRenderType[],\n    horizontalSnapPoses: SnappableRenderType[],\n) {\n    const {\n        vertical: {\n            isBound: isVerticalBound,\n            pos: verticalBoundPos,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            pos: horizontalBoundPos,\n        },\n    } = checkBoundPoses(moveable, verticalPoses, horizontalPoses);\n\n    if (isVerticalBound) {\n        verticalSnapPoses.push({\n            type: \"bounds\",\n            pos: verticalBoundPos,\n        });\n    }\n    if (isHorizontalBound) {\n        horizontalSnapPoses.push({\n            type: \"bounds\",\n            pos: horizontalBoundPos,\n        });\n    }\n    const {\n        vertical: verticalInnerBoundPoses,\n        horizontal: horizontalInnerBoundPoses,\n    } = checkInnerBoundPoses(moveable);\n\n    verticalInnerBoundPoses.forEach(innerPos => {\n        if (findIndex(verticalSnapPoses, ({ type, pos }) => type === \"bounds\" && pos === innerPos) >= 0) {\n            return;\n        }\n        verticalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos,\n        });\n    });\n\n    horizontalInnerBoundPoses.forEach(innerPos => {\n        if (findIndex(horizontalSnapPoses, ({ type, pos }) => type === \"bounds\" && pos === innerPos) >= 0) {\n            return;\n        }\n        horizontalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos,\n        });\n    });\n}\n/**\n * @namespace Moveable.Snappable\n * @description Whether or not target can be snapped to the guideline. (default: false)\n * @sort 2\n */\nexport default {\n    name: \"snappable\",\n    props: {\n        snappable: [Boolean, Array],\n        snapCenter: Boolean,\n        snapHorizontal: Boolean,\n        snapVertical: Boolean,\n        snapElement: Boolean,\n        snapGap: Boolean,\n        isDisplaySnapDigit: Boolean,\n        snapDigit: Number,\n        snapThreshold: Number,\n        horizontalGuidelines: Array,\n        verticalGuidelines: Array,\n        elementGuidelines: Array,\n        bounds: Object,\n        innerBounds: Object,\n        snapDistFormat: Function,\n    } as const,\n    events: {\n        onSnap: \"snap\",\n    } as const,\n    css: [\n        `:host {\n    --bounds-color: #d66;\n}`,\n        `.guideline {\n    pointer-events: none;\n    z-index: 1;\n}`,\n        `.line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<SnappableProps, SnappableState>, React: Renderer): any[] {\n        const {\n            top: targetTop,\n            left: targetLeft,\n            pos1, pos2, pos3, pos4,\n            snapRenderInfo,\n            targetClientRect,\n            containerClientRect,\n            is3d,\n            rootMatrix,\n        } = moveable.state;\n\n        if (!snapRenderInfo || !hasGuidelines(moveable, \"\")) {\n            return [];\n        }\n\n        const n = is3d ? 4 : 3;\n        const minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n        const minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n        const containerPos = caculateContainerPos(rootMatrix, containerClientRect, n);\n        const [clientLeft, clientTop] = caculateInversePosition(rootMatrix, [\n            targetClientRect.left - containerPos[0],\n            targetClientRect.top - containerPos[1],\n        ], n);\n\n        const {\n            snapThreshold = 5,\n            snapDigit = 0,\n            isDisplaySnapDigit = true,\n            snapDistFormat = (v: number) => v,\n        } = moveable.props;\n        const poses = getAbsolutePosesByState(moveable.state);\n        const { width, height, top, left, bottom, right } = getRect(poses);\n        const verticalSnapPoses: SnappableRenderType[] = [];\n        const horizontalSnapPoses: SnappableRenderType[] = [];\n        const verticalGuidelines: Guideline[] = [];\n        const horizontalGuidelines: Guideline[] = [];\n        const snapInfos: Array<{ vertical: SnapInfo, horizontal: SnapInfo }> = [];\n\n        if (!snapRenderInfo.request) {\n            if (snapRenderInfo.direction) {\n                snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction));\n            }\n            if (snapRenderInfo.snap) {\n                const rect = getRect(poses);\n\n                if (snapRenderInfo.center) {\n                    (rect as any).middle = (rect.top + rect.bottom) / 2;\n                    (rect as any).center = (rect.left + rect.right) / 2;\n                }\n                snapInfos.push(checkSnaps(moveable, rect, true, 1));\n            }\n            snapInfos.forEach(snapInfo => {\n                const {\n                    vertical: {\n                        posInfos: verticalPosInfos,\n                    },\n                    horizontal: {\n                        posInfos: horizontalPosInfos,\n                    },\n                } = snapInfo;\n                verticalSnapPoses.push(...verticalPosInfos.map(posInfo => ({\n                    type: \"snap\",\n                    pos: posInfo.pos,\n                } as const)));\n                horizontalSnapPoses.push(...horizontalPosInfos.map(posInfo => ({\n                    type: \"snap\",\n                    pos: posInfo.pos,\n                } as const)));\n                verticalGuidelines.push(...getSnapGuidelines(verticalPosInfos));\n                horizontalGuidelines.push(...getSnapGuidelines(horizontalPosInfos));\n            });\n        }\n        addBoundGuidelines(\n            moveable,\n            [left, right],\n            [top, bottom],\n            verticalSnapPoses,\n            horizontalSnapPoses,\n        );\n        const elementHorizontalGroup = groupByElementGuidelines(\n            horizontalGuidelines,\n            clientLeft,\n            width,\n            0,\n        );\n        const elementVerticalGroup = groupByElementGuidelines(\n            verticalGuidelines,\n            clientTop,\n            height,\n            1,\n        );\n        const horizontalNames = [\"horizontal\", \"left\", \"top\", \"width\"] as const;\n        const verticalNames = [\"vertical\", \"top\", \"left\", \"height\"] as const;\n\n        const gapVerticalGuidelines = getGapGuidelines(\n            verticalGuidelines, \"vertical\",\n            [targetLeft, targetTop],\n            [width, height],\n        );\n        const gapHorizontalGuidelines = getGapGuidelines(\n            horizontalGuidelines, \"horizontal\",\n            [targetLeft, targetTop],\n            [width, height],\n        );\n\n        const allGuidelines = [\n            ...verticalGuidelines,\n            ...horizontalGuidelines,\n        ];\n        triggerEvent(moveable, \"onSnap\", {\n            guidelines: allGuidelines.filter(({ element }) => !element),\n            elements: groupBy(allGuidelines.filter(({ element }) => element), ({ element }) => element),\n            gaps: [\n                ...gapVerticalGuidelines,\n                ...gapHorizontalGuidelines,\n            ],\n        }, true);\n\n        return [\n            ...renderGapGuidelines(\n                moveable,\n                gapVerticalGuidelines,\n                \"vertical\",\n                horizontalNames,\n                snapDistFormat,\n                React,\n            ),\n            ...renderGapGuidelines(\n                moveable,\n                gapHorizontalGuidelines,\n                \"horizontal\",\n                verticalNames,\n                snapDistFormat,\n                React,\n            ),\n            ...renderElementGroup(\n                elementHorizontalGroup,\n                horizontalNames,\n                minLeft,\n                clientLeft,\n                width,\n                targetTop,\n                snapThreshold,\n                isDisplaySnapDigit,\n                snapDigit,\n                0,\n                snapDistFormat,\n                React,\n            ),\n            ...renderElementGroup(\n                elementVerticalGroup,\n                verticalNames,\n                minTop,\n                clientTop,\n                height,\n                targetLeft,\n                snapThreshold,\n                isDisplaySnapDigit,\n                snapDigit,\n                1,\n                snapDistFormat,\n                React,\n            ),\n            ...renderSnapPoses(\n                horizontalSnapPoses,\n                horizontalNames,\n                minLeft,\n                targetTop,\n                width,\n                React,\n            ),\n            ...renderSnapPoses(\n                verticalSnapPoses,\n                verticalNames,\n                minTop,\n                targetLeft,\n                height,\n                React,\n            ),\n            ...renderGuidelines(\n                horizontalGuidelines,\n                horizontalNames,\n                targetLeft,\n                targetTop,\n                0,\n                React,\n            ),\n            ...renderGuidelines(\n                verticalGuidelines,\n                verticalNames,\n                targetTop,\n                targetLeft,\n                1,\n                React,\n            ),\n        ];\n    },\n    dragStart(moveable: MoveableManagerInterface<SnappableProps, SnappableState>, e: any) {\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            snap: true,\n            center: true,\n        };\n        snapStart(moveable);\n    },\n    pinchStart(moveable: MoveableManagerInterface<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragEnd(moveable: MoveableManagerInterface<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragControlCondition(e: any) {\n        return directionCondition(e) || rotatableDragControlCondtion(e);\n    },\n    dragControlStart(moveable: MoveableManagerInterface<SnappableProps, SnappableState>, e: any) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragGroupStart(moveable: any, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroupEnd(moveable: any) {\n        this.unset(moveable);\n    },\n    dragGroupControlStart(moveable: any, e: any) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragGroupControlEnd(moveable: any) {\n        this.unset(moveable);\n    },\n    unset(moveable: any) {\n        const state = moveable.state;\n\n        state.enableSnap = false;\n        state.guidelines = [];\n        state.snapRenderInfo = null;\n    },\n};\n\n/**\n* Whether or not target can be snapped to the guideline. (default: false)\n* @name Moveable.Snappable#snappable\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* moveable.snappable = true;\n*/\n/**\n * When you drag, make the snap in the center of the target. (default: false)\n * @name Moveable.Snappable#snapCenter\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n * });\n *\n * moveable.snapCenter = true;\n */\n\n/**\n * When you drag, make the snap in the vertical guidelines. (default: true)\n * @name Moveable.Snappable#snapVertical\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n * });\n *\n * moveable.snapVertical = false;\n */\n/**\n * When you drag, make the snap in the horizontal guidelines. (default: true)\n * @name Moveable.Snappable#snapHorizontal\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n * });\n *\n * moveable.snapHorizontal = false;\n */\n/**\n * When you drag, make the gap snap in the element guidelines. (default: true)\n * @name Moveable.Snappable#snapGap\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n *   snapGap: true,\n * });\n *\n * moveable.snapGap = false;\n */\n/**\n * When you drag, make the snap in the element guidelines. (default: true)\n * @name Moveable.Snappable#snapElement\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n * });\n *\n * moveable.snapElement = false;\n */\n/**\n * Distance value that can snap to guidelines. (default: 5)\n * @name Moveable.Snappable#snapThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapThreshold = 5;\n */\n\n/**\n * Add guidelines in the horizontal direction. (default: [])\n * @name Moveable.Snappable#horizontalGuidlines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.horizontalGuidlines = [100, 200, 500];\n */\n\n/**\n * Add guidelines in the vertical direction. (default: [])\n * @name Moveable.Snappable#verticalGuidlines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.verticalGuidlines = [100, 200, 500];\n */\n/**\n * Add guidelines for the element. (default: [])\n * @name Moveable.Snappable#elementGuidelines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.elementGuidelines = [\n *   document.querySelector(\".element\"),\n * ];\n */\n/**\n * You can set up boundaries. (default: null)\n * @name Moveable.Snappable#bounds\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};\n */\n/**\n * You can set up inner boundaries. (default: null)\n * @name Moveable.Snappable#innerBounds\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};\n */\n/**\n * snap distance digits (default: 0)\n * @name Moveable.Snappable#snapDigit\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapDigit = 0\n */\n/**\n * Whether to show snap distance (default: true)\n * @name Moveable.Snappable#isDisplaySnapDigit\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplaySnapDigit = true;\n */\n\n/**\n * You can set the text format of the distance shown in the guidelines. (default: self)\n * @name Moveable.Snappable#snapDistFormat\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  snappable: true,\n *  snapDistFormat: v => v,\n * });\n * moveable.snapDistFormat = v => `${v}px`;\n */\n\n/**\n * When you drag or dragControl, the `snap` event is called.\n * @memberof Moveable.Snappable\n * @event snap\n * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     snappable: true\n * });\n * moveable.on(\"snap\", e => {\n *     console.log(\"onSnap\", e);\n * });\n */\n","import { getDragDist, setDragStart } from \"../DraggerUtils\";\nimport { throttleArray, triggerEvent, fillParams, throttle, getDistSize, prefix, fillEndParams } from \"../utils\";\nimport { minus, plus, getRad } from \"../matrix\";\nimport {\n    DraggableProps, OnDrag, OnDragGroup,\n    OnDragGroupStart, OnDragStart, OnDragEnd, DraggableState,\n    Renderer, OnDragGroupEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport { triggerChildDragger } from \"../groupUtils\";\nimport { checkSnapDrag, startCheckSnapDrag } from \"./Snappable\";\nimport { IObject } from \"@daybrush/utils\";\n\n/**\n * @namespace Draggable\n * @memberof Moveable\n * @description Draggable refers to the ability to drag and move targets.\n */\nexport default {\n    name: \"draggable\",\n    props: {\n        draggable: Boolean,\n        throttleDrag: Number,\n        throttleDragRotate: Number,\n        startDragRotate: Number,\n    } as const,\n    events: {\n        onDragStart: \"dragStart\",\n        onDrag: \"drag\",\n        onDragEnd: \"dragEnd\",\n        onDragGroupStart: \"dragGroupStart\",\n        onDragGroup: \"dragGroup\",\n        onDragGroupEnd: \"dragGroupEnd\",\n    } as const,\n    render(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        React: Renderer,\n    ): any[] {\n        const throttleDragRotate = moveable.props.throttleDragRotate;\n        const { dragInfo, beforeOrigin } = moveable.state;\n\n        if (!throttleDragRotate || !dragInfo) {\n            return [];\n        }\n        const dist = dragInfo.dist;\n\n        if (!dist[0] && !dist[1]) {\n            return [];\n        }\n\n        const width = getDistSize(dist);\n        const rad = getRad(dist, [0, 0]);\n\n        return [<div className={prefix(\n            \"line\",\n            \"horizontal\",\n            \"dragline\",\n            \"dashed\",\n        )} key={`dragRotateGuideline`} style={{\n            width: `${width}px`,\n            transform: `translate(${beforeOrigin[0]}px, ${beforeOrigin[1]}px) rotate(${rad}rad)`,\n        }} />];\n    },\n    dragStart(\n        moveable: MoveableManagerInterface<DraggableProps, any>,\n        e: any,\n    ) {\n        const { datas, parentEvent, parentDragger } = e;\n        const state = moveable.state;\n        const {\n            targetTransform,\n            target,\n            dragger,\n        } = state;\n\n        if (dragger) {\n            return false;\n        }\n        state.dragger = parentDragger || moveable.targetDragger;\n        const style = window.getComputedStyle(target!);\n\n        datas.datas = {};\n        datas.left = parseFloat(style.left || \"\") || 0;\n        datas.top = parseFloat(style.top || \"\") || 0;\n        datas.bottom = parseFloat(style.bottom || \"\") || 0;\n        datas.right = parseFloat(style.right || \"\") || 0;\n        datas.transform = targetTransform;\n        datas.startTranslate = [0, 0];\n\n        setDragStart(moveable, { datas });\n\n        datas.prevDist = [0, 0];\n        datas.prevBeforeDist = [0, 0];\n        datas.isDrag = false;\n\n        startCheckSnapDrag(moveable, datas);\n        const params = fillParams<OnDragStart>(moveable, e, {\n            set: (translate: number[]) => {\n                datas.startTranslate = translate;\n            },\n        });\n        const result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n        if (result !== false) {\n            datas.isDrag = true;\n            moveable.state.dragInfo = {\n                startRect: moveable.getRect(),\n                dist: [0, 0],\n            };\n        } else {\n            state.dragger = null;\n            datas.isPinch = false;\n        }\n        return datas.isDrag ? params : false;\n    },\n    drag(\n        moveable: MoveableManagerInterface<DraggableProps, any>,\n        e: any,\n    ): OnDrag | undefined {\n        const { datas, parentEvent, parentFlag, isPinch, isRequest } = e;\n        let { distX, distY } = e;\n        const { isDrag, prevDist, prevBeforeDist, transform, startTranslate } = datas;\n\n        if (!isDrag) {\n            return;\n        }\n        const props = moveable.props;\n\n        const parentMoveable = props.parentMoveable;\n        const throttleDrag = parentEvent ? 0 : (props.throttleDrag || 0);\n        const throttleDragRotate = parentEvent ? 0 : (props.throttleDragRotate || 0);\n\n        let isSnap = false;\n        let dragRotateRad = 0;\n\n        if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {\n            const startDragRotate = props.startDragRotate || 0;\n            const deg\n                = throttle(startDragRotate + getRad([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate)\n                - startDragRotate;\n            const ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));\n            const rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));\n            const r = getDistSize([rx, ry]);\n            dragRotateRad = deg * Math.PI / 180;\n\n            distX = r * Math.cos(dragRotateRad);\n            distY = r * Math.sin(dragRotateRad);\n        }\n\n        if (!isPinch && !parentEvent && !parentFlag && (!throttleDragRotate || distX || distY)) {\n            const [verticalInfo, horizontalInfo] = checkSnapDrag(\n                moveable, distX, distY, throttleDragRotate, isRequest, datas,\n            );\n            const {\n                isSnap: isVerticalSnap,\n                isBound: isVerticalBound,\n                offset: verticalOffset,\n            } = verticalInfo;\n            const {\n                isSnap: isHorizontalSnap,\n                isBound: isHorizontalBound,\n                offset: horizontalOffset,\n            } = horizontalInfo;\n            isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;\n\n            distX += verticalOffset;\n            distY += horizontalOffset;\n        }\n        datas.passDeltaX = distX - (datas.passDistX || 0);\n        datas.passDeltaY = distY - (datas.passDistY || 0);\n        datas.passDistX = distX;\n        datas.passDistY = distY;\n        const beforeTranslate = plus(getDragDist({ datas, distX, distY }, true), startTranslate);\n        const translate = plus(getDragDist({ datas, distX, distY }, false), startTranslate);\n\n        if (!throttleDragRotate && !isSnap) {\n            throttleArray(translate, throttleDrag);\n            throttleArray(beforeTranslate, throttleDrag);\n        }\n\n        const beforeDist = minus(beforeTranslate, startTranslate);\n        const dist = minus(translate, startTranslate);\n        const delta = minus(dist, prevDist);\n        const beforeDelta = minus(beforeDist, prevBeforeDist);\n\n        datas.prevDist = dist;\n        datas.prevBeforeDist = beforeDist;\n\n        const left = datas.left + beforeDist[0];\n        const top = datas.top + beforeDist[1];\n        const right = datas.right - beforeDist[0];\n        const bottom = datas.bottom - beforeDist[1];\n        const nextTransform = `${transform} translate(${dist[0]}px, ${dist[1]}px)`;\n\n        moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;\n        if (!parentEvent && !parentMoveable && delta.every(num => !num) && beforeDelta.some(num => !num)) {\n            return;\n        }\n        const params = fillParams<OnDrag>(moveable, e, {\n            transform: nextTransform,\n            dist,\n            delta,\n            translate,\n            beforeDist,\n            beforeDelta,\n            beforeTranslate,\n            left,\n            top,\n            right,\n            bottom,\n            isPinch,\n        });\n\n        !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n        return params;\n    },\n    dragEnd(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        e: any,\n    ) {\n        const { parentEvent, datas, isDrag } = e;\n\n        moveable.state.dragger = null;\n        moveable.state.dragInfo = null;\n        if (!datas.isDrag) {\n            return;\n        }\n        datas.isDrag = false;\n        !parentEvent && triggerEvent<DraggableProps>(moveable, \"onDragEnd\", fillEndParams<OnDragEnd>(moveable, e, {}));\n        return isDrag;\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas, clientX, clientY } = e;\n\n        const params = this.dragStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const events = triggerChildDragger(moveable, this, \"dragStart\", [\n            clientX || 0,\n            clientY || 0,\n        ], e, false);\n\n        const nextParams: OnDragGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n\n        datas.isDrag = result !== false;\n\n        return datas.isDrag ? params : false;\n    },\n    dragGroup(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        const params = this.drag(moveable, e);\n        const { passDeltaX, passDeltaY } = e.datas;\n        const events = triggerChildDragger(moveable, this, \"drag\", [passDeltaX, passDeltaY], e, false);\n\n        if (!params) {\n            return;\n        }\n        const nextParams: OnDragGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onDragGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        this.dragEnd(moveable, e);\n        triggerChildDragger(moveable, this, \"dragEnd\", [0, 0], e, false);\n        triggerEvent(moveable, \"onDragGroupEnd\", fillEndParams<OnDragGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n        }));\n\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Draggable#request\n     * @param {object} [e] - the draggable's request parameter\n     * @param {number} [e.x] - x position\n     * @param {number} [e.y] - y position\n     * @param {number} [e.deltaX] - X number to move\n     * @param {number} [e.deltaY] - Y number to move\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"draggable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 });\n     * moveable.request(\"draggable\", { x: 220, y: 100 });\n     * moveable.request(\"draggable\", { x: 240, y: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n\n        return {\n            isControl: false,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"x\" in e) {\n                    distX = e.x - rect.left;\n                } else if (\"deltaX\" in e) {\n                    distX += e.deltaX;\n                }\n                if (\"y\" in e) {\n                    distY = e.y - rect.top;\n                } else if (\"deltaY\" in e) {\n                    distY += e.deltaY;\n                }\n\n                return { datas, distX, distY };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n    unset(moveable: any) {\n        moveable.state.dragInfo = null;\n    },\n};\n\n/**\n * Whether or not target can be dragged. (default: false)\n * @name Moveable.Draggable#draggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.draggable = true;\n */\n\n/**\n * throttle of x, y when drag.\n * @name Moveable.Draggable#throttleDrag\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleDrag = 1;\n */\n\n/**\n* throttle of angle of x, y when drag.\n* @name Moveable.Draggable#throttleDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* moveable.throttleDragRotate = 45;\n*/\n\n/**\n* start angle of throttleDragRotate of x, y when drag.\n* @name Moveable.Draggable#startDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* // 45, 135, 225, 315\n* moveable.throttleDragRotate = 90;\n* moveable.startDragRotate = 45;\n*/\n\n/**\n * When the drag starts, the dragStart event is called.\n * @memberof Moveable.Draggable\n * @event dragStart\n * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When dragging, the drag event is called.\n * @memberof Moveable.Draggable\n * @event drag\n * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"drag\", ({ target, transform }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the drag finishes, the dragEnd event is called.\n * @memberof Moveable.Draggable\n * @event dragEnd\n * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n /**\n * When the group drag starts, the `dragGroupStart` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroupStart\n * @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupStart\", ({ targets }) => {\n *     console.log(\"onDragGroupStart\", targets);\n * });\n */\n\n /**\n * When the group drag, the `dragGroup` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroup\n * @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroup\", ({ targets, events }) => {\n *     console.log(\"onDragGroup\", targets);\n *     events.forEach(ev => {\n *          // drag event\n *          console.log(\"onDrag left, top\", ev.left, ev.top);\n *          // ev.target!.style.left = `${ev.left}px`;\n *          // ev.target!.style.top = `${ev.top}px`;\n *          console.log(\"onDrag translate\", ev.dist);\n *          ev.target!.style.transform = ev.transform;)\n *     });\n * });\n */\n\n/**\n * When the group drag finishes, the `dragGroupEnd` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroupEnd\n * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onDragGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    throttle, prefix, triggerEvent, fillParams,\n    getRotationRad, getClientRect, caculatePosition, fillEndParams\n} from \"../utils\";\nimport { IObject, hasClass } from \"@daybrush/utils\";\nimport {\n    RotatableProps, OnRotateGroup, OnRotateGroupEnd,\n    Renderer, OnRotateGroupStart, OnRotateStart, OnRotate,\n    OnRotateEnd, MoveableClientRect, SnappableProps, SnappableState, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport { triggerChildAble } from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { minus, plus, getRad, rotate as rotateMatrix } from \"../matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapRotate } from \"./Snappable\";\n\n/**\n * @namespace Rotatable\n * @memberof Moveable\n * @description Rotatable indicates whether the target can be rotated.\n */\n\nfunction setRotateStartInfo(\n    moveable: MoveableManagerInterface<any, any>,\n    datas: IObject<any>, clientX: number, clientY: number, origin: number[], rect: MoveableClientRect) {\n\n    const n = moveable.state.is3d ? 4 : 3;\n    const nextOrigin = caculatePosition(moveable.state.rootMatrix, origin, n);\n    const startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);\n\n    datas.startAbsoluteOrigin = startAbsoluteOrigin;\n    datas.prevDeg = getRad(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\n    datas.prevSnapDeg = datas.prevDeg;\n    datas.startDeg = datas.prevDeg;\n    datas.loop = 0;\n}\nfunction getParentDeg(\n    moveable: MoveableManagerInterface<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    parentDist: number,\n    direction: number,\n    startRotate: number,\n) {\n    const {\n        prevDeg,\n    } = datas;\n\n    // const absoluteDeg = startRotate + parentDist;\n    const dist = checkSnapRotate(\n        moveable,\n        moveableRect,\n        datas.origin,\n        parentDist,\n    );\n    datas.prevDeg = dist;\n\n    const delta = dist - prevDeg;\n\n    return [delta, dist, startRotate + dist];\n}\nfunction getDeg(\n    moveable: MoveableManagerInterface<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    deg: number,\n    direction: number,\n    startRotate: number,\n    throttleRotate: number,\n    isSnap?: boolean,\n) {\n    const {\n        prevDeg,\n        prevSnapDeg,\n        startDeg,\n        loop: prevLoop,\n    } = datas;\n\n    if (prevDeg > deg && prevDeg > 270 && deg < 90) {\n        // 360 => 0\n        ++datas.loop;\n    } else if (prevDeg < deg && prevDeg < 90 && deg > 270) {\n        // 0 => 360\n        --datas.loop;\n    }\n    const loop = datas.loop;\n    const absolutePrevSnapDeg = prevLoop * 360 + prevSnapDeg - startDeg + startRotate;\n    let absoluteDeg = loop * 360 + deg - startDeg + startRotate;\n\n    datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startRotate;\n\n    absoluteDeg = throttle(absoluteDeg, throttleRotate);\n    let dist = direction * (absoluteDeg - startRotate);\n    if (isSnap) {\n        dist = checkSnapRotate(moveable, moveableRect, datas.origin, dist);\n        absoluteDeg = dist / direction + startRotate;\n    }\n    datas.prevSnapDeg = absoluteDeg - loop * 360 + startDeg - startRotate;\n\n    const delta = direction * (absoluteDeg - absolutePrevSnapDeg);\n\n    return [delta, dist, startRotate + dist];\n}\nfunction getRotateInfo(\n    moveable: MoveableManagerInterface<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    direction: number,\n    clientX: number, clientY: number,\n    startRotate: number,\n    throttleRotate: number,\n) {\n    return getDeg(\n        moveable,\n        moveableRect,\n        datas,\n        getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180,\n        direction,\n        startRotate,\n        throttleRotate,\n        true,\n    );\n}\n\nexport function getReversePositionX(dir: string) {\n    if (dir === \"left\") {\n        return \"right\";\n    } else if (dir === \"right\") {\n        return \"left\";\n    }\n    return dir;\n}\nexport function getReversePositionY(dir: string) {\n    if (dir === \"top\") {\n        return \"bottom\";\n    } else if (dir === \"bottom\") {\n        return \"top\";\n    }\n    return dir;\n}\nexport function getPositions(\n    rotationPosition: RotatableProps[\"rotationPosition\"],\n    [pos1, pos2, pos3, pos4]: number[][],\n    direction: number,\n) {\n    const [dir1, dir2] = (rotationPosition || \"top\").split(\"-\");\n    let radPoses = [pos1, pos2];\n\n    // if (scale[0] < 0) {\n    //     dir1 = getReversePositionX(dir1);\n    //     dir2 = getReversePositionX(dir2);\n    // }\n    // if (scale[1] < 0) {\n    //     dir1 = getReversePositionY(dir1);\n    //     dir2 = getReversePositionY(dir2);\n    // }\n    if (dir1 === \"left\") {\n        radPoses = [pos3, pos1];\n    } else if (dir1 === \"right\") {\n        radPoses = [pos2, pos4];\n    } else if (dir1 === \"bottom\") {\n        radPoses = [pos4, pos3];\n    }\n    let pos = [\n        (radPoses[0][0] + radPoses[1][0]) / 2,\n        (radPoses[0][1] + radPoses[1][1]) / 2,\n    ];\n    const rad = getRotationRad(radPoses, direction);\n\n    if (dir2) {\n        const isStart = dir2 === \"top\" || dir2 === \"left\";\n        const isReverse = dir1 === \"bottom\" || dir1 === \"left\";\n\n        pos = radPoses[(isStart && !isReverse) || (!isStart && isReverse) ? 0 : 1];\n    }\n    return [pos, rad] as const;\n}\n\nexport function dragControlCondition(e: any) {\n    if (e.isRequest) {\n        return e.requestAble === \"rotatable\";\n    }\n    return hasClass(e.inputEvent.target, prefix(\"rotation\"));\n}\n\nexport default {\n    name: \"rotatable\",\n    canPinch: true,\n    props: {\n        rotatable: Boolean,\n        rotationPosition: String,\n        throttleRotate: Number,\n    } as const,\n    events: {\n        onRotateStart: \"rotateStart\",\n        onRotate: \"rotate\",\n        onRotateEnd: \"rotateEnd\",\n        onRotateGroupStart: \"rotateGroupStart\",\n        onRotateGroup: \"rotateGroup\",\n        onRotateGroupEnd: \"rotateGroupEnd\",\n    } as const,\n    render(moveable: MoveableManagerInterface<RotatableProps>, React: Renderer): any {\n        const {\n            rotatable,\n            rotationPosition,\n        } = moveable.props;\n        if (!rotatable) {\n            return null;\n        }\n        const { renderPoses, direction } = moveable.state;\n        const [pos, rotationRad] = getPositions(rotationPosition!, renderPoses, direction);\n\n        return (\n            <div key=\"rotation\" className={prefix(\"line rotation-line\")} style={{\n                // tslint:disable-next-line: max-line-length\n                transform: `translate(-50%) translate(${pos[0]}px, ${pos[1]}px) rotate(${rotationRad}rad)`,\n            }}>\n                <div className={prefix(\"control\", \"rotation\")}></div>\n            </div>\n        );\n    },\n    dragControlCondition,\n    dragControlStart(\n        moveable: MoveableManagerInterface<RotatableProps & SnappableProps, SnappableState>,\n        e: any) {\n        const {\n            datas,\n            clientX, clientY,\n            parentRotate, parentFlag, isPinch,\n            isRequest,\n        } = e;\n        const {\n            target, left, top, origin, beforeOrigin,\n            direction, beforeDirection, targetTransform,\n        } = moveable.state;\n\n        if (!isRequest && !target) {\n            return false;\n        }\n\n        const rect = moveable.getRect();\n        datas.rect = rect;\n        datas.transform = targetTransform;\n        datas.left = left;\n        datas.top = top;\n\n        if (isRequest || isPinch || parentFlag) {\n            const externalRotate = parentRotate || 0;\n\n            datas.beforeInfo = {\n                origin: rect.beforeOrigin,\n                prevDeg: externalRotate,\n                startDeg: externalRotate,\n                prevSnapDeg: externalRotate, loop: 0,\n            };\n            datas.afterInfo = {\n                origin: rect.origin,\n                prevDeg: externalRotate, startDeg: externalRotate,\n                prevSnapDeg: externalRotate, loop: 0,\n            };\n        } else {\n            datas.beforeInfo = { origin: rect.beforeOrigin };\n            datas.afterInfo = { origin: rect.origin };\n\n            const controlRect = getClientRect(moveable.controlBox.getElement());\n\n            setRotateStartInfo(moveable, datas.beforeInfo, clientX, clientY, beforeOrigin, controlRect);\n            setRotateStartInfo(moveable, datas.afterInfo, clientX, clientY, origin, controlRect);\n        }\n\n        datas.direction = direction;\n        datas.beforeDirection = beforeDirection;\n        datas.startRotate = 0;\n        datas.datas = {};\n\n        const params = fillParams<OnRotateStart>(moveable, e, {\n            set: (rotatation: number) => {\n                datas.startRotate = rotatation;\n            },\n        });\n        const result = triggerEvent(moveable, \"onRotateStart\", params);\n        datas.isRotate = result !== false;\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n        };\n\n        return datas.isRotate ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<RotatableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, parentRotate, parentFlag, isPinch } = e;\n        const {\n            direction,\n            beforeDirection,\n            beforeInfo,\n            afterInfo,\n            isRotate,\n            startRotate,\n            rect,\n        } = datas;\n\n        if (!isRotate) {\n            return;\n        }\n        const {\n            throttleRotate = 0,\n            parentMoveable,\n        } = moveable.props;\n\n        let delta: number;\n        let dist: number;\n        let rotate: number;\n        let beforeDelta: number;\n        let beforeDist: number;\n        let beforeRotate: number;\n\n        if (!parentFlag && \"parentDist\" in e) {\n            const parentDist = e.parentDist;\n\n            [delta, dist, rotate]\n                = getParentDeg(moveable, rect, afterInfo, parentDist, direction, startRotate);\n            [beforeDelta, beforeDist, beforeRotate]\n                = getParentDeg(moveable, rect, beforeInfo, parentDist, direction, startRotate);\n\n        } else if (isPinch || parentFlag) {\n            [delta, dist, rotate]\n                = getDeg(moveable, rect, afterInfo, parentRotate, direction, startRotate, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate]\n                = getDeg(moveable, rect, beforeInfo, parentRotate, direction, startRotate, throttleRotate);\n        } else {\n            [delta, dist, rotate]\n                = getRotateInfo(moveable, rect, afterInfo, direction, clientX, clientY, startRotate, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate] = getRotateInfo(\n                moveable, rect, beforeInfo, beforeDirection, clientX, clientY, startRotate, throttleRotate,\n            );\n        }\n\n        if (!delta && !beforeDelta && !parentMoveable) {\n            return;\n        }\n        const params = fillParams<OnRotate>(moveable, e, {\n            delta,\n            dist,\n            rotate,\n            beforeDist,\n            beforeDelta,\n            beforeRotate,\n            transform: `${datas.transform} rotate(${dist}deg)`,\n            isPinch: !!isPinch,\n        });\n        triggerEvent(moveable, \"onRotate\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RotatableProps>, e: any) {\n        const { datas, isDrag } = e;\n\n        if (!datas.isRotate) {\n            return false;\n        }\n        datas.isRotate = false;\n\n        triggerEvent(moveable, \"onRotateEnd\", fillEndParams<OnRotateEnd>(moveable, e, {}));\n        return isDrag;\n    },\n    dragGroupControlCondition: dragControlCondition,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas, inputEvent } = e;\n        const {\n            left: parentLeft,\n            top: parentTop,\n            beforeOrigin: parentBeforeOrigin,\n        } = moveable.state;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        params.set(datas.beforeDirection * moveable.rotation);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            { ...e, parentRotate: 0 },\n            (child, childDatas, eventParams) => {\n                const { left, top, beforeOrigin } = child.state;\n                const childClient = plus(\n                    minus([left, top], [parentLeft, parentTop]),\n                    minus(beforeOrigin, parentBeforeOrigin),\n                );\n\n                childDatas.prevClient = childClient;\n                eventParams.dragStart = Draggable.dragStart(\n                    child,\n                    new CustomDragger().dragStart(childClient, inputEvent),\n                );\n            },\n        );\n\n        const nextParams: OnRotateGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n\n        datas.isRotate = result !== false;\n\n        return datas.isRotate ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { inputEvent, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const direction = datas.beforeDirection;\n        const parentRotate = params.beforeDist;\n        const deg = params.beforeDelta;\n        const rad = deg / 180 * Math.PI;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            { ...e, parentRotate },\n            (child, childDatas, result, i) => {\n                const [prevX, prevY] = childDatas.prevClient;\n                const [clientX, clientY] = rotateMatrix([prevX, prevY], rad * direction);\n                const delta = [clientX - prevX, clientY - prevY];\n\n                childDatas.prevClient = [clientX, clientY];\n\n                const dragResult = Draggable.drag(\n                    child,\n                    setCustomDrag(child.state, delta, inputEvent, !!e.isPinch, false),\n                );\n                result.drag = dragResult;\n            },\n        );\n        moveable.rotation = direction * params.beforeRotate;\n\n        const nextParams: OnRotateGroup = {\n            targets: moveable.props.targets!,\n            events,\n            set: (rotation: number) => {\n                moveable.rotation = rotation;\n            },\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onRotateGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams = fillEndParams<OnRotateGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n        });\n\n        triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Rotatable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.deltaRotate=0] -  delta number of rotation\n     * @param {number} [e.rotate=0] - absolute number of moveable's rotation\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"rotatable\", { deltaRotate: 10 }, true);\n     *\n     * * moveable.request(\"rotatable\", { rotate: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"rotatable\");\n     *\n     * // request\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     *\n     * requester.request({ rotate: 10 });\n     * requester.request({ rotate: 20 });\n     * requester.request({ rotate: 30 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<RotatableProps>) {\n        const datas = {};\n        let distRotate = 0;\n\n        const startRotation = moveable.getRotation();\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"deltaRotate\" in e) {\n                    distRotate += e.deltaRotate;\n                } else if (\"rotate\" in e) {\n                    distRotate = e.rotate - startRotation;\n                }\n\n                return { datas, parentDist: distRotate };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n/**\n * Whether or not target can be rotated. (default: false)\n * @name Moveable.Rotatable#rotatable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.rotatable = true;\n */\n/**\n * You can specify the position of the rotation. (default: \"top\")\n * @name Moveable.Rotatable#rotationPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   rotationPosition: \"top\",\n * });\n *\n * moveable.rotationPosition = \"bottom\"\n */\n\n/**\n * throttle of angle(degree) when rotate.\n * @name Moveable.Rotatable#throttleRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleRotate = 1;\n */\n\n/**\n * When the rotate starts, the rotateStart event is called.\n * @memberof Moveable.Rotatable\n * @event rotateStart\n * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n* When rotating, the rotate event is called.\n* @memberof Moveable.Rotatable\n* @event rotate\n* @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { rotatable: true });\n* moveable.on(\"rotate\", ({ target, transform, dist }) => {\n*     target.style.transform = transform;\n* });\n*/\n/**\n * When the rotate finishes, the rotateEnd event is called.\n * @memberof Moveable.Rotatable\n * @event rotateEnd\n * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n * When the group rotate starts, the `rotateGroupStart` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupStart\n * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupStart\", ({ targets }) => {\n *     console.log(\"onRotateGroupStart\", targets);\n * });\n */\n\n/**\n* When the group rotate, the `rotateGroup` event is called.\n* @memberof Moveable.Rotatable\n* @event rotateGroup\n* @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     rotatable: true\n* });\n* moveable.on(\"rotateGroup\", ({ targets, events }) => {\n*     console.log(\"onRotateGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group rotate.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const deg = ev.beforeDist;\n*     });\n* });\n*/\n\n/**\n * When the group rotate finishes, the `rotateGroupEnd` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupEnd\n * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onRotateGroupEnd\", targets, isDrag);\n * });\n */\n","import { prefix, getControlTransform, throttle } from \"./utils\";\nimport { ResizableProps, ScalableProps, WarpableProps, Renderer, MoveableManagerInterface } from \"./types\";\nimport { DIRECTION_INDEXES, DIRECTION_ROTATIONS, DIRECTIONS } from \"./consts\";\nimport { IObject } from \"@daybrush/utils\";\n\nexport function renderControls(\n    moveable: MoveableManagerInterface<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    defaultDirections: string[],\n    React: Renderer,\n): any[] {\n    const {\n        renderPoses,\n        rotation,\n    } = moveable.state;\n    const {\n        renderDirections: directions = defaultDirections,\n    } = moveable.props;\n    const {\n        direction,\n    } = moveable.state;\n\n    const directionMap: IObject<boolean> = {};\n    directions.forEach(dir => {\n        directionMap[dir] = true;\n    });\n    return directions.map(dir => {\n        const indexes = DIRECTION_INDEXES[dir];\n\n        if (!indexes || !directionMap[dir]) {\n            return null;\n        }\n        let directionRotation = throttle(rotation / Math.PI * 180, 15) + DIRECTION_ROTATIONS[dir];\n\n        if (direction < 1) {\n            directionRotation = 360 - directionRotation;\n        }\n        directionRotation %= 180;\n\n        return (\n            <div className={prefix(\"control\", \"direction\", dir)}\n                data-rotation={directionRotation} data-direction={dir} key={`direction-${dir}`}\n                style={getControlTransform(rotation, ...indexes.map(index => renderPoses[index]))}></div>\n        );\n    });\n}\nexport function renderAllDirections(\n    moveable: MoveableManagerInterface<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    React: Renderer,\n) {\n    return renderControls(moveable, DIRECTIONS, React);\n}\nexport function renderDiagonalDirections(\n    moveable: MoveableManagerInterface<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    React: Renderer,\n): any[] {\n    return renderControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], React);\n}\n","import {\n    throttle, getDirection, triggerEvent,\n    fillParams, getKeepRatioHeight, getKeepRatioWidth, getCSSSize, getDistSize, caculateBoundSize, fillEndParams,\n} from \"../utils\";\nimport {\n    setDragStart,\n    getDragDist,\n    getResizeDist,\n    getStartDirection,\n    getAbsoluteFixedPosition,\n} from \"../DraggerUtils\";\nimport {\n    ResizableProps, OnResizeGroup, OnResizeGroupEnd,\n    Renderer, OnResizeGroupStart, DraggableProps, OnDrag, OnResizeStart, SnappableState,\n    OnResize, OnResizeEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirection\";\nimport {\n    triggerChildAble,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { getRad, caculate, createRotateMatrix, plus } from \"../matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapSize } from \"./Snappable\";\nimport {\n    directionCondition,\n} from \"./utils\";\nimport { IObject, isString } from \"@daybrush/utils\";\nimport { TINY_NUM } from \"../consts\";\n\n/**\n * @namespace Resizable\n * @memberof Moveable\n * @description Resizable indicates whether the target's width and height can be increased or decreased.\n */\n\nexport default {\n    name: \"resizable\",\n    ableGroup: \"size\",\n    updateRect: true,\n    canPinch: true,\n    props: {\n        resizable: Boolean,\n        throttleResize: Number,\n        renderDirections: Array,\n        keepRatio: Boolean,\n    } as const,\n    events: {\n        onResizeStart: \"resizeStart\",\n        onResize: \"resize\",\n        onResizeEnd: \"resizeEnd\",\n\n        onResizeGroupStart: \"resizeGroupStart\",\n        onResizeGroup: \"resizeGroup\",\n        onResizeGroupEnd: \"resizeGroupEnd\",\n    } as const,\n    render(moveable: MoveableManagerInterface<Partial<ResizableProps>>, React: Renderer): any[] | undefined {\n        const { resizable, edge } = moveable.props;\n        if (resizable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps, SnappableState>,\n        e: any,\n    ) {\n        const {\n            inputEvent,\n            isPinch,\n            parentDirection,\n            datas,\n            parentFlag,\n        } = e;\n\n        const direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n\n        const { target, width, height } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        !isPinch && setDragStart(moveable, { datas });\n\n        datas.datas = {};\n        datas.direction = direction;\n        datas.startOffsetWidth = width;\n        datas.startOffsetHeight = height;\n        datas.prevWidth = 0;\n        datas.prevHeight = 0;\n        [\n            datas.startWidth,\n            datas.startHeight,\n        ] = getCSSSize(target);\n        const padding = [Math.max(0, width - datas.startWidth), Math.max(0, height - datas.startHeight)];\n        datas.minSize = padding;\n        datas.maxSize = [Infinity, Infinity];\n\n        if (!parentFlag) {\n            const style = window.getComputedStyle(target);\n\n            datas.minSize = plus([\n                parseFloat(style.minWidth!) || 0,\n                parseFloat(style.minHeight!) || 0,\n            ], padding);\n            datas.maxSize = plus([\n                parseFloat(style.maxWidth!) || Infinity,\n                parseFloat(style.maxHeight!) || Infinity,\n            ], padding);\n        }\n        const transformOrigin = moveable.props.transformOrigin || \"% %\";\n\n        datas.transformOrigin = transformOrigin && isString(transformOrigin)\n            ? transformOrigin.split(\" \")\n            : transformOrigin;\n        datas.startDirection = getStartDirection(moveable, direction);\n        datas.fixedPosition = getAbsoluteFixedPosition(moveable, datas.startDirection);\n        datas.fixedOriginalPosition = getAbsoluteFixedPosition(moveable, direction);\n\n        const params = fillParams<OnResizeStart>(moveable, e, {\n            direction,\n            set: ([startWidth, startHeight]: number[]) => {\n                datas.startWidth = startWidth;\n                datas.startHeight = startHeight;\n            },\n            setMin: (minSize: number[]) => {\n                datas.minSize = minSize;\n            },\n            setMax: (maxSize: number[]) => {\n                datas.maxSize = maxSize;\n            },\n            setOrigin: (origin: Array<string | number>) => {\n                datas.transformOrigin = origin;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ),\n        });\n        const result = triggerEvent<ResizableProps>(moveable, \"onResizeStart\", params);\n        if (result !== false) {\n            datas.isResize = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction,\n            };\n        }\n        return datas.isResize ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const {\n            datas,\n            distX, distY,\n            parentFlag, isPinch,\n            parentDistance, parentScale, inputEvent,\n            parentKeepRatio,\n            dragClient,\n            parentDist,\n            isRequest,\n        } = e;\n\n        const {\n            direction,\n            isResize,\n            transformOrigin,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            startWidth,\n            startHeight,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n            minSize,\n            maxSize,\n        } = datas;\n        const {\n            throttleResize = 0,\n            parentMoveable,\n        } = moveable.props;\n        let sizeDirection = direction;\n\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [1, 1];\n        }\n        const keepRatio = moveable.props.keepRatio || parentKeepRatio;\n        const isWidth = sizeDirection[0] || !sizeDirection[1];\n        const ratio = isWidth ? startOffsetHeight / startOffsetWidth : startOffsetWidth / startOffsetHeight;\n        const startDirection = keepRatio || parentFlag ? direction : datas.startDirection;\n        let fixedPosition = dragClient;\n        let distWidth: number = 0;\n        let distHeight: number = 0;\n\n        if (!dragClient) {\n            if (!parentFlag && isPinch) {\n                fixedPosition = getAbsoluteFixedPosition(moveable, [0, 0]);\n            } else {\n                fixedPosition = (keepRatio ? datas.fixedOriginalPosition : datas.fixedPosition);\n            }\n        }\n\n        if (parentDist) {\n            distWidth = parentDist[0];\n            distHeight = parentDist[1];\n        } else if (parentScale) {\n            distWidth = (parentScale[0] - 1) * startOffsetWidth;\n            distHeight = (parentScale[1] - 1) * startOffsetHeight;\n        } else if (isPinch) {\n            if (parentDistance) {\n                distWidth = parentDistance;\n                distHeight = parentDistance * startOffsetHeight / startOffsetWidth;\n            }\n        } else {\n            const dist = getDragDist({ datas, distX, distY });\n\n            distWidth = sizeDirection[0] * dist[0];\n            distHeight = sizeDirection[1] * dist[1];\n\n            if (keepRatio && startOffsetWidth && startOffsetHeight) {\n                const rad = getRad([0, 0], dist);\n                const standardRad = getRad([0, 0], sizeDirection);\n                const ratioRad = getRad([0, 0], [startOffsetWidth, startOffsetHeight]);\n                const size = getDistSize([distWidth, distHeight]);\n                const signSize = Math.cos(rad - standardRad) * size;\n\n                if (!sizeDirection[0]) {\n                    // top, bottom\n                    distHeight = signSize;\n                    distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n                } else if (!sizeDirection[1]) {\n                    // left, right\n                    distWidth = signSize;\n                    distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n                } else {\n                    // two-way\n                    distWidth = Math.cos(ratioRad) * signSize;\n                    distHeight = Math.sin(ratioRad) * signSize;\n                }\n            }\n        }\n        let nextWidth = sizeDirection[0] || keepRatio\n            ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;\n        let nextHeight = sizeDirection[1] || keepRatio\n            ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;\n\n        if (keepRatio && startOffsetWidth && startOffsetHeight) {\n            // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight\n            nextHeight = nextWidth * startOffsetHeight / startOffsetWidth;\n        }\n        let snapDist = [0, 0];\n\n        if (!isPinch) {\n            snapDist = checkSnapSize(\n                moveable, nextWidth,\n                nextHeight, direction,\n                datas.fixedOriginalPosition,\n                isRequest,\n                datas,\n            );\n        }\n        if (parentDist) {\n            !parentDist[0] && (snapDist[0] = 0);\n            !parentDist[1] && (snapDist[1] = 0);\n        }\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    nextWidth = throttle(nextWidth, throttleResize!);\n                } else {\n                    nextHeight = throttle(nextHeight, throttleResize!);\n                }\n            }\n            if (\n                (sizeDirection[0] && !sizeDirection[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                nextWidth += snapDist[0];\n                nextHeight = getKeepRatioHeight(nextWidth, isWidth, ratio);\n            } else if (\n                (!sizeDirection[0] && sizeDirection[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                nextHeight += snapDist[1];\n                nextWidth = getKeepRatioWidth(nextHeight, isWidth, ratio);\n            }\n        } else {\n            nextWidth += snapDist[0];\n            nextHeight += snapDist[1];\n            if (!snapDist[0]) {\n                nextWidth = throttle(nextWidth, throttleResize!);\n            }\n            if (!snapDist[1]) {\n                nextHeight = throttle(nextHeight, throttleResize!);\n            }\n        }\n        [nextWidth, nextHeight] = caculateBoundSize(\n            [nextWidth, nextHeight],\n            minSize,\n            maxSize,\n            keepRatio,\n        );\n        nextWidth = Math.round(nextWidth);\n        nextHeight = Math.round(nextHeight);\n        distWidth = nextWidth - startOffsetWidth;\n        distHeight = nextHeight - startOffsetHeight;\n\n        const delta = [distWidth - prevWidth, distHeight - prevHeight];\n\n        datas.prevWidth = distWidth;\n        datas.prevHeight = distHeight;\n\n        const inverseDelta = getResizeDist(\n                moveable,\n                nextWidth, nextHeight,\n                startDirection, fixedPosition, transformOrigin);\n\n        if (!parentMoveable && delta.every(num => !num) && inverseDelta.every(num => !num)) {\n            return;\n        }\n        const params = fillParams<OnResize>(moveable, e, {\n            width: startWidth + distWidth,\n            height: startHeight + distHeight,\n            offsetWidth: nextWidth,\n            offsetHeight: nextHeight,\n            direction,\n            dist: [distWidth, distHeight],\n            delta,\n            isPinch: !!isPinch,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, inverseDelta, inputEvent, !!isPinch, false),\n            ) as OnDrag,\n        });\n        triggerEvent<ResizableProps>(moveable, \"onResize\", params);\n        return params;\n    },\n    dragControlAfter(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const datas = e.datas;\n        const {\n            isResize,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            width,\n            height,\n        } = moveable.state;\n        const errorWidth = width - (startOffsetWidth + prevWidth);\n        const errorHeight = height - (startOffsetHeight + prevHeight);\n        const isErrorWidth = Math.abs(errorWidth) > 3;\n        const isErrorHeight = Math.abs(errorHeight) > 3;\n\n        if (isErrorWidth) {\n            datas.startWidth += errorWidth;\n            datas.startOffsetWidth += errorWidth;\n            datas.prevWidth += errorWidth;\n        }\n        if (isErrorHeight) {\n            datas.startHeight += errorHeight;\n            datas.startOffsetHeight += errorHeight;\n            datas.prevHeight += errorHeight;\n        }\n        if (isErrorWidth || isErrorHeight) {\n            this.dragControl(moveable, e);\n            return true;\n        }\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isResize) {\n            return false;\n        }\n        datas.isResize = false;\n\n        const params = fillEndParams<OnResizeEnd>(moveable, e, {});\n        triggerEvent<ResizableProps>(moveable, \"onResizeEnd\", params);\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const direction = params.direction;\n        const fixedPosition = datas.fixedOriginalPosition;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            (child, childDatas) => {\n                const pos = getAbsoluteFixedPosition(child, direction);\n                const [originalX, originalY] = caculate(\n                    createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                    [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1],\n                    3,\n                );\n                childDatas.originalX = originalX;\n                childDatas.originalY = originalY;\n\n                return e;\n            },\n        );\n\n        const nextParams: OnResizeGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent<ResizableProps>(moveable, \"onResizeGroupStart\", nextParams);\n\n        datas.isResize = result !== false;\n        return datas.isResize ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        if (!datas.isResize) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const {\n            offsetWidth, offsetHeight, dist,\n        } = params;\n\n        const keepRatio = moveable.props.keepRatio;\n\n        const parentScale = [\n            offsetWidth / (offsetWidth - dist[0]),\n            offsetHeight / (offsetHeight - dist[1]),\n        ];\n        const fixedPosition = datas.fixedOriginalPosition;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            (_, childDatas) => {\n                const [clientX, clientY] = caculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        childDatas.originalX * parentScale[0],\n                        childDatas.originalY * parentScale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...e,\n                    parentDist: null,\n                    parentScale,\n                    dragClient: plus(fixedPosition, [clientX, clientY]),\n                    parentKeepRatio: keepRatio,\n                };\n            },\n        );\n        const nextParams: OnResizeGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent<ResizableProps>(moveable, \"onResizeGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isResize) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams: OnResizeGroupEnd = fillEndParams<OnResizeGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n        });\n\n        triggerEvent<ResizableProps>(moveable, \"onResizeGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Resizable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.direction=[1, 1]] - Direction to resize\n     * @param {number} [e.deltaWidth] - delta number of width\n     * @param {number} [e.deltaHeight] - delta number of height\n     * @param {number} [e.offsetWidth] - offset number of width\n     * @param {number} [e.offsetHeight] - offset number of height\n     * @param {number} [e.isInstant] - Whether to execute the request instantly\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"resizable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<any>) {\n        const datas = {};\n        let distWidth = 0;\n        let distHeight = 0;\n        const rect = moveable.getRect();\n\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas, parentDirection: e.direction || [1, 1] };\n            },\n            request(e: IObject<any>) {\n                if (\"offsetWidth\" in e) {\n                    distWidth = e.offsetWidth - rect.offsetWidth;\n                } else if (\"deltaWidth\" in e) {\n                    distWidth += e.deltaWidth;\n                }\n                if (\"offsetHeight\" in e) {\n                    distHeight = e.offsetHeight - rect.offsetHeight;\n                } else if (\"deltaHeight\" in e) {\n                    distHeight += e.deltaHeight;\n                }\n\n                return { datas, parentDist: [distWidth, distHeight] };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n\n/**\n * Whether or not target can be resized. (default: false)\n * @name Moveable.Resizable#resizable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     resizable: false,\n * });\n *\n * moveable.resizable = true;\n */\n\n/**\n * throttle of width, height when resize.\n * @name Moveable.Resizable#throttleResize\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   throttleResize: 0,\n * });\n *\n * moveable.throttleResize = 1;\n */\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Resizable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Resizable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n\n/**\n * When the resize starts, the resizeStart event is called.\n * @memberof Moveable.Resizable\n * @event resizeStart\n * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When resizing, the resize event is called.\n * @memberof Moveable.Resizable\n * @event resize\n * @param {Moveable.Resizable.OnResize} - Parameters for the resize event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resize\", ({ target, width, height }) => {\n *     target.style.width = `${e.width}px`;\n *     target.style.height = `${e.height}px`;\n * });\n */\n/**\n * When the resize finishes, the resizeEnd event is called.\n * @memberof Moveable.Resizable\n * @event resizeEnd\n * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n /**\n * When the group resize starts, the `resizeGroupStart` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroupStart\n * @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupStart\", ({ targets }) => {\n *     console.log(\"onResizeGroupStart\", targets);\n * });\n */\n\n /**\n * When the group resize, the `resizeGroup` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroup\n * @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroup\", ({ targets, events }) => {\n *     console.log(\"onResizeGroup\", targets);\n *     events.forEach(ev => {\n *         const offset = [\n *             direction[0] < 0 ? -ev.delta[0] : 0,\n *             direction[1] < 0 ? -ev.delta[1] : 0,\n *         ];\n *         // ev.drag is a drag event that occurs when the group resize.\n *         const left = offset[0] + ev.drag.beforeDist[0];\n *         const top = offset[1] + ev.drag.beforeDist[1];\n *         const width = ev.width;\n *         const top = ev.top;\n *     });\n * });\n */\n\n/**\n * When the group resize finishes, the `resizeGroupEnd` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroupEnd\n * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onResizeGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    throttle, getDirection, triggerEvent, multiply2,\n    fillParams, getKeepRatioHeight, getKeepRatioWidth, getDistSize, fillEndParams,\n} from \"../utils\";\nimport { MIN_SCALE } from \"../consts\";\nimport {\n    setDragStart, getDragDist,\n    getScaleDist,\n    getAbsoluteFixedPosition,\n} from \"../DraggerUtils\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirection\";\nimport {\n    ScalableProps, ResizableProps, OnScaleGroup, OnScaleGroupEnd,\n    Renderer, OnScaleGroupStart, DraggableProps, OnDragStart,\n    OnDrag, SnappableState, GroupableProps, OnScaleStart,\n    OnScale, OnScaleEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport {\n    triggerChildAble,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { getRad, caculate, createRotateMatrix, plus } from \"../matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapScale } from \"./Snappable\";\nimport { isArray, IObject } from \"@daybrush/utils\";\nimport {\n    directionCondition,\n} from \"./utils\";\n\n/**\n * @namespace Scalable\n * @memberof Moveable\n * @description Scalable indicates whether the target's x and y can be scale of transform.\n */\nexport default {\n    name: \"scalable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    props: {\n        scalable: Boolean,\n        throttleScale: Number,\n        renderDirections: String,\n        keepRatio: Boolean,\n    } as const,\n    events: {\n        onScaleStart: \"scaleStart\",\n        onScale: \"scale\",\n        onScaleEnd: \"scaleEnd\",\n        onScaleGroupStart: \"scaleGroupStart\",\n        onScaleGroup: \"scaleGroup\",\n        onScaleGroupEnd: \"scaleGroupEnd\",\n    } as const,\n    render(\n        moveable: MoveableManagerInterface<Partial<ResizableProps & ScalableProps>>,\n        React: Renderer): any[] | undefined {\n        const { resizable, scalable, edge } = moveable.props;\n        if (!resizable && scalable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManagerInterface<ScalableProps & DraggableProps, SnappableState>,\n        e: any) {\n\n        const { datas, isPinch, inputEvent, parentDirection } = e;\n        const direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n        const {\n            width,\n            height,\n            targetTransform,\n            target,\n        } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        if (!isPinch) {\n            setDragStart(moveable, { datas });\n        }\n\n        datas.datas = {};\n        datas.transform = targetTransform;\n        datas.prevDist = [1, 1];\n        datas.direction = direction;\n        datas.width = width;\n        datas.height = height;\n        datas.startScale = [1, 1];\n        datas.fixedDirection = direction.map((dir: number) => -dir);\n        datas.fixedPosition = getAbsoluteFixedPosition(moveable, direction);\n\n        const params = fillParams<OnScaleStart>(moveable, e, {\n            direction,\n            set: (scale: number[]) => {\n                datas.startScale = scale;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ) as OnDragStart,\n        });\n        const result = triggerEvent(moveable, \"onScaleStart\", params);\n\n        if (result !== false) {\n            datas.isScale = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction,\n            };\n\n        }\n        return datas.isScale ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<ScalableProps & DraggableProps & GroupableProps, SnappableState>,\n        e: any) {\n        const {\n            datas, distX, distY,\n            parentScale,\n            parentDistance,\n            parentKeepRatio,\n            parentFlag, isPinch, inputEvent,\n            dragClient,\n            parentDist,\n            isRequest,\n        } = e;\n        const {\n            prevDist,\n            direction,\n            width,\n            height,\n            transform,\n            isScale,\n            startScale,\n        } = datas;\n\n        if (!isScale) {\n            return false;\n        }\n\n        const {\n            throttleScale,\n            parentMoveable,\n        } = moveable.props;\n        let sizeDirection = direction;\n\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [1, 1];\n        }\n        const keepRatio = moveable.props.keepRatio || parentKeepRatio;\n        const state = moveable.state;\n        const isWidth = sizeDirection[0] || !sizeDirection[1];\n        const startWidth = width * startScale[0];\n        const startHeight = height * startScale[1];\n        const ratio = isWidth ? startHeight / startWidth : startWidth / startHeight;\n        let scaleX: number = 1;\n        let scaleY: number = 1;\n        let fixedPosition = dragClient;\n\n        if (!dragClient) {\n            if (!parentFlag && isPinch) {\n                fixedPosition = getAbsoluteFixedPosition(moveable, [0, 0]);\n            } else {\n                fixedPosition = datas.fixedPosition;\n            }\n        }\n\n        if (parentDist) {\n            scaleX = (width + parentDist[0]) / width;\n            scaleY = (height + parentDist[1]) / height;\n        } else if (parentScale) {\n            scaleX = parentScale[0];\n            scaleY = parentScale[1];\n        } else if (isPinch) {\n            if (parentDistance) {\n                scaleX = (width + parentDistance) / width;\n                scaleY = (height + parentDistance * height / width) / height;\n            }\n        } else {\n            const dist = getDragDist({ datas, distX, distY });\n            let distWidth = sizeDirection[0] * dist[0];\n            let distHeight = sizeDirection[1] * dist[1];\n\n            if (keepRatio && width && height) {\n                const rad = getRad([0, 0], dist);\n                const standardRad = getRad([0, 0], sizeDirection);\n                const ratioRad = getRad([0, 0], [startWidth, startHeight]);\n                const size = getDistSize([distWidth, distHeight]);\n                const signSize = Math.cos(rad - standardRad) * size;\n\n                if (!sizeDirection[0]) {\n                    // top, bottom\n                    distHeight = signSize;\n                    distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n                } else if (!sizeDirection[1]) {\n                    // left, right\n                    distWidth = signSize;\n                    distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n                } else {\n                    // two-way\n                    distWidth = Math.cos(ratioRad) * signSize;\n                    distHeight = Math.sin(ratioRad) * signSize;\n                }\n            }\n            scaleX = (width + distWidth) / width;\n            scaleY = (height + distHeight) / height;\n        }\n\n        scaleX = sizeDirection[0] || keepRatio ? scaleX * startScale[0] : startScale[0];\n        scaleY = sizeDirection[1] || keepRatio ? scaleY * startScale[1] : startScale[1];\n\n        if (scaleX === 0) {\n            scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (scaleY === 0) {\n            scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n\n        const nowDist = [scaleX / startScale[0], scaleY / startScale[1]];\n        let scale = [scaleX, scaleY];\n\n        if (!isPinch && moveable.props.groupable) {\n            const snapRenderInfo = state.snapRenderInfo || {};\n            const stateDirection = snapRenderInfo.direction;\n\n            if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n                state.snapRenderInfo = { direction, request: e.isRequest, };\n            }\n        }\n        let snapDist = [0, 0];\n\n        if (!isPinch) {\n            snapDist = checkSnapScale(\n                moveable,\n                nowDist,\n                direction,\n                datas.fixedPosition,\n                isRequest,\n                datas,\n            );\n        }\n\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale!) / startScale[0];\n                } else {\n                    nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale!) / startScale[1];\n                }\n            }\n\n            if (\n                (sizeDirection[0] && !sizeDirection[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                nowDist[0] += snapDist[0];\n                const snapHeight = getKeepRatioHeight(width * nowDist[0] * startScale[0], isWidth, ratio);\n\n                nowDist[1] = snapHeight / height / startScale[1];\n            } else if (\n                (!sizeDirection[0] && sizeDirection[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                nowDist[1] += snapDist[1];\n                const snapWidth = getKeepRatioWidth(height * nowDist[1] * startScale[1], isWidth, ratio);\n\n                nowDist[0] = snapWidth / width / startScale[0];\n            }\n        } else {\n            nowDist[0] += snapDist[0];\n            nowDist[1] += snapDist[1];\n            if (!snapDist[0]) {\n                nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale!) / startScale[0];\n            }\n            if (!snapDist[1]) {\n                nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale!) / startScale[1];\n            }\n        }\n        if (nowDist[0] === 0) {\n            nowDist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (nowDist[1] === 0) {\n            nowDist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        const delta = [nowDist[0] / prevDist[0], nowDist[1] / prevDist[1]];\n        scale = multiply2(nowDist, startScale);\n\n        datas.prevDist = nowDist;\n\n        const inverseDelta = getScaleDist(moveable, delta, direction, fixedPosition);\n\n        if (\n            scaleX === prevDist[0] && scaleY === prevDist[1]\n            && inverseDelta.every(num => !num)\n            && !parentMoveable\n        ) {\n            return false;\n        }\n\n        const params = fillParams<OnScale>(moveable, e, {\n            offsetWidth: width,\n            offsetHeight: height,\n            scale,\n            direction,\n            dist: nowDist,\n            delta,\n            transform: `${transform} scale(${scaleX}, ${scaleY})`,\n            isPinch: !!isPinch,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, inverseDelta, inputEvent, isPinch, false),\n            ) as OnDrag,\n        });\n        triggerEvent(moveable, \"onScale\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ScalableProps>, e: any) {\n        const { datas, isDrag } = e;\n        if (!datas.isScale) {\n            return false;\n        }\n\n        datas.isScale = false;\n\n        triggerEvent(moveable, \"onScaleEnd\", fillEndParams<OnScaleEnd>(moveable, e, {}));\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const direction = params.direction;\n        const fixedPosition = datas.fixedPosition;\n\n        datas.moveableScale = moveable.scale;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            (child, childDatas) => {\n                const pos = getAbsoluteFixedPosition(child, direction);\n\n                const [originalX, originalY] = caculate(\n                    createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                    [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1],\n                    3,\n                );\n                childDatas.originalX = originalX;\n                childDatas.originalY = originalY;\n\n                return e;\n            },\n        );\n\n        const nextParams: OnScaleGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n\n        datas.isScale = result !== false;\n        return datas.isScale ? nextParams : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        if (!datas.isScale) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n        if (!params) {\n            return;\n        }\n\n        const moveableScale = datas.moveableScale;\n        moveable.scale = [\n            params.scale[0] * moveableScale[0],\n            params.scale[1] * moveableScale[1],\n        ];\n        const keepRatio = moveable.props.keepRatio;\n        const { dist, scale } = params;\n\n        // const fixedDirection = datas.fixedDirection;\n        const fixedPosition = datas.fixedPosition;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            (_, childDatas) => {\n                const [clientX, clientY] = caculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        childDatas.originalX * dist[0],\n                        childDatas.originalY * dist[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...e,\n                    parentDist: null,\n                    parentScale: scale,\n                    parentKeepRatio: keepRatio,\n                    dragClient: plus(fixedPosition, [clientX, clientY]),\n                };\n            },\n        );\n        const nextParams: OnScaleGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onScaleGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isScale) {\n            return;\n        }\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams = fillEndParams<OnScaleGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n        });\n\n        triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Scalable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.direction=[1, 1]] - Direction to scale\n     * @param {number} [e.deltaWidth] - delta number of width\n     * @param {number} [e.deltaHeight] - delta number of height\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"scalable\");\n     *\n     * // request\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request() {\n        const datas = {};\n        let distWidth = 0;\n        let distHeight = 0;\n\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas, parentDirection: e.direction || [1, 1] };\n            },\n            request(e: IObject<any>) {\n                distWidth += e.deltaWidth;\n                distHeight += e.deltaHeight;\n\n                return { datas, parentDist: [distWidth, distHeight] };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n\n/**\n * Whether or not target can scaled. (default: false)\n * @name Moveable.Scalable#scalable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.scalable = true;\n */\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Scalable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.keepRatio = true;\n */\n\n/**\n * throttle of scaleX, scaleY when scale.\n * @name Moveable.Scalable#throttleScale\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleScale = 0.1;\n */\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Scalable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Scalable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * When the scale starts, the scaleStart event is called.\n * @memberof Moveable.Scalable\n * @event scaleStart\n * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When scaling, the scale event is called.\n * @memberof Moveable.Scalable\n * @event scale\n * @param {Moveable.Scalable.OnScale} - Parameters for the scale event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the scale finishes, the scaleEnd event is called.\n * @memberof Moveable.Scalable\n * @event scaleEnd\n * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the scaleEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group scale starts, the `scaleGroupStart` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroupStart\n* @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroupStart\", ({ targets }) => {\n*     console.log(\"onScaleGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group scale, the `scaleGroup` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroup\n* @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroup\", ({ targets, events }) => {\n*     console.log(\"onScaleGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group scale.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const scaleX = ev.scale[0];\n*         const scaleY = ev.scale[1];\n*     });\n* });\n*/\n\n/**\n * When the group scale finishes, the `scaleGroupEnd` event is called.\n * @memberof Moveable.Scalable\n * @event scaleGroupEnd\n * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onScaleGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    prefix, getLineStyle, getDirection, getAbsolutePosesByState,\n    triggerEvent, fillParams, makeMatrixCSS, fillEndParams,\n } from \"../utils\";\nimport {\n    convertDimension, invert, multiply,\n    caculate,\n    createIdentityMatrix,\n    ignoreDimension,\n    minus,\n    createWarpMatrix,\n    getRad,\n    plus,\n} from \"../matrix\";\nimport { NEARBY_POS } from \"../consts\";\nimport { setDragStart, getDragDist, getPosIndexesByDirection } from \"../DraggerUtils\";\nimport {\n    WarpableProps, ScalableProps, ResizableProps,\n    Renderer, SnappableProps, SnappableState,\n    OnWarpStart, OnWarp, OnWarpEnd, MoveableManagerInterface,\n} from \"../types\";\nimport { hasClass, dot } from \"@daybrush/utils\";\nimport { renderAllDirections } from \"../renderDirection\";\nimport { hasGuidelines, checkSnapBounds } from \"./Snappable\";\n\nfunction getMiddleLinePos(pos1: number[], pos2: number[]) {\n    return pos1.map((pos, i) => dot(pos, pos2[i], 1, 2));\n}\n\nfunction getTriangleRad(pos1: number[], pos2: number[], pos3: number[]) {\n    // pos1 Rad\n    const rad1 = getRad(pos1, pos2);\n    const rad2 = getRad(pos1, pos3);\n\n    const rad = rad2 - rad1;\n\n    return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1: number[][], poses2: number[][]) {\n    const rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n    const rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n    const pi = Math.PI;\n\n    if ((rad1 >= pi && rad2 <= pi) || (rad1 <= pi && rad2 >= pi)) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * @namespace Moveable.Warpable\n * @description Warpable indicates whether the target can be warped(distorted, bented).\n */\nexport default {\n    name: \"warpable\",\n    ableGroup: \"size\",\n    props: {\n        warpable: Boolean,\n        renderDirections: Array,\n    } as const,\n    events: {\n        onWarpStart: \"warpStart\",\n        onWarp: \"warp\",\n        onWarpEnd: \"warpEnd\",\n    } as const,\n    render(moveable: MoveableManagerInterface<ResizableProps & ScalableProps & WarpableProps>, React: Renderer): any[] {\n        const { resizable, scalable, warpable } = moveable.props;\n\n        if (resizable || scalable || !warpable) {\n            return [];\n        }\n        const { pos1, pos2, pos3, pos4 } = moveable.state;\n\n        const linePosFrom1 = getMiddleLinePos(pos1, pos2);\n        const linePosFrom2 = getMiddleLinePos(pos2, pos1);\n        const linePosFrom3 = getMiddleLinePos(pos1, pos3);\n        const linePosFrom4 = getMiddleLinePos(pos3, pos1);\n        const linePosTo1 = getMiddleLinePos(pos3, pos4);\n        const linePosTo2 = getMiddleLinePos(pos4, pos3);\n        const linePosTo3 = getMiddleLinePos(pos2, pos4);\n        const linePosTo4 = getMiddleLinePos(pos4, pos2);\n\n        return [\n            <div className={prefix(\"line\")} key=\"middeLine1\" style={getLineStyle(linePosFrom1, linePosTo1)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine2\" style={getLineStyle(linePosFrom2, linePosTo2)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine3\" style={getLineStyle(linePosFrom3, linePosTo3)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine4\" style={getLineStyle(linePosFrom4, linePosTo4)}></div>,\n            ...renderAllDirections(moveable, React),\n        ];\n    },\n    dragControlCondition(e: any) {\n        if (e.isRequest) {\n            return false;\n        }\n        return hasClass(e.inputEvent.target, prefix(\"direction\"));\n    },\n    dragControlStart(\n        moveable: MoveableManagerInterface<WarpableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, inputEvent } = e;\n        const { target } = moveable.props;\n        const { target: inputTarget } = inputEvent;\n        const direction = getDirection(inputTarget);\n\n        if (!direction || !target) {\n            return false;\n        }\n        const state = moveable.state;\n        const {\n            transformOrigin, is3d,\n            targetTransform, targetMatrix,\n            width, height,\n            left, top,\n        } = state;\n\n        datas.datas = {};\n        datas.targetTransform = targetTransform;\n        datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);\n        datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);\n        datas.direction = direction;\n        datas.left = left;\n        datas.top = top;\n\n        setDragStart(moveable, { datas });\n        datas.poses = [\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n        ].map(p => minus(p, transformOrigin));\n\n        datas.nextPoses = datas.poses.map(([x, y]: number[]) => caculate(datas.warpTargetMatrix, [x, y, 0, 1], 4));\n        datas.startMatrix = createIdentityMatrix(4);\n        datas.prevMatrix = createIdentityMatrix(4);\n        datas.absolutePoses = getAbsolutePosesByState(state);\n        datas.posIndexes = getPosIndexesByDirection(direction);\n        state.snapRenderInfo = {\n            request: e.isRequest,\n            direction,\n        };\n\n        const params = fillParams<OnWarpStart>(moveable, e, {\n            set: (matrix: number[]) => {\n                datas.startMatrix = matrix;\n            },\n        });\n        const result = triggerEvent(moveable, \"onWarpStart\", params);\n        if (result !== false) {\n            datas.isWarp = true;\n        }\n        return datas.isWarp;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<WarpableProps & SnappableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, isRequest } = e;\n        let { distX, distY } = e;\n        const {\n            targetInverseMatrix, prevMatrix, isWarp, startMatrix,\n            poses,\n            posIndexes,\n            absolutePoses,\n        } = datas;\n\n        if (!isWarp) {\n            return false;\n        }\n\n        if (hasGuidelines(moveable, \"warpable\")) {\n            const selectedPoses: number[][] = posIndexes.map((index: number) => absolutePoses[index]);\n\n            if (selectedPoses.length > 1) {\n                selectedPoses.push([\n                    (selectedPoses[0][0] + selectedPoses[1][0]) / 2,\n                    (selectedPoses[0][1] + selectedPoses[1][1]) / 2,\n                ]);\n            }\n\n            const {\n                horizontal: horizontalSnapInfo,\n                vertical: verticalSnapInfo,\n            } = checkSnapBounds(\n                moveable,\n                isRequest,\n                selectedPoses.map(pos => [pos[0] + distX, pos[1] + distY]),\n            );\n\n            distY -= horizontalSnapInfo.offset;\n            distX -= verticalSnapInfo.offset;\n        }\n\n        const dist = getDragDist({ datas, distX, distY }, true);\n        const nextPoses = datas.nextPoses.slice();\n\n        posIndexes.forEach((index: number) => {\n            nextPoses[index] = plus(nextPoses[index], dist);\n        });\n\n        if (!NEARBY_POS.every(\n            nearByPoses => isValidPos(nearByPoses.map(i => poses[i]), nearByPoses.map(i => nextPoses[i])),\n        )) {\n            return false;\n        }\n        const h = createWarpMatrix(\n            poses[0],\n            poses[2],\n            poses[1],\n            poses[3],\n            nextPoses[0],\n            nextPoses[2],\n            nextPoses[1],\n            nextPoses[3],\n        );\n\n        if (!h.length) {\n            return false;\n        }\n\n        const matrix = multiply(targetInverseMatrix, h, 4);\n        const transform = `${datas.targetTransform} ${makeMatrixCSS(matrix, true)}`;\n        const delta = multiply(invert(prevMatrix, 4), matrix, 4);\n\n        datas.prevMatrix = matrix;\n\n        triggerEvent(moveable, \"onWarp\", fillParams<OnWarp>(moveable, e, {\n            delta,\n            matrix: multiply(startMatrix, matrix, 4),\n            multiply,\n            dist: matrix,\n            transform,\n        }));\n        return true;\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<WarpableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isWarp) {\n            return false;\n        }\n        datas.isWarp = false;\n\n        triggerEvent(moveable, \"onWarpEnd\", fillEndParams<OnWarpEnd>(moveable, e, {}));\n        return isDrag;\n    },\n};\n\n/**\n * Whether or not target can be warped. (default: false)\n * @name Moveable.Warpable#warpable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.warpable = true;\n */\n\n /**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Warpable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     warpable: true,\n *     renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n/**\n* When the warp starts, the warpStart event is called.\n* @memberof Moveable.Warpable\n* @event warpStart\n* @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { warpable: true });\n* moveable.on(\"warpStart\", ({ target }) => {\n*     console.log(target);\n* });\n*/\n/**\n * When warping, the warp event is called.\n * @memberof Moveable.Warpable\n * @event warp\n * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event\n * @example\n * import Moveable from \"moveable\";\n * let matrix = [\n *  1, 0, 0, 0,\n *  0, 1, 0, 0,\n *  0, 0, 1, 0,\n *  0, 0, 0, 1,\n * ];\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warp\", ({ target, transform, delta, multiply }) => {\n *    // target.style.transform = transform;\n *    matrix = multiply(matrix, delta);\n *    target.style.transform = `matrix3d(${matrix.join(\",\")})`;\n * });\n */\n/**\n * When the warp finishes, the warpEnd event is called.\n * @memberof Moveable.Warpable\n * @event warpEnd\n * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warpEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n","import { prefix } from \"./utils\";\n\nexport const AREA = prefix(\"area\");\nexport const AREA_PIECES = prefix(\"area-pieces\");\nexport const AREA_PIECE = prefix(\"area-piece\");\nexport const AVOID = prefix(\"avoid\");\n","import {\n    createWarpMatrix,\n} from \"../matrix\";\nimport { ref } from \"framework-utils\";\nimport { triggerEvent, fillParams, getRect, caculateInversePosition, makeMatrixCSS } from \"../utils\";\nimport {\n    Renderer, GroupableProps, DragAreaProps, OnClick,\n    OnClickGroup, MoveableManagerInterface, MoveableGroupInterface\n} from \"../types\";\nimport { AREA_PIECE, AREA, AVOID, AREA_PIECES } from \"../classNames\";\nimport { addClass, findIndex, removeClass } from \"@daybrush/utils\";\n\nfunction restoreStyle(moveable: MoveableManagerInterface) {\n    const el = moveable.areaElement;\n    const { width, height } = moveable.state;\n\n    removeClass(el, AVOID);\n\n    el.style.cssText += `left: 0px; top: 0px; width: ${width}px; height: ${height}px`;\n}\n\nfunction renderPieces(React: Renderer): any {\n    return (<div key=\"area_pieces\" className={AREA_PIECES}>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n    </div>);\n}\nexport default {\n    name: \"dragArea\",\n    props: {\n        dragArea: Boolean,\n    } as const,\n    events: {\n        onClick: \"click\",\n        onClickGroup: \"clickGroup\",\n    } as const,\n    render(moveable: MoveableManagerInterface<GroupableProps>, React: Renderer): any[] {\n        const { target, dragArea, groupable } = moveable.props;\n        const { width, height, renderPoses } = moveable.state;\n\n        if (groupable) {\n            return [\n                <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={AREA}></div>,\n                renderPieces(React),\n            ];\n        }\n        if (!target || !dragArea) {\n            return [];\n        }\n        const h = createWarpMatrix(\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n            renderPoses[0],\n            renderPoses[1],\n            renderPoses[2],\n            renderPoses[3],\n        );\n        const transform = h.length ? makeMatrixCSS(h, true) : \"none\";\n\n        return [\n            <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={AREA} style={{\n                top: \"0px\",\n                left: \"0px\",\n                width: `${width}px`,\n                height: `${height}px`,\n                transformOrigin: \"0 0\",\n                transform,\n            }}></div>,\n            renderPieces(React),\n        ];\n    },\n    dragStart(moveable: MoveableManagerInterface, { datas, clientX, clientY, inputEvent }: any) {\n        if (!inputEvent) {\n            return false;\n        }\n        datas.isDragArea = false;\n        datas.inputTarget = inputEvent.target;\n        const areaElement = moveable.areaElement;\n        const {\n            moveableClientRect,\n            renderPoses,\n            rootMatrix,\n            is3d,\n        } = moveable.state;\n        const { left, top } = moveableClientRect;\n        const {\n            left: relativeLeft,\n            top: relativeTop,\n            width,\n            height,\n        } = getRect(renderPoses);\n        const n = is3d ? 4 : 3;\n        let [posX, posY] = caculateInversePosition(rootMatrix, [clientX - left, clientY - top], n);\n\n        posX -= relativeLeft;\n        posY -= relativeTop;\n        const rects = [\n            { left: relativeLeft, top: relativeTop, width, height: posY - 10 },\n            { left: relativeLeft, top: relativeTop, width: posX - 10, height },\n            { left: relativeLeft, top: relativeTop + posY + 10, width, height: height - posY - 10 },\n            { left: relativeLeft + posX + 10, top: relativeTop, width: width - posX - 10, height },\n        ];\n\n        const children = [].slice.call(areaElement.nextElementSibling!.children) as HTMLElement[];\n        rects.forEach((rect, i) => {\n            children[i].style.cssText\n                = `left: ${rect.left}px;top: ${rect.top}px; width: ${rect.width}px; height: ${rect.height}px;`;\n        });\n        addClass(areaElement, AVOID);\n        return true;\n    },\n    drag(moveable: MoveableManagerInterface, { datas, inputEvent }: any) {\n        if (!inputEvent) {\n            return false;\n        }\n        if (!datas.isDragArea) {\n            datas.isDragArea = true;\n            restoreStyle(moveable);\n        }\n    },\n    dragEnd(moveable: MoveableManagerInterface<DragAreaProps>, e: any) {\n        if (!e.inputEvent) {\n            return false;\n        }\n        const { inputEvent, datas } = e;\n        const isDragArea = datas.isDragArea;\n\n        if (!isDragArea) {\n            restoreStyle(moveable);\n        }\n\n        const target = moveable.state.target!;\n        const inputTarget = inputEvent.target;\n\n        if (isDragArea || moveable.isMoveableElement(inputTarget)) {\n            return;\n        }\n        const containsTarget = target.contains(inputTarget);\n\n        triggerEvent<DragAreaProps>(moveable, \"onClick\", fillParams<OnClick>(moveable, e, {\n            isDouble: e.isDouble,\n            inputTarget,\n            isTarget: target === inputTarget,\n            containsTarget,\n        }));\n    },\n    dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroupInterface<DragAreaProps>,\n        e: any,\n    ) {\n        const { inputEvent, isDragArea, datas } = e;\n        if (!inputEvent) {\n            return false;\n        }\n        if (!isDragArea) {\n            restoreStyle(moveable);\n        }\n        const prevInputTarget = datas.inputTarget;\n        const inputTarget = inputEvent.target;\n\n        if (isDragArea || moveable.isMoveableElement(inputTarget) || prevInputTarget === inputTarget) {\n            return;\n        }\n        const targets = moveable.props.targets!;\n        let targetIndex = targets.indexOf(inputTarget);\n        const isTarget = targetIndex > -1;\n        let containsTarget = false;\n\n        if (targetIndex === -1) {\n            targetIndex = findIndex(targets, parentTarget => parentTarget.contains(inputTarget));\n            containsTarget = targetIndex > -1;\n        }\n\n        triggerEvent<DragAreaProps>(moveable, \"onClickGroup\", fillParams<OnClickGroup>(moveable, e, {\n            isDouble: e.isDouble,\n            targets,\n            inputTarget,\n            targetIndex,\n            isTarget,\n            containsTarget,\n        }));\n    },\n};\n\n/**\n * Add an event to the moveable area instead of the target for stopPropagation. (default: false)\n * @name Moveable#dragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n\n/**\n * When you click on the element, the `click` event is called.\n * @memberof Moveable\n * @event click\n * @param {Moveable.OnClick} - Parameters for the `click` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"click\", ({ hasTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", target, hasTarget, containsTarget, targetIndex);\n * });\n */\n\n/**\n * When you click on the element inside the group, the `clickGroup` event is called.\n * @memberof Moveable\n * @event clickGroup\n * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"clickGroup\", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", inputTarget, isTarget, containsTarget, targetIndex);\n * });\n */\n","import { prefix, getControlTransform } from \"../utils\";\nimport { Renderer, OriginOptions, MoveableManagerInterface } from \"../types\";\n\nexport default {\n    name: \"origin\",\n    props: {\n        origin: Boolean,\n    } as const,\n    events: {} as const,\n    render(moveable: MoveableManagerInterface<OriginOptions>, React: Renderer): any[] {\n        const { beforeOrigin, rotation } = moveable.state;\n\n        return [\n            <div className={prefix(\"control\", \"origin\")}\n                style={getControlTransform(rotation, beforeOrigin)} key=\"beforeOrigin\"></div>,\n        ];\n    },\n};\n\n/**\n * Whether or not the origin controlbox will be visible or not (default: true)\n * @name Moveable#origin\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.origin = true;\n */\n","\nimport { ScrollableProps, OnScroll, MoveableManagerInterface, MoveableGroupInterface } from \"../types\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport DragScroll from \"@scena/dragscroll\";\n\nfunction getDefaultScrollPosition(e: { scrollContainer: HTMLElement, direction: number[] }) {\n    const scrollContainer = e.scrollContainer;\n\n    return [\n        scrollContainer.scrollLeft,\n        scrollContainer.scrollTop,\n    ];\n}\n/**\n * @namespace Moveable.Scrollable\n * @description Whether or not target can be scrolled to the scroll container (default: false)\n */\nexport default {\n    name: \"scrollable\",\n    canPinch: true,\n    props: {\n        scrollable: Boolean,\n        scrollContainer: Object,\n        scrollThreshold: Number,\n        getScrollPosition: Function,\n    } as const,\n    events: {\n        onScroll: \"scroll\",\n        onScrollGroup: \"scrollGroup\",\n    } as const,\n    dragStart(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        const props = moveable.props;\n        const {\n            scrollContainer = moveable.getContainer(),\n        } = props;\n\n        const dragScroll = new DragScroll();\n\n        e.datas.dragScroll = dragScroll;\n\n        const draggerName = e.isControl ? \"controlDragger\" : \"targetDragger\";\n        const targets = e.targets;\n\n        dragScroll.on(\"scroll\", ({ container, direction }) => {\n            const params = fillParams<OnScroll>(moveable, e, {\n                scrollContainer: container,\n                direction,\n            }) as any;\n\n            const eventName = targets ? \"onScrollGroup\" : \"onScroll\" as any;\n            if (targets) {\n                params.targets = targets;\n            }\n            triggerEvent(moveable, eventName, params);\n        }).on(\"move\", ({ offsetX, offsetY }) => {\n            moveable[draggerName].scrollBy(offsetX, offsetY, e.inputEvent, false);\n        });\n        dragScroll.dragStart(e, {\n            container: scrollContainer as HTMLElement,\n        });\n    },\n    checkScroll(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        const {\n            dragScroll,\n        } = e.datas;\n        if (!dragScroll) {\n            return;\n        }\n        const {\n            scrollContainer = moveable.getContainer(),\n            scrollThreshold = 0,\n            getScrollPosition = getDefaultScrollPosition,\n        } = moveable.props;\n\n        dragScroll.drag(e, {\n            container: scrollContainer,\n            threshold: scrollThreshold,\n            getScrollPosition: (ev: any) => {\n                return getScrollPosition({ scrollContainer: ev.container, direction: ev.direction });\n            },\n        });\n\n        return true;\n    },\n    drag(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.checkScroll(moveable, e);\n    },\n    dragEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        e.datas.dragScroll.dragEnd();\n        e.datas.dragScroll = null;\n    },\n    dragControlStart(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.dragStart(moveable, { ...e, isControl: true });\n    },\n    dragControl(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets, isControl: true });\n    },\n    dragGroupContro(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n};\n\n/**\n * Whether or not target can be scrolled to the scroll container (default: false)\n * @name Moveable.Scrollable#scrollable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n * moveable.scrollable = true;\n */\n\n/**\n * The container to which scroll is applied (default: container)\n * @name Moveable.Scrollable#scrollContainer\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n/**\n * Expand the range of the scroll check area. (default: 0)\n * @name Moveable.Scrollable#scrollThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n\n/**\n * Sets a function to get the scroll position. (default: Function)\n * @name Moveable.Scrollable#getScrollPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.\n * @memberof Moveable.Scrollable\n * @event scroll\n * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.\n * @memberof Moveable.Scrollable\n * @event scrollGroup\n * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n","export default {\n    name: \"\",\n    props: {\n        target: Object,\n        dragTarget: Object,\n        container: Object,\n        rootContainer: Object,\n        zoom: Number,\n        transformOrigin: Array,\n        edge: Boolean,\n        ables: Array,\n        className: String,\n        pinchThreshold: Number,\n        pinchOutside: Boolean,\n        triggerAblesSimultaneously: Boolean,\n        checkInput: Boolean,\n        cspNonce: String,\n    } as const,\n    events: {\n        onRenderStart: \"renderStart\",\n        onRender: \"render\",\n        onRenderEnd: \"renderEnd\",\n        onRenderGroupStart: \"renderGroupStart\",\n        onRenderGroup: \"renderGroup\",\n        onRenderGroupEnd: \"renderGroupEnd\",\n    } as const,\n};\n","import { prefix, makeMatrixCSS } from \"../utils\";\nimport { Renderer, MoveableManagerInterface } from \"../types\";\nimport { createWarpMatrix } from \"../matrix\";\n\nexport default {\n    name: \"padding\",\n    props: {\n        padding: Object,\n    } as const,\n    events: {} as const,\n    render(moveable: MoveableManagerInterface, React: Renderer): any[] {\n        const props = moveable.props;\n        if (props.dragArea) {\n            return [];\n        }\n        const padding = props.padding || {};\n        const {\n            left = 0,\n            top = 0,\n            right = 0,\n            bottom = 0,\n        } = padding;\n        const {\n            renderPoses,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        } = moveable.state;\n\n        const poses = [pos1, pos2, pos3, pos4];\n        const paddingDirections: number[][] = [];\n\n        if (left > 0) {\n            paddingDirections.push([0, 2]);\n        }\n        if (top > 0) {\n            paddingDirections.push([0, 1]);\n        }\n        if (right > 0) {\n            paddingDirections.push([1, 3]);\n        }\n        if (bottom > 0) {\n            paddingDirections.push([2, 3]);\n        }\n        return paddingDirections.map(([dir1, dir2], i) => {\n            const paddingPos1 = poses[dir1];\n            const paddingPos2 = poses[dir2];\n            const paddingPos3 = renderPoses[dir1];\n            const paddingPos4 = renderPoses[dir2];\n\n            const h = createWarpMatrix(\n                [0, 0],\n                [100, 0],\n                [0, 100],\n                [100, 100],\n                paddingPos1,\n                paddingPos2,\n                paddingPos3,\n                paddingPos4,\n            );\n            if (!h.length) {\n                return undefined;\n            }\n            return (<div key={`padding${i}`} className={prefix(\"padding\")} style={{\n                transform: makeMatrixCSS(h, true),\n            }}></div>);\n        });\n    },\n};\n\n/**\n * Add padding around the target to increase the drag area. (default: null)\n * @name Moveable#padding\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  target: document.querySelector(\".target\"),\n *  padding: { left: 0, top: 0, right: 0, bottom: 0 },\n * });\n * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },\n * moveable.updateRect();\n */\n","import { getUnitSize, convertCSSSize } from \"../../utils\";\nimport { ControlPose } from \"../../types\";\n\nconst RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"] as const;\n\nfunction caculateRatio(values: number[], size: number) {\n    const sumSize = values[0] + values[1];\n    const sumRatio = sumSize > size ? size / sumSize : 1;\n\n    values[0] *= sumRatio;\n    values[1] = size - values[1] * sumRatio;\n\n    return values;\n}\nexport const HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];\nexport const VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];\nexport const HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1] as const;\nexport const VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1] as const;\n\nexport function getRadiusStyles(\n    poses: number[][], controlPoses: ControlPose[],\n    isRelative: boolean,\n    width: number,\n    height: number,\n    left: number = 0,\n    top: number = 0,\n    right: number = width,\n    bottom: number = height,\n) {\n    const clipStyles: string[] = [];\n    let isVertical = false;\n\n    const raws = poses.map((pos, i) => {\n        const { horizontal, vertical } = controlPoses[i];\n        if (vertical && !isVertical) {\n            isVertical = true;\n            clipStyles.push(\"/\");\n        }\n\n        if (isVertical) {\n            const rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);\n            clipStyles.push(convertCSSSize(rawPos, height, isRelative));\n\n            return rawPos;\n        } else {\n            const rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);\n            clipStyles.push(convertCSSSize(rawPos, width, isRelative));\n\n            return rawPos;\n        }\n    });\n\n    return {\n        styles: clipStyles,\n        raws,\n    };\n}\nexport function getRadiusRange(controlPoses: ControlPose[]) {\n    // [start, length]\n    const horizontalRange = [0, 0];\n    const verticalRange = [0, 0];\n    const length =  controlPoses.length;\n\n    for (let i = 0; i < length; ++i) {\n        const clipPose = controlPoses[i];\n\n        if (!clipPose.sub) {\n            continue;\n        }\n        if (clipPose.horizontal) {\n            if (horizontalRange[1] === 0) {\n                horizontalRange[0] = i;\n            }\n            horizontalRange[1] = i - horizontalRange[0] + 1;\n            verticalRange[0] = i + 1;\n        }\n        if (clipPose.vertical) {\n            if (verticalRange[1] === 0) {\n                verticalRange[0] = i;\n            }\n            verticalRange[1] = i - verticalRange[0] + 1;\n        }\n    }\n\n    return {\n        horizontalRange,\n        verticalRange,\n    };\n}\nexport function getRadiusValues(\n    values: string[],\n    width: number,\n    height: number,\n    left: number,\n    top: number,\n): ControlPose[] {\n    const splitIndex = values.indexOf(\"/\");\n    const splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;\n    const horizontalValues = values.slice(0, splitLength);\n    const verticalValues = values.slice(splitLength + 1);\n    const [\n        nwValue = \"0\",\n        neValue = nwValue,\n        seValue = nwValue,\n        swValue = neValue,\n    ] = horizontalValues;\n    const [\n        wnValue = nwValue,\n        enValue = wnValue,\n        esValue = wnValue,\n        wsValue = enValue,\n    ] = verticalValues;\n\n    const horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(pos => getUnitSize(pos, width));\n    const verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(pos => getUnitSize(pos, height));\n    const horizontalPoses = horizontalRawPoses.slice();\n    const verticalPoses = verticalRawPoses.slice();\n\n    [horizontalPoses[0], horizontalPoses[1]] = caculateRatio([horizontalPoses[0], horizontalPoses[1]], width);\n    [horizontalPoses[3], horizontalPoses[2]] = caculateRatio([horizontalPoses[3], horizontalPoses[2]], width);\n    [verticalPoses[0], verticalPoses[3]] = caculateRatio([verticalPoses[0], verticalPoses[3]], height);\n    [verticalPoses[1], verticalPoses[2]] = caculateRatio([verticalPoses[1], verticalPoses[2]], height);\n\n    const nextHorizontalPoses = horizontalPoses.slice(0, horizontalValues.length);\n    const nextVerticalPoses = verticalPoses.slice(0, verticalValues.length);\n    return [\n        ...nextHorizontalPoses.map((pos, i) => {\n            const direction = RADIUS_DIRECTIONS[i];\n\n            return {\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n                vertical: 0,\n                pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)],\n                sub: true,\n                raw: horizontalRawPoses[i],\n                direction,\n            };\n        }),\n        ...nextVerticalPoses.map((pos, i) => {\n            const direction = RADIUS_DIRECTIONS[i];\n\n            return {\n                horizontal: 0,\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n                pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0), top + pos],\n                sub: true,\n                raw: verticalRawPoses[i],\n                direction,\n            };\n        }),\n    ];\n}\nexport function removeRadiusPos(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    index: number,\n    startIndex: number,\n    length: number = poses.length,\n) {\n    const {\n        horizontalRange,\n        verticalRange,\n    } = getRadiusRange(controlPoses.slice(startIndex));\n    const radiuslIndex = index - startIndex;\n    let deleteCount = 0;\n\n    if (radiuslIndex === 0) {\n        deleteCount = length;\n    } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {\n        deleteCount = horizontalRange[1] - radiuslIndex;\n    } else if (radiuslIndex >= verticalRange[0]) {\n        deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;\n    } else {\n        return;\n    }\n    controlPoses.splice(index, deleteCount);\n    poses.splice(index, deleteCount);\n}\nexport function addRadiusPos(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    startIndex: number,\n    horizontalIndex: number,\n    verticalIndex: number,\n    distX: number,\n    distY: number,\n    right: number,\n    bottom: number,\n    left: number = 0,\n    top: number = 0,\n) {\n    const {\n        horizontalRange,\n        verticalRange,\n    } = getRadiusRange(controlPoses.slice(startIndex));\n    if (horizontalIndex > -1) {\n        const radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1\n            ? distX - left\n            : right - distX;\n        for (let i = horizontalRange[1]; i <= horizontalIndex; ++i) {\n            const y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;\n            let x = 0;\n            if (horizontalIndex === i) {\n                x = distX;\n            } else if (i === 0) {\n                x = left + radiusX;\n            } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {\n                x = right - (poses[startIndex][0] - left);\n            }\n            controlPoses.splice(startIndex + i, 0, {\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n                vertical: 0,\n                pos: [x, y],\n            });\n            poses.splice(startIndex + i, 0, [x, y]);\n\n            if (i === 0) {\n                break;\n            }\n        }\n    } else if (verticalIndex > - 1) {\n        const radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1\n            ? distY - top\n            : bottom - distY;\n        if (horizontalRange[1] === 0 && verticalRange[1] === 0) {\n            const pos = [\n                left + radiusY,\n                top,\n            ];\n            controlPoses.push({\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n                vertical: 0,\n                pos,\n            });\n            poses.push(pos);\n        }\n\n        const startVerticalIndex = verticalRange[0];\n        for (let i = verticalRange[1]; i <= verticalIndex; ++i) {\n            const x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;\n            let y = 0;\n            if (verticalIndex === i) {\n                y = distY;\n            } else if (i === 0) {\n                y = top + radiusY;\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {\n                y = poses[startIndex + startVerticalIndex][1];\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {\n                y = bottom - (poses[startIndex + startVerticalIndex][1] - top);\n            }\n            controlPoses.push({\n                horizontal: 0,\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n                pos: [x, y],\n            });\n            poses.push([x, y]);\n            if (i === 0) {\n                break;\n            }\n        }\n    }\n}\nexport function splitRadiusPoses(\n    controlPoses: ControlPose[],\n    raws: number[] = controlPoses.map(pos => pos.raw!),\n) {\n    const horizontals = controlPoses\n    .map((pos , i) => pos.horizontal ? raws[i] : null).filter(pos => pos != null) as number[];\n    const verticals = controlPoses\n        .map((pos , i) => pos.vertical ? raws[i] : null).filter(pos => pos != null) as number[];\n\n    return {\n        horizontals,\n        verticals,\n    };\n}\n","import {\n    Renderer, ClippableProps, OnClip,\n    ClippableState, OnClipEnd, OnClipStart,\n    ControlPose, MoveableManagerInterface\n} from \"../types\";\nimport { splitBracket, splitComma, splitUnit, splitSpace } from \"@daybrush/utils\";\nimport {\n    prefix, caculatePosition, getDiagonalSize,\n    fillParams, triggerEvent,\n    makeMatrixCSS, getRect, fillEndParams, getUnitSize, convertCSSSize, moveControlPos, caculatePointerDist\n} from \"../utils\";\nimport { getRad, plus, minus } from \"../matrix\";\nimport { setDragStart, getDragDist } from \"../DraggerUtils\";\nimport {\n    getRadiusValues,\n    HORIZONTAL_RADIUS_ORDER, VERTICAL_RADIUS_ORDER, getRadiusStyles, addRadiusPos, removeRadiusPos\n} from \"./roundable/borderRadius\";\n\nconst CLIP_DIRECTIONS = [\n    [0, -1, \"n\"],\n    [1, 0, \"e\"],\n] as const;\nconst CLIP_RECT_DIRECTIONS = [\n    [-1, -1, \"nw\"],\n    [0, -1, \"n\"],\n    [1, -1, \"ne\"],\n    [1, 0, \"e\"],\n    [1, 1, \"se\"],\n    [0, 1, \"s\"],\n    [-1, 1, \"sw\"],\n    [-1, 0, \"w\"],\n] as const;\n\n// 1 2 5 6 0 3 4 7\n// 0 1 2 3 4 5 6 7\n\nfunction getClipStyles(\n    moveable: MoveableManagerInterface<ClippableProps>,\n    clipPath: ReturnType<typeof getClipPath>,\n    poses: number[][],\n) {\n    const {\n        clipRelative,\n    } = moveable.props;\n    const {\n        width,\n        height,\n    } = moveable.state;\n    const {\n        type: clipType,\n        poses: clipPoses,\n    } = clipPath!;\n\n    const isRect = clipType === \"rect\";\n    const isCircle = clipType === \"circle\";\n    if (clipType === \"polygon\") {\n        return poses.map(pos => `${\n            convertCSSSize(pos[0], width, clipRelative)\n            } ${\n            convertCSSSize(pos[1], height, clipRelative)\n            }`);\n    } else if (isRect || clipType === \"inset\") {\n        const top = poses[1][1];\n        const right = poses[3][0];\n        const left = poses[7][0];\n        const bottom = poses[5][1];\n\n        if (isRect) {\n            return [\n                top,\n                right,\n                bottom,\n                left,\n            ].map(pos => `${pos}px`);\n        }\n        const clipStyles\n            = [top, width - right, height - bottom, left]\n                .map((pos, i) => convertCSSSize(pos, i % 2 ? width : height, clipRelative));\n\n        if (poses.length > 8) {\n            const [subWidth, subHeight] = minus(poses[4], poses[0]);\n\n            clipStyles.push(\"round\", ...getRadiusStyles(\n                poses.slice(8),\n                clipPoses.slice(8),\n                clipRelative!,\n                subWidth,\n                subHeight,\n                left, top, right, bottom,\n            ).styles);\n        }\n        return clipStyles;\n    } else if (isCircle || clipType === \"ellipse\") {\n        const center = poses[0];\n        const ry = convertCSSSize(\n            Math.abs(poses[1][1] - center[1]),\n            isCircle ? Math.sqrt((width * width + height * height) / 2) : height,\n            clipRelative,\n        );\n\n        const clipStyles = isCircle ? [ry]\n            : [convertCSSSize(Math.abs(poses[2][0] - center[0]), width, clipRelative), ry];\n\n        clipStyles.push(\n            \"at\", convertCSSSize(center[0], width, clipRelative),\n            convertCSSSize(center[1], height, clipRelative));\n\n        return clipStyles;\n    }\n}\nfunction getRectPoses(top: number, right: number, bottom: number, left: number): ControlPose[] {\n    const xs = [left, (left + right) / 2, right];\n    const ys = [top, (top + bottom) / 2, bottom];\n\n    return CLIP_RECT_DIRECTIONS.map(([dirx, diry, dir]) => {\n        const x = xs[dirx + 1];\n        const y = ys[diry + 1];\n        return {\n            vertical: Math.abs(diry),\n            horizontal: Math.abs(dirx),\n            direction: dir,\n            pos: [x, y],\n        };\n    });\n}\nfunction getClipPath(\n    target: HTMLElement | SVGElement,\n    width: number,\n    height: number,\n    defaultClip?: string,\n    customClip?: string,\n) {\n    let clipText: string | undefined = customClip;\n\n    if (!clipText) {\n        const style = getComputedStyle(target!);\n        const clipPath = style.clipPath!;\n\n        clipText = clipPath !== \"none\" ? clipPath : style.clip!;\n    }\n    if (!clipText || clipText === \"none\" || clipText === \"auto\") {\n        clipText = defaultClip;\n\n        if (!clipText) {\n            return;\n        }\n    }\n    const {\n        prefix: clipPrefix = clipText,\n        value = \"\",\n    } = splitBracket(clipText);\n    const isCircle = clipPrefix === \"circle\";\n    let splitter = \" \";\n\n    if (clipPrefix === \"polygon\") {\n        const values = splitComma(value! || `0% 0%, 100% 0%, 100% 100%, 0% 100%`);\n        splitter = \",\";\n\n        const poses: ControlPose[] = values.map(pos => {\n            const [xPos, yPos] = pos.split(\" \");\n\n            return {\n                vertical: 1,\n                horizontal: 1,\n                pos: [\n                    getUnitSize(xPos, width),\n                    getUnitSize(yPos, height),\n                ],\n            };\n        });\n\n        return {\n            type: clipPrefix,\n            clipText,\n            poses,\n            splitter,\n        } as const;\n    } else if (isCircle || clipPrefix === \"ellipse\") {\n        let xPos: string = \"\";\n        let yPos: string = \"\";\n        let radiusX = 0;\n        let radiusY = 0;\n        const values = splitSpace(value!);\n\n        if (isCircle) {\n            let radius = \"\";\n            [radius = \"50%\", , xPos = \"50%\", yPos = \"50%\"] = values;\n\n            radiusX = getUnitSize(radius, Math.sqrt((width * width + height * height) / 2));\n            radiusY = radiusX;\n        } else {\n            let xRadius = \"\";\n            let yRadius = \"\";\n            [xRadius = \"50%\", yRadius = \"50%\", , xPos = \"50%\", yPos = \"50%\"] = values;\n\n            radiusX = getUnitSize(xRadius, width);\n            radiusY = getUnitSize(yRadius, height);\n        }\n        const centerPos = [\n            getUnitSize(xPos, width),\n            getUnitSize(yPos, height),\n        ];\n        const poses: ControlPose[] = [\n            {\n                vertical: 1,\n                horizontal: 1,\n                pos: centerPos,\n                direction: \"nesw\",\n            },\n            ...CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(dir => ({\n                vertical: Math.abs(dir[1]),\n                horizontal: dir[0],\n                direction: dir[2],\n                sub: true,\n                pos: [\n                    centerPos[0] + dir[0] * radiusX,\n                    centerPos[1] + dir[1] * radiusY,\n                ],\n            })),\n        ];\n        return {\n            type: clipPrefix as \"circle\" | \"ellipse\",\n            clipText,\n            radiusX,\n            radiusY,\n            left: centerPos[0] - radiusX,\n            top: centerPos[1] - radiusY,\n            poses,\n            splitter,\n        } as const;\n    } else if (clipPrefix === \"inset\") {\n        const values = splitSpace(value! || \"0 0 0 0\");\n        const roundIndex = values.indexOf(\"round\");\n\n        const rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;\n        const radiusValues = values.slice(rectLength + 1);\n        const [\n            topValue,\n            rightValue = topValue,\n            bottomValue = topValue,\n            leftValue = rightValue,\n        ] = values.slice(0, rectLength);\n        const [top, bottom] = [topValue, bottomValue].map(pos => getUnitSize(pos, height));\n        const [left, right] = [leftValue, rightValue].map(pos => getUnitSize(pos, width));\n        const nextRight = width - right;\n        const nextBottom = height - bottom;\n        const radiusPoses = getRadiusValues(\n            radiusValues,\n            nextRight - left,\n            nextBottom - top,\n            left,\n            top,\n        );\n        const poses: ControlPose[] = [\n            ...getRectPoses(top, nextRight, nextBottom, left),\n            ...radiusPoses,\n        ];\n\n        return {\n            type: \"inset\",\n            clipText,\n            poses,\n            top,\n            left,\n            right: nextRight,\n            bottom: nextBottom,\n            radius: radiusValues,\n            splitter,\n        } as const;\n    } else if (clipPrefix === \"rect\") {\n        // top right bottom left\n        const values = splitComma(value! || `0px, ${width}px, ${height}px, 0px`);\n\n        splitter = \",\";\n        const [top, right, bottom, left] = values.map((pos, i) => {\n            const { value: posValue } = splitUnit(pos);\n\n            return posValue;\n        });\n        const poses = getRectPoses(top, right, bottom, left);\n\n        return {\n            type: \"rect\",\n            clipText,\n            poses,\n            top,\n            right,\n            bottom,\n            left,\n            values,\n            splitter,\n        } as const;\n    }\n    return;\n}\nfunction addClipPath(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n    const [distX, distY] = caculatePointerDist(moveable, e);\n    const { clipPath, index } = e.datas;\n    const {\n        type: clipType,\n        poses: clipPoses,\n        splitter,\n    } = (clipPath as ReturnType<typeof getClipPath>)!;\n    const poses = clipPoses.map(pos => pos.pos);\n    if (clipType === \"polygon\") {\n        poses.splice(index, 0, [distX, distY]);\n    } else if (clipType === \"inset\") {\n        const horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(index);\n        const verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(index);\n        const length = clipPoses.length;\n\n        addRadiusPos(\n            clipPoses,\n            poses,\n            8,\n            horizontalIndex,\n            verticalIndex,\n            distX,\n            distY,\n            poses[4][0],\n            poses[4][1],\n            poses[0][0],\n            poses[0][1],\n        );\n\n        if (length === clipPoses.length) {\n            return;\n        }\n    } else {\n        return;\n    }\n    const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n    triggerEvent<OnClip>(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n        clipEventType: \"added\",\n        clipType,\n        poses,\n        clipStyles,\n        clipStyle: `${clipType}(${clipStyles.join(splitter)})`,\n        distX: 0,\n        distY: 0,\n    }));\n}\nfunction removeClipPath(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n    const { clipPath, index } = e.datas;\n    const {\n        type: clipType,\n        poses: clipPoses,\n        splitter,\n    } = (clipPath as ReturnType<typeof getClipPath>)!;\n    const poses = clipPoses.map(pos => pos.pos);\n    const length = poses.length;\n    if (clipType === \"polygon\") {\n        clipPoses.splice(index, 1);\n        poses.splice(index, 1);\n    } else if (clipType === \"inset\") {\n        if (index < 8) {\n            return;\n        }\n        removeRadiusPos(clipPoses, poses, index, 8, length);\n\n        if (length === clipPoses.length) {\n            return;\n        }\n    } else {\n        return;\n    }\n    const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n    triggerEvent<OnClip>(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n        clipEventType: \"removed\",\n        clipType,\n        poses,\n        clipStyles,\n        clipStyle: `${clipType}(${clipStyles.join(splitter)})`,\n        distX: 0,\n        distY: 0,\n    }));\n}\n/**\n * @namespace Moveable.Clippable\n * @description Whether to clip the target.\n */\n\nexport default {\n    name: \"clippable\",\n    props: {\n        clippable: Boolean,\n        defaultClipPath: String,\n        customClipPath: String,\n        clipRelative: Boolean,\n        clipArea: Boolean,\n        dragWithClip: Boolean,\n    } as const,\n    events: {\n        onClipStart: \"clipStart\",\n        onClip: \"clip\",\n        onClipEnd: \"clipEnd\",\n    } as const,\n    css: [\n        `.control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, React: Renderer): any[] {\n        const {\n            customClipPath, defaultClipPath,\n            clipArea, zoom,\n        } = moveable.props;\n        const {\n            target, width, height, matrix, is3d, left, top,\n            pos1, pos2, pos3, pos4,\n            clipPathState,\n        } = moveable.state;\n\n        if (!target) {\n            return [];\n        }\n\n        const clipPath = getClipPath(\n            target, width, height, defaultClipPath || \"inset\", clipPathState || customClipPath);\n\n        if (!clipPath) {\n            return [];\n        }\n        const n = is3d ? 4 : 3;\n        const type = clipPath.type;\n        const clipPoses = clipPath.poses;\n        const poses = clipPoses.map(pos => {\n            // return [x, y];\n            const caculatedPos = caculatePosition(matrix, pos.pos, n);\n\n            return [\n                caculatedPos[0] - left,\n                caculatedPos[1] - top,\n            ];\n        });\n\n        let controls: any[] = [];\n        let lines: any[] = [];\n\n        const isRect = type === \"rect\";\n        const isInset = type === \"inset\";\n        const isPolygon = type === \"polygon\";\n\n        if (isRect || isInset || isPolygon) {\n            const linePoses = isInset ? poses.slice(0, 8) : poses;\n\n            lines = linePoses.map((to, i) => {\n                const from = i === 0 ? linePoses[linePoses.length - 1] : linePoses[i - 1];\n\n                const rad = getRad(from, to);\n                const dist = getDiagonalSize(from, to);\n                return <div key={`clipLine${i}`} className={prefix(\"line\", \"clip-line\")}\n                    data-clip-index={i}\n                    style={{\n                        width: `${dist}px`,\n                        transform: `translate(${from[0]}px, ${from[1]}px) rotate(${rad}rad)`,\n                    }}></div>;\n            });\n        }\n        controls = poses.map((pos, i) => {\n            return <div key={`clipControl${i}`}\n                className={prefix(\"control\", \"clip-control\")}\n                data-clip-index={i}\n                style={{\n                    transform: `translate(${pos[0]}px, ${pos[1]}px)`,\n                }}></div>;\n        });\n\n        if (isInset) {\n            controls.push(...poses.slice(8).map((pos, i) => {\n                return <div key={`clipRadiusControl${i}`}\n                    className={prefix(\"control\", \"clip-control\", \"clip-radius\")}\n                    data-clip-index={8 + i}\n                    style={{\n                        transform: `translate(${pos[0]}px, ${pos[1]}px)`,\n                    }}></div>;\n            }));\n        }\n        if (type === \"circle\" || type === \"ellipse\") {\n            const {\n                left: clipLeft,\n                top: clipTop,\n                radiusX,\n                radiusY,\n            } = clipPath;\n\n            const [distLeft, distTop] = minus(\n                caculatePosition(matrix, [clipLeft!, clipTop!], n),\n                caculatePosition(matrix, [0, 0], n),\n            );\n            let ellipseClipPath = \"none\";\n\n            if (!clipArea) {\n                const piece = Math.max(10, radiusX! / 5, radiusY! / 5);\n                const areaPoses: number[][] = [];\n\n                for (let i = 0; i <= piece; ++i) {\n                    const rad = Math.PI * 2 / piece * i;\n                    areaPoses.push([\n                        radiusX! + (radiusX! - zoom!) * Math.cos(rad),\n                        radiusY! + (radiusY! - zoom!) * Math.sin(rad),\n                    ]);\n                }\n                areaPoses.push([radiusX!, -2]);\n                areaPoses.push([-2, -2]);\n                areaPoses.push([-2, radiusY! * 2 + 2]);\n                areaPoses.push([radiusX! * 2 + 2, radiusY! * 2 + 2]);\n                areaPoses.push([radiusX! * 2 + 2, -2]);\n                areaPoses.push([radiusX!, -2]);\n\n                ellipseClipPath = `polygon(${areaPoses.map(pos => `${pos[0]}px ${pos[1]}px`).join(\", \")})`;\n            }\n            controls.push(<div key=\"clipEllipse\" className={prefix(\"clip-ellipse\")} style={{\n                width: `${radiusX! * 2}px`,\n                height: `${radiusY! * 2}px`,\n                clipPath: ellipseClipPath,\n                transform: `translate(${-left + distLeft}px, ${-top + distTop}px) ${makeMatrixCSS(matrix)}`,\n            }}></div>);\n        }\n        if (clipArea) {\n            const {\n                width: allWidth,\n                height: allHeight,\n                left: allLeft,\n                top: allTop,\n            } = getRect([pos1, pos2, pos3, pos4, ...poses]);\n            if (isPolygon || isRect || isInset) {\n                const areaPoses = isInset ? poses.slice(0, 8) : poses;\n                controls.push(<div key=\"clipArea\" className={prefix(\"clip-area\")} style={{\n                    width: `${allWidth}px`,\n                    height: `${allHeight}px`,\n                    transform: `translate(${allLeft}px, ${allTop}px)`,\n                    clipPath: `polygon(${\n                        areaPoses.map(pos => `${pos[0] - allLeft}px ${pos[1] - allTop}px`).join(\", \")\n                        })`,\n                }}></div>);\n            }\n        }\n        return [\n            ...controls,\n            ...lines,\n        ];\n    },\n    dragControlCondition(e: any) {\n        return e.inputEvent && (e.inputEvent.target.className || \"\").indexOf(\"clip\") > -1;\n    },\n    dragStart(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n        const props = moveable.props;\n        const {\n            dragWithClip = true,\n        } = props;\n\n        if (dragWithClip) {\n            return false;\n        }\n\n        return this.dragControlStart(moveable, e);\n    },\n    drag(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n        return this.dragControl(moveable, e);\n    },\n    dragEnd(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n        return this.dragControlEnd(moveable, e);\n    },\n    dragControlStart(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        const state = moveable.state;\n        const { defaultClipPath, customClipPath } = moveable.props;\n        const { target, width, height } = state;\n        const inputTarget = e.inputEvent ? e.inputEvent.target : null;\n        const className = inputTarget ? inputTarget.className : \"\";\n        const datas = e.datas;\n        const clipPath = getClipPath(target!, width, height, defaultClipPath || \"inset\", customClipPath);\n\n        if (!clipPath) {\n            return false;\n        }\n        const { clipText, type, poses } = clipPath;\n        const result = triggerEvent<ClippableProps>(moveable, \"onClipStart\", fillParams<OnClipStart>(moveable, e, {\n            clipType: type,\n            clipStyle: clipText,\n            poses: poses.map(pos => pos.pos),\n        }));\n\n        if (result === false) {\n            datas.isClipStart = false;\n            return false;\n        }\n        datas.isControl = className.indexOf(\"clip-control\") > -1;\n        datas.isLine = className.indexOf(\"clip-line\") > -1;\n        datas.isArea = className.indexOf(\"clip-area\") > -1 || className.indexOf(\"clip-ellipse\") > -1;\n        datas.index = inputTarget ? parseInt(inputTarget.getAttribute(\"data-clip-index\"), 10) : -1;\n        datas.clipPath = clipPath;\n        datas.isClipStart = true;\n        state.clipPathState = clipText;\n        setDragStart(moveable, e);\n\n        return true;\n    },\n    dragControl(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        const { datas, originalDatas } = e;\n\n        if (!datas.isClipStart) {\n            return false;\n        }\n        const draggableData = (originalDatas && originalDatas.draggable) || {};\n        const { isControl, isLine, isArea, index, clipPath } = datas as {\n            clipPath: ReturnType<typeof getClipPath>,\n            [key: string]: any,\n        };\n        if (!clipPath) {\n            return false;\n        }\n        let [distX, distY] = draggableData.isDrag ? draggableData.prevDist : getDragDist(e);\n        const state = moveable.state;\n        const isDragWithTarget = !isArea && !isControl && !isLine;\n        const {\n            type: clipType,\n            poses: clipPoses,\n            splitter,\n        } = clipPath;\n        const poses = clipPoses.map(pos => pos.pos);\n        const nextPoses: number[][] = poses.map(pos => pos.slice());\n\n        if (isDragWithTarget) {\n            distX = -distX;\n            distY = -distY;\n        }\n        const isAll = !isControl || clipPoses[index].direction === \"nesw\";\n\n        if (isControl && !isAll) {\n            moveControlPos(clipPoses, nextPoses, index, distX, distY);\n        }\n        if (isAll) {\n            poses.forEach((pos, i) => {\n                nextPoses[i] = plus(pos, [distX, distY]);\n            });\n        }\n        // const indexes: number[] = [];\n        // const clipStyles = getClipStyles(clipPath, width, height, clipPoses.map(pos => pos.pos))!;\n        const nextClipStyles = getClipStyles(moveable, clipPath, nextPoses)!;\n        const clipStyle = `${clipType}(${nextClipStyles.join(splitter)})`;\n\n        state.clipPathState = clipStyle;\n        triggerEvent<OnClip>(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n            clipEventType: \"changed\",\n            clipType,\n            poses: nextPoses,\n            clipStyle,\n            clipStyles: nextClipStyles,\n            distX,\n            distY,\n        }));\n\n        return true;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        moveable.state.clipPathState = \"\";\n        const { isDrag, datas, isDouble } = e;\n        const { isLine, isClipStart, isControl } = datas;\n\n        if (!isClipStart) {\n            return false;\n        }\n        triggerEvent<ClippableProps>(moveable, \"onClipEnd\", fillEndParams<OnClipEnd>(moveable, e, {}));\n        if (isDouble) {\n            if (isControl) {\n                removeClipPath(moveable, e);\n            } else if (isLine) {\n                // add\n                addClipPath(moveable, e);\n            }\n        }\n        return isDouble || isDrag;\n    },\n    unset(moveable: MoveableManagerInterface<ClippableProps, ClippableState>) {\n        moveable.state.clipPathState = \"\";\n    },\n};\n\n/**\n * Whether to clip the target. (default: false)\n * @name Moveable.Clippable#clippable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#defaultClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (`rect` not possible) (default: false)\n * @name Moveable.Clippable#clipRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#customClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When dragging the target, the clip also moves. (default: true)\n * @name Moveable.Clippable#dragWithClip\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can drag the clip by setting clipArea. (default: false)\n * @name Moveable.Clippable#clipArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag start the clip area or controls, the `clipStart` event is called.\n * @memberof Moveable.Clippable\n * @event clipStart\n * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag the clip area or controls, the `clip` event is called.\n * @memberof Moveable.Clippable\n * @event clip\n * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag end the clip area or controls, the `clipEnd` event is called.\n * @memberof Moveable.Clippable\n * @event clipEnd\n * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n","import {\n    prefix, triggerEvent,\n    fillParams, caculatePoses, getRect, fillEndParams, convertCSSSize\n} from \"../utils\";\nimport {\n    OnDragOriginStart, OnDragOrigin,\n    OnDragOriginEnd, MoveableManagerInterface, DraggableProps, OriginDraggableProps, MoveableGroupInterface\n} from \"../types\";\nimport { hasClass, IObject } from \"@daybrush/utils\";\nimport { setDragStart, getDragDist, getNextMatrix } from \"../DraggerUtils\";\nimport { minus, plus } from \"../matrix\";\nimport Draggable from \"./Draggable\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\n\n/**\n * @namespace OriginDraggable\n * @memberof Moveable\n * @description Whether to drag origin (default: false)\n */\nexport default {\n    name: \"originDraggable\",\n    props: {\n        originDraggable: Boolean,\n        originRelative: Boolean,\n    } as const,\n    events: {\n        onDragOriginStart: \"dragOriginStart\",\n        onDragOrigin: \"dragOrigin\",\n        onDragOriginEnd: \"dragOriginEnd\",\n    } as const,\n    css: [\n        `:host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}`,\n    ],\n    dragControlCondition(e: any) {\n        if (e.isRequest) {\n            return e.requestAble === \"originDraggable\";\n        }\n        return hasClass(e.inputEvent.target, prefix(\"origin\"));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>, e: any) {\n        const { inputEvent, datas } = e;\n\n        setDragStart(moveable, e);\n\n        const params = fillParams<OnDragOriginStart>(moveable, e, {\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ),\n        });\n        const result = triggerEvent<OriginDraggableProps>(\n            moveable, \"onDragOriginStart\", params);\n\n        datas.startOrigin = moveable.state.transformOrigin;\n        datas.startTargetOrigin = moveable.state.targetOrigin;\n        datas.prevOrigin = [0, 0];\n        datas.isDragOrigin = true;\n\n        if (result === false) {\n            datas.isDragOrigin = false;\n            return false;\n        }\n\n        return params;\n    },\n    dragControl(moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>, e: any) {\n        const { datas, inputEvent, isPinch, isRequest } = e;\n\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        const [distX, distY] = getDragDist(e);\n        const state = moveable.state;\n        const {\n            width,\n            height,\n            offsetMatrix,\n            targetMatrix,\n            is3d,\n        } = state;\n        const {\n            originRelative = true,\n        } = moveable.props;\n        const n = is3d ? 4 : 3;\n        let dist = [distX, distY];\n\n        if (isRequest) {\n            const distOrigin = e.distOrigin;\n            if (distOrigin[0] || distOrigin[1]) {\n                dist = distOrigin;\n            }\n        }\n        const origin = plus(datas.startOrigin, dist);\n        const targetOrigin = plus(datas.startTargetOrigin, dist);\n        const delta = minus(dist, datas.prevOrigin);\n\n        const nextMatrix = getNextMatrix(\n            offsetMatrix,\n            targetMatrix,\n            origin,\n            n,\n        );\n\n        const rect = moveable.getRect();\n        const nextRect = getRect(caculatePoses(nextMatrix, width, height, n));\n\n        const dragDelta = [\n            rect.left - nextRect.left,\n            rect.top - nextRect.top,\n        ];\n\n        datas.prevOrigin = dist;\n        const transformOrigin = [\n            convertCSSSize(targetOrigin[0], width, originRelative),\n            convertCSSSize(targetOrigin[1], height, originRelative),\n        ].join(\" \");\n        const params = fillParams<OnDragOrigin>(moveable, e, {\n            width,\n            height,\n            origin,\n            dist,\n            delta,\n            transformOrigin,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, dragDelta, inputEvent, !!isPinch, false),\n            )!,\n        });\n        triggerEvent<OriginDraggableProps>(moveable, \"onDragOrigin\", params);\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<OriginDraggableProps>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        triggerEvent<OriginDraggableProps>(moveable, \"onDragOriginEnd\",\n            fillEndParams<OnDragOriginEnd>(moveable, e, {}));\n        return true;\n    },\n    dragGroupControlCondition(e: any) {\n        return this.dragControlCondition(e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<OriginDraggableProps>, e: any) {\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        return true;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<OriginDraggableProps>, e: any) {\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        moveable.transformOrigin = params.transformOrigin;\n\n        return true;\n    },\n    /**\n    * @method Moveable.OriginDraggable#request\n    * @param {object} e - the OriginDraggable's request parameter\n    * @param {number} [e.x] - x position\n    * @param {number} [e.y] - y position\n    * @param {number} [e.deltaX] - x number to move\n    * @param {number} [e.deltaY] - y number to move\n    * @param {array} [e.deltaOrigin] - left, top number to move transform-origin\n    * @param {array} [e.origin] - transform-origin position\n    * @param {number} [e.isInstant] - Whether to execute the request instantly\n    * @return {Moveable.Requester} Moveable Requester\n    * @example\n\n    * // Instantly Request (requestStart - request - requestEnd)\n    * // Use Relative Value\n    * moveable.request(\"originDraggable\", { deltaX: 10, deltaY: 10 }, true);\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 }, true);\n    * // Use Transform Value\n    * moveable.request(\"originDraggable\", { deltaOrigin: [10, 0] }, true);\n    * moveable.request(\"originDraggable\", { origin: [100, 0] }, true);\n    * // requestStart\n    * const requester = moveable.request(\"originDraggable\");\n    *\n    * // request\n    * // Use Relative Value\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 220, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 240, y: 100 });\n    *\n    * // requestEnd\n    * requester.requestEnd();\n    */\n    request(moveable: MoveableManagerInterface<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n\n        const transformOrigin = rect.transformOrigin;\n        const distOrigin = [0, 0];\n\n        return {\n            isControl: true,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"deltaOrigin\" in e) {\n                    distOrigin[0] += e.deltaOrigin[0];\n                    distOrigin[1] += e.deltaOrigin[1];\n                } else if (\"origin\" in e) {\n                    distOrigin[0] = e.origin[0] - transformOrigin[0];\n                    distOrigin[1] = e.origin[1] - transformOrigin[1];\n                } else {\n                    if (\"x\" in e) {\n                        distX = e.x - rect.left;\n                    } else if (\"deltaX\" in e) {\n                        distX += e.deltaX;\n                    }\n                    if (\"y\" in e) {\n                        distY = e.y - rect.top;\n                    } else if (\"deltaY\" in e) {\n                        distY += e.deltaY;\n                    }\n                }\n\n                return { datas, distX, distY, distOrigin };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n/**\n * Whether to drag origin (default: false)\n * @name Moveable.OriginDraggable#originDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n * });\n * let translate = [0, 0];\n * moveable.on(\"dragOriginStart\", e => {\n *     e.dragStart && e.dragStart.set(translate);\n * }).on(\"dragOrigin\", e => {\n *     translate = e.drag.beforeTranslate;\n *     e.target.style.cssText\n *         = `transform-origin: ${e.transformOrigin};`\n *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n * }).on(\"dragOriginEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (default: true)\n * @name Moveable.OriginDraggable#originRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n *     originRelative: false,\n * });\n * moveable.originRelative = true;\n */\n\n/**\n* When drag start the origin, the `dragOriginStart` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginStart\n* @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag the origin, the `dragOrigin` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOrigin\n* @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag end the origin, the `dragOriginEnd` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginEnd\n* @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n","import {\n    prefix, triggerEvent,\n    fillParams, fillEndParams, caculatePosition, moveControlPos, caculatePointerDist\n} from \"../utils\";\nimport {\n    Renderer, RoundableProps, OnRoundStart, RoundableState, OnRound, ControlPose, OnRoundEnd, MoveableManagerInterface,\n} from \"../types\";\nimport { splitSpace } from \"@daybrush/utils\";\nimport { setDragStart, getDragDist } from \"../DraggerUtils\";\nimport { minus } from \"../matrix\";\nimport {\n    getRadiusValues, getRadiusStyles, removeRadiusPos,\n    addRadiusPos, splitRadiusPoses\n} from \"./roundable/borderRadius\";\n\nfunction addBorderRadius(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    lineIndex: number,\n    distX: number,\n    distY: number,\n    width: number,\n    height: number,\n) {\n    const {\n        horizontals,\n        verticals,\n    } = splitRadiusPoses(controlPoses);\n    const horizontalsLength = horizontals.length;\n    const verticalsLength = verticals.length;\n    // lineIndex\n    // 0 top\n    // 1 right\n    // 2 left\n    // 3 bottom\n\n    // 0 top - left\n    // 1 top - right\n    // 2 bottom - right\n    // 3 bottom - left\n    // 0 left - top\n    // 1 right - top\n    // 2 right - bottom\n    // 3 left - bottom\n    let horizontalIndex = -1;\n    let verticalIndex = -1;\n\n    if (lineIndex === 0) {\n        if (horizontalsLength === 0) {\n            horizontalIndex = 0;\n        } else if (horizontalsLength === 1) {\n            horizontalIndex = 1;\n        }\n    } else if (lineIndex === 3) {\n        if (horizontalsLength <= 2) {\n            horizontalIndex = 2;\n        } else if (horizontalsLength <= 3) {\n            horizontalIndex = 3;\n        }\n    }\n    if (lineIndex === 2) {\n        if (verticalsLength === 0) {\n            verticalIndex = 0;\n        } else if (verticalsLength < 4) {\n            verticalIndex = 3;\n        }\n    } else if (lineIndex === 1) {\n        if (verticalsLength <= 1) {\n            verticalIndex = 1;\n        } else if (verticalsLength <= 2) {\n            verticalIndex = 2;\n        }\n    }\n\n    addRadiusPos(\n        controlPoses, poses, 0,\n        horizontalIndex, verticalIndex,\n        distX, distY, width, height,\n    );\n}\nfunction getBorderRadius(\n    target: HTMLElement | SVGElement, width: number, height: number, state?: string,\n) {\n    let borderRadius: string;\n\n    if (!state) {\n        const style = window.getComputedStyle(target);\n\n        if (!style) {\n            return null;\n        }\n        borderRadius = style.borderRadius || \"\";\n    } else {\n        borderRadius = state;\n    }\n    if (!borderRadius || (!state && borderRadius === \"0px\")) {\n        return null;\n    }\n    const values = splitSpace(borderRadius);\n\n    return getRadiusValues(values, width, height, 0, 0);\n}\n\nfunction triggerRoundEvent(\n    moveable: MoveableManagerInterface<RoundableProps, RoundableState>,\n    e: any,\n    dist: number[],\n    delta: number[],\n    controlPoses: ControlPose[],\n    nextPoses: number[][],\n) {\n    const state = moveable.state;\n    const {\n        width,\n        height,\n    } = state;\n    const {\n        raws,\n        styles,\n    } = getRadiusStyles(\n        nextPoses,\n        controlPoses,\n        moveable.props.roundRelative!,\n        width,\n        height,\n    );\n    const {\n        horizontals,\n        verticals,\n    } = splitRadiusPoses(controlPoses, raws);\n    const borderRadius = styles.join(\" \");\n\n    state.borderRadiusState = borderRadius;\n    triggerEvent<RoundableProps>(moveable, \"onRound\", fillParams<OnRound>(moveable, e, {\n        horizontals,\n        verticals,\n        borderRadius,\n        width,\n        height,\n        delta,\n        dist,\n    }));\n}\n\n/**\n * @namespace Moveable.Roundable\n * @description Whether to show and drag or double click border-radius\n */\n\nexport default {\n    name: \"roundable\",\n    props: {\n        roundable: Boolean,\n        roundRelative: Boolean,\n    } as const,\n    events: {\n        onRoundStart: \"roundStart\",\n        onRound: \"round\",\n        onRoundEnd: \"roundEnd\",\n    } as const,\n    css: [\n        `.control.border-radius {\n    background: #d66;\n    cursor: pointer;\n}`,\n        `:host[data-able-roundable] .line.direction {\n    cursor: pointer;\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, React: Renderer): any {\n        const {\n            target,\n            width,\n            height,\n            matrix,\n            is3d,\n            left,\n            top,\n            borderRadiusState,\n        } = moveable.state;\n\n        if (!target) {\n            return null;\n        }\n\n        const n = is3d ? 4 : 3;\n        const radiusValues = getBorderRadius(target, width, height, borderRadiusState);\n\n        if (!radiusValues) {\n            return null;\n        }\n        return radiusValues.map((v, i) => {\n            const pos = minus(caculatePosition(matrix, v.pos, n), [left, top]);\n\n            return <div key={`borderRadiusControl${i}`}\n                className={prefix(\"control\", \"border-radius\")}\n                data-radius-index={i}\n                style={{\n                    transform: `translate(${pos[0]}px, ${pos[1]}px)`,\n                }}></div>;\n        });\n    },\n    dragControlCondition(e: any) {\n        if (!e.inputEvent || e.isRequest) {\n            return false;\n        }\n        const className = (e.inputEvent.target.className || \"\");\n\n        return className.indexOf(\"border-radius\") > -1\n            || (className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1);\n    },\n    dragControlStart(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const { inputEvent, datas, } = e;\n        const inputTarget = inputEvent.target;\n        const className = (inputTarget.className || \"\");\n        const isControl = className.indexOf(\"border-radius\") > -1;\n        const isLine = className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\n        const controlIndex = isControl ? parseInt(inputTarget.getAttribute(\"data-radius-index\"), 10) : -1;\n        const lineIndex = isLine ? parseInt(inputTarget.getAttribute(\"data-line-index\"), 10) : -1;\n\n        if (!isControl && !isLine) {\n            return false;\n        }\n\n        const result = triggerEvent<RoundableProps>(\n            moveable, \"onRoundStart\", fillParams<OnRoundStart>(moveable, e, {}));\n\n        if (result === false) {\n            return false;\n        }\n\n        datas.lineIndex = lineIndex;\n        datas.controlIndex = controlIndex;\n        datas.isControl = isControl;\n        datas.isLine = isLine;\n\n        setDragStart(moveable, e);\n\n        const {\n            roundRelative,\n        } = moveable.props;\n        const state = moveable.state;\n        const {\n            target,\n            width,\n            height,\n        } = state;\n\n        datas.isRound = true;\n        datas.prevDist = [0, 0];\n        const controlPoses = getBorderRadius(target!, width, height) || [];\n\n        datas.controlPoses = controlPoses;\n\n        state.borderRadiusState = getRadiusStyles(\n            controlPoses.map(pos => pos.pos), controlPoses, roundRelative!, width, height).styles.join(\" \");\n        return true;\n    },\n    dragControl(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isRound || !datas.isControl || !datas.controlPoses.length) {\n            return false;\n        }\n        const index = datas.controlIndex as number;\n        const controlPoses = datas.controlPoses as ControlPose[];\n        const nextPoses = controlPoses.map(pos => pos.pos.slice());\n        const [distX, distY] = getDragDist(e);\n        const dist = [distX, distY];\n        const delta = minus(dist, datas.prevDist);\n\n        moveControlPos(controlPoses, nextPoses, index, distX, distY);\n\n        datas.prevDist = [distX, distY];\n\n        triggerRoundEvent(\n            moveable,\n            e,\n            dist,\n            delta,\n            controlPoses,\n            nextPoses,\n        );\n        return true;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const state = moveable.state;\n\n        state.borderRadiusState = \"\";\n        const { datas, isDouble } = e;\n        if (!datas.isRound) {\n            return false;\n        }\n        const {\n            width,\n            height,\n        } = state;\n        const {\n            isControl,\n            controlIndex,\n            isLine,\n            lineIndex,\n        } = datas;\n        const controlPoses = datas.controlPoses as ControlPose[];\n        const poses = controlPoses.map(pos => pos.pos);\n        const length = poses.length;\n\n        if (isDouble) {\n            if (isControl) {\n                removeRadiusPos(controlPoses, poses, controlIndex, 0);\n            } else if (isLine) {\n                const [distX, distY] = caculatePointerDist(moveable, e);\n\n                addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height);\n            }\n            if (length !== controlPoses.length) {\n                triggerRoundEvent(\n                    moveable,\n                    e,\n                    [0, 0],\n                    [0, 0],\n                    controlPoses,\n                    poses,\n                );\n            }\n            triggerEvent<RoundableProps>(moveable, \"onRoundEnd\",\n                fillEndParams<OnRoundEnd>(moveable, e, {}));\n        }\n        state.borderRadiusState = \"\";\n        return true;\n    },\n    unset(moveable: MoveableManagerInterface<RoundableProps, RoundableState>) {\n        moveable.state.borderRadiusState = \"\";\n    },\n};\n/**\n * Whether to show and drag or double click border-radius, (default: false)\n * @name Moveable.Roundable#roundable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * % Can be used instead of the absolute px\n * @name Moveable.Roundable#roundRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag start the clip area or controls, the `roundStart` event is called.\n * @memberof Moveable.Roundable\n * @event roundStart\n * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag or double click the border area or controls, the `round` event is called.\n * @memberof Moveable.Roundable\n * @event round\n * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag end the border area or controls, the `roundEnd` event is called.\n * @memberof Moveable.Roundable\n * @event roundEnd\n * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n","import { refs } from \"framework-utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { Renderer, MoveableGroupInterface } from \"../types\";\n\nexport default {\n    name: \"groupable\",\n    props: {\n        defaultGroupRotate: Number,\n        defaultGroupOrigin: String,\n        groupable: Boolean,\n    } as const,\n    events: {} as const,\n    render(moveable: MoveableGroupInterface, React: Renderer): any[] {\n        const targets = moveable.props.targets || [];\n\n        moveable.moveables = [];\n        const { left, top } = moveable.state;\n        const position = { left, top };\n\n        return targets.map((target, i) => {\n            return <MoveableManager\n                key={\"moveable\" + i}\n                ref={refs(moveable, \"moveables\", i)}\n                target={target}\n                origin={false}\n                parentMoveable={moveable}\n                parentPosition={position}\n            />;\n        });\n    },\n};\n","import Pinchable from \"./Pinchable\";\nimport Rotatable from \"./Rotatable\";\nimport Draggable from \"./Draggable\";\nimport Resizable from \"./Resizable\";\nimport Scalable from \"./Scalable\";\nimport Warpable from \"./Warpable\";\nimport Snappable from \"./Snappable\";\nimport DragArea from \"./DragArea\";\nimport Origin from \"./Origin\";\nimport Scrollable from \"./Scrollable\";\nimport Default from \"./Default\";\nimport Padding from \"./Padding\";\nimport Clippable from \"./Clippable\";\nimport OriginDraggable from \"./OriginDraggable\";\nimport Roundable from \"./Roundable\";\nimport { Able, UnionToIntersection } from \"../types\";\nimport { IObject } from \"@daybrush/utils\";\nimport { invert } from \"./utils\";\nimport Groupable from \"./Groupable\";\n\nexport const MOVEABLE_ABLES = [\n    Default, Snappable, Pinchable, Draggable, Rotatable,\n    Resizable, Scalable, Warpable, Scrollable, DragArea, Padding, Origin, OriginDraggable,\n    Clippable, Roundable, Groupable,\n] as const;\n\nexport const MOVEABLE_EVENTS_PROPS_MAP = MOVEABLE_ABLES.reduce((current, able) => {\n    return {...current, ...able.events};\n}, {}) as UnionToIntersection<typeof MOVEABLE_ABLES[number][\"events\"]>;\nexport const MOVEABLE_PROPS_MAP = MOVEABLE_ABLES.reduce((current, able) => {\n    return {...current, ...able.props};\n}, {}) as UnionToIntersection<typeof MOVEABLE_ABLES[number][\"props\"]>;\n\nexport const MOVEABLE_EVENTS_MAP = invert(MOVEABLE_EVENTS_PROPS_MAP);\nexport const MOVEABLE_EVENTS: string[] = Object.keys(MOVEABLE_EVENTS_MAP);\nexport const MOVEABLE_PROPS: string[] = Object.keys(MOVEABLE_PROPS_MAP);\n\nconst cssMap: IObject<boolean> = {};\n\nMOVEABLE_ABLES.forEach(({ css }: Able) => {\n    if (!css) {\n        return;\n    }\n    css.forEach(text => {\n        cssMap[text] = true;\n    });\n});\n\nexport const ABLE_CSS = Object.keys(cssMap).join(\"\\n\");\n","import * as React from \"react\";\nimport { MOVEABLE_CSS, PREFIX } from \"./consts\";\nimport {\n    prefix, getLineStyle,\n    getTargetInfo,\n    unset,\n    createIdentityMatrix3,\n    isInside,\n    getAbsolutePosesByState,\n    getRect,\n    filterAbles,\n    equals,\n    resetClientRect,\n    throttle,\n    flat,\n    groupByMap,\n    caculatePadding,\n} from \"./utils\";\nimport styled from \"react-css-styled\";\nimport Dragger from \"@daybrush/drag\";\nimport { ref, prefixCSS } from \"framework-utils\";\nimport { MoveableManagerProps, MoveableManagerState, Able, RectInfo, Requester, PaddingBox, HitRect } from \"./types\";\nimport { triggerAble, getTargetAbleDragger, getAbleDragger } from \"./getAbleDragger\";\nimport { getRad, plus } from \"./matrix\";\nimport { IObject } from \"@daybrush/utils\";\nimport { ABLE_CSS } from \"./ables/consts\";\n\nconst ControlBoxElement = styled(\"div\", prefixCSS(PREFIX, MOVEABLE_CSS + ABLE_CSS));\n\nfunction renderLine(direction: string, pos1: number[], pos2: number[], index: number) {\n    const rad = getRad(pos1, pos2);\n    const rotation = direction ? (throttle(rad / Math.PI * 180, 15)) % 180 : -1;\n\n    return <div key={`line${index}`} className={prefix(\"line\", \"direction\", direction)}\n        data-rotation={rotation}\n        data-line-index={index}\n        data-direction={direction} style={getLineStyle(pos1, pos2, rad)}></div>;\n}\nexport default class MoveableManager<T = {}>\n    extends React.PureComponent<MoveableManagerProps<T>, MoveableManagerState> {\n    public static defaultProps: Required<MoveableManagerProps> = {\n        target: null,\n        dragTarget: null,\n        container: null,\n        rootContainer: null,\n        origin: true,\n        edge: false,\n        parentMoveable: null,\n        parentPosition: null,\n        ables: [],\n        pinchThreshold: 20,\n        dragArea: false,\n        transformOrigin: \"\",\n        className: \"\",\n        zoom: 1,\n        triggerAblesSimultaneously: false,\n        padding: {},\n        pinchOutside: true,\n        checkInput: false,\n        groupable: false,\n        cspNonce: \"\",\n    };\n    public state: MoveableManagerState = {\n        container: null,\n        target: null,\n        beforeMatrix: createIdentityMatrix3(),\n        matrix: createIdentityMatrix3(),\n        targetMatrix: createIdentityMatrix3(),\n        offsetMatrix: createIdentityMatrix3(),\n        targetTransform: \"\",\n        is3d: false,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n        transformOrigin: [0, 0],\n        direction: 1,\n        beforeDirection: 1,\n        beforeOrigin: [0, 0],\n        origin: [0, 0],\n        pos1: [0, 0],\n        pos2: [0, 0],\n        pos3: [0, 0],\n        pos4: [0, 0],\n        renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],\n        targetClientRect: resetClientRect(),\n        containerClientRect: resetClientRect(),\n        moveableClientRect: resetClientRect(),\n        rotation: 0,\n    } as any;\n    public targetAbles: Able[] = [];\n    public controlAbles: Able[] = [];\n    public controlBox!: typeof ControlBoxElement extends new (...args: any[]) => infer K ? K : never;\n    public areaElement!: HTMLElement;\n    public targetDragger!: Dragger;\n    public controlDragger!: Dragger;\n    public rotation: number = 0;\n    public scale: number[] = [1, 1];\n    public isUnmounted = false;\n\n    public render() {\n        const props = this.props;\n        const state = this.state;\n        const { edge, parentPosition, className, target: propsTarget, zoom, cspNonce } = props;\n\n        this.checkUpdate();\n        this.updateRenderPoses();\n\n        const { left: parentLeft, top: parentTop } = parentPosition! || { left: 0, top: 0 };\n        const { left, top, target: stateTarget, direction, renderPoses } = state;\n        const groupTargets = (props as any).targets;\n        const isDisplay = ((groupTargets && groupTargets.length) || propsTarget) && stateTarget;\n        const isDragging = this.isDragging();\n        const ableAttributes: IObject<boolean> = {};\n\n        this.getEnabledAbles().forEach(able => {\n            ableAttributes[`data-able-${able.name.toLowerCase()}`] = true;\n        });\n        return (\n            <ControlBoxElement\n                cspNonce={cspNonce}\n                ref={ref(this, \"controlBox\")}\n                className={`${prefix(\"control-box\", direction === -1\n                    ? \"reverse\" : \"\", isDragging ? \"dragging\" : \"\")} ${className}`}\n                {...ableAttributes}\n                style={{\n                    \"position\": \"absolute\",\n                    \"display\": isDisplay ? \"block\" : \"none\",\n                    \"transform\": `translate(${left - parentLeft}px, ${top - parentTop}px) translateZ(50px)`,\n                    \"--zoom\": zoom,\n                    \"--zoompx\": `${zoom}px`,\n                }}>\n                {this.renderAbles()}\n                {renderLine(edge ? \"n\" : \"\", renderPoses[0], renderPoses[1], 0)}\n                {renderLine(edge ? \"e\" : \"\", renderPoses[1], renderPoses[3], 1)}\n                {renderLine(edge ? \"w\" : \"\", renderPoses[0], renderPoses[2], 2)}\n                {renderLine(edge ? \"s\" : \"\", renderPoses[2], renderPoses[3], 3)}\n            </ControlBoxElement>\n        );\n    }\n    public componentDidMount() {\n        this.controlBox.getElement();\n        const props = this.props;\n        const { parentMoveable, container } = props;\n\n        this.updateEvent(props);\n        if (!container && !parentMoveable) {\n            this.updateRect(\"End\", false, true);\n        }\n        this.updateCheckInput();\n    }\n    public componentDidUpdate(prevProps: MoveableManagerProps) {\n        this.updateEvent(prevProps);\n        this.updateCheckInput();\n    }\n    public componentWillUnmount() {\n        this.isUnmounted = true;\n        unset(this, \"targetDragger\");\n        unset(this, \"controlDragger\");\n    }\n    public getContainer(): HTMLElement | SVGElement {\n        const { parentMoveable, container } = this.props;\n\n        return container!\n            || (parentMoveable && parentMoveable.getContainer())\n            || this.controlBox.getElement().parentElement!;\n    }\n    /**\n     * Check if the target is an element included in the moveable.\n     * @method Moveable#isMoveableElement\n     * @param - the target\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"click\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *         moveable.target = e.target;\n     *     }\n     * });\n     */\n    public isMoveableElement(target: HTMLElement | SVGElement) {\n        return target && ((target.getAttribute(\"class\") || \"\").indexOf(PREFIX) > -1);\n    }\n    /**\n     * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n     * @method Moveable#dragStart\n     * @param - external `MouseEvent`or `TouchEvent`\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *          moveable.dragStart(e);\n     *     }\n     * });\n     */\n    public dragStart(e: MouseEvent | TouchEvent) {\n        if (this.targetDragger) {\n            this.targetDragger.triggerDragStart(e);\n        }\n        return this;\n    }\n    /**\n     * Hit test an element or rect on a moveable target.\n     * @method Moveable#hitTest\n     * @param - element or rect to test\n     * @return - Get hit test rate (rate > 0 is hitted)\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.hitTest(e.target) > 0) {\n     *          console.log(\"hiited\");\n     *     }\n     * });\n     */\n    public hitTest(el: Element | HitRect): number {\n        let rect: Required<HitRect>;\n\n        if (el instanceof Element) {\n            const clientRect = el.getBoundingClientRect();\n\n            rect = {\n                left: clientRect.left,\n                top: clientRect.top,\n                width: clientRect.width,\n                height: clientRect.height,\n            };\n        } else {\n            rect = { width: 0, height: 0, ...el };\n        }\n        const {\n            left: rectLeft,\n            top: rectTop,\n            width: rectWidth,\n            height: rectHeight,\n        } = this.state.targetClientRect;\n        const {\n            left,\n            top,\n            width,\n            height,\n        } = rect;\n        const right = left + width;\n        const bottom = top + height;\n        const rectRight = rectLeft + rectWidth;\n        const rectBottom = rectTop + rectHeight;\n        const testLeft = Math.max(rectLeft, left);\n        const testRight = Math.min(rectRight, right);\n        const testTop = Math.max(rectTop, top);\n        const testBottom = Math.min(rectBottom, bottom);\n\n        if (testRight < testLeft || testBottom < testTop) {\n            return 0;\n        }\n\n        const rectSize = (Math.min(rectRight, right) - Math.max(left, rectLeft))\n            * (Math.min(rectBottom, bottom) - Math.max(rectTop, top));\n\n        return Math.min(100, (testRight - testLeft) * (testBottom - testTop) / rectSize * 100);\n    }\n    /**\n     * Whether the coordinates are inside Moveable\n     * @method Moveable#isInside\n     * @param - x coordinate\n     * @param - y coordinate\n     * @return - True if the coordinate is in moveable or false\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.isInside(e.clientX, e.clientY)) {\n     *          console.log(\"inside\");\n     *     }\n     * });\n     */\n    public isInside(clientX: number, clientY: number) {\n        const { pos1, pos2, pos3, pos4, target, targetClientRect } = this.state;\n\n        if (!target) {\n            return false;\n        }\n        const { left, top } = targetClientRect;\n        const pos = [clientX - left, clientY - top];\n\n        return isInside(pos, pos1, pos2, pos3, pos4);\n    }\n    /**\n     * If the width, height, left, and top of all elements change, update the shape of the moveable.\n     * @method Moveable#updateRect\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"resize\", e => {\n     *     moveable.updateRect();\n     * });\n     */\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        const props = this.props;\n        const parentMoveable = props.parentMoveable;\n        const state = this.state;\n        const target = (state.target || this.props.target) as HTMLElement | SVGElement;\n        const container = this.getContainer();\n        const rootContainer = parentMoveable\n            ? parentMoveable.props.rootContainer\n            : props.rootContainer;\n        this.updateState(\n            getTargetInfo(this.controlBox && this.controlBox.getElement(),\n                target, container, container,\n                rootContainer || container, isTarget ? state : undefined),\n            parentMoveable ? false : isSetState,\n        );\n    }\n    public updateEvent(prevProps: MoveableManagerProps) {\n        const controlBoxElement = this.controlBox.getElement();\n        const hasTargetAble = this.targetAbles.length;\n        const hasControlAble = this.controlAbles.length;\n        const props = this.props;\n        const target = props.dragTarget || props.target;\n        const prevTarget = prevProps.dragTarget || prevProps.target;\n        const dragArea = props.dragArea;\n        const prevDragArea = prevProps.dragArea;\n        const isTargetChanged = !dragArea && prevTarget !== target;\n        const isUnset = (!hasTargetAble && this.targetDragger)\n            || isTargetChanged\n            || prevDragArea !== dragArea;\n\n        if (isUnset) {\n            unset(this, \"targetDragger\");\n            this.updateState({ dragger: null });\n        }\n        if (!hasControlAble) {\n            unset(this, \"controlDragger\");\n        }\n\n        if (target && hasTargetAble && !this.targetDragger) {\n            this.targetDragger = getTargetAbleDragger<any>(this, target!, \"\");\n        }\n        if (!this.controlDragger && hasControlAble) {\n            this.controlDragger = getAbleDragger<any>(this, controlBoxElement, \"controlAbles\", \"Control\");\n        }\n        if (isUnset) {\n            this.unsetAbles();\n        }\n    }\n    /**\n     * Check if the moveable state is being dragged.\n     * @method Moveable#isDragging\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * // false\n     * console.log(moveable.isDragging());\n     *\n     * moveable.on(\"drag\", () => {\n     *   // true\n     *   console.log(moveable.isDragging());\n     * });\n     */\n    public isDragging() {\n        return (this.targetDragger ? this.targetDragger.isFlag() : false)\n            || (this.controlDragger ? this.controlDragger.isFlag() : false);\n    }\n    /**\n     * If the width, height, left, and top of the only target change, update the shape of the moveable.\n     * @method Moveable#updateTarget\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.updateTarget();\n     */\n    public updateTarget(type?: \"Start\" | \"\" | \"End\") {\n        this.updateRect(type, true);\n    }\n    /**\n     * You can get the vertex information, position and offset size information of the target based on the container.\n     * @method Moveable#getRect\n     * @return - The Rect Info\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * const rectInfo = moveable.getRect();\n     */\n    public getRect(): RectInfo {\n        const state = this.state;\n        const poses = getAbsolutePosesByState(this.state);\n        const [pos1, pos2, pos3, pos4] = poses;\n        const rect = getRect(poses);\n        const {\n            width: offsetWidth,\n            height: offsetHeight,\n        } = state;\n        const {\n            width,\n            height,\n            left,\n            top,\n        } = rect;\n        const statePos = [state.left, state.top];\n        const origin = plus(statePos, state.origin);\n        const beforeOrigin = plus(statePos, state.beforeOrigin);\n        const transformOrigin = state.transformOrigin;\n\n        return {\n            width,\n            height,\n            left,\n            top,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            offsetWidth,\n            offsetHeight,\n            beforeOrigin,\n            origin,\n            transformOrigin,\n            rotation: this.getRotation(),\n        };\n    }\n    public getRotation() {\n        const {\n            pos1,\n            pos2,\n            direction,\n        } = this.state;\n\n        let deg = getRad(pos1, pos2) / Math.PI * 180;\n\n        deg = direction >= 0 ? deg : 180 - deg;\n        deg = deg >= 0 ? deg : 360 + deg;\n\n        return deg;\n    }\n    /**\n     * Request able through a method rather than an event.\n     * At the moment of execution, requestStart is executed,\n     * and then request and requestEnd can be executed through Requester.\n     * @method Moveable#request\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}\n     * @param - ableName\n     * @param - request to be able params.\n     * @param - If isInstant is true, request and requestEnd are executed immediately.\n     * @return - Able Requester. If there is no request in able, nothing will work.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n     *\n     * // Start move\n     * const requester = moveable.request(\"draggable\");\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.requestEnd();\n     */\n    public request(ableName: string, param: IObject<any> = {}, isInstant?: boolean): Requester {\n        const { ables, groupable } = this.props as any;\n        const requsetAble: Able = ables!.filter((able: Able) => able.name === ableName)[0];\n\n        if (this.isDragging() || !requsetAble || !requsetAble.request) {\n            return {\n                request() {\n                    return this;\n                },\n                requestEnd() {\n                    return this;\n                },\n            };\n        }\n        const self = this;\n        const ableRequester = requsetAble.request(this);\n\n        const requestInstant = isInstant || param.isInstant;\n        const ableType = ableRequester.isControl ? \"controlAbles\" : \"targetAbles\";\n        const eventAffix = `${(groupable ? \"Group\" : \"\")}${ableRequester.isControl ? \"Control\" : \"\"}`;\n\n        const requester = {\n            request(ableParam: IObject<any>) {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"\", {\n                    ...ableRequester.request(ableParam),\n                    requestAble: ableName,\n                    isRequest: true,\n                }, requestInstant);\n                return this;\n            },\n            requestEnd() {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"End\", {\n                    ...ableRequester.requestEnd(),\n                    requestAble: ableName,\n                    isRequest: true,\n                }, requestInstant);\n                return this;\n            },\n        };\n\n        triggerAble(self, ableType, \"drag\", eventAffix, \"Start\", {\n            ...ableRequester.requestStart(param),\n            requestAble: ableName,\n            isRequest: true,\n        }, requestInstant);\n\n        return requestInstant ? requester.request(param).requestEnd() : requester;\n    }\n    /**\n     * Remove the Moveable object and the events.\n     * @method Moveable#destroy\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.destroy();\n     */\n    public destroy(): void {\n        this.componentWillUnmount();\n    }\n    public updateRenderPoses() {\n        const state = this.state;\n        const props = this.props;\n        const {\n            beforeOrigin, transformOrigin,\n            matrix, is3d, pos1, pos2, pos3, pos4, left: stateLeft, top: stateTop } = state;\n        const {\n            left = 0,\n            top = 0,\n            bottom = 0,\n            right = 0,\n        } = (props.padding || {}) as PaddingBox;\n        const n = is3d ? 4 : 3;\n        const absoluteOrigin = (props as any).groupable ? beforeOrigin : plus(beforeOrigin, [stateLeft, stateTop]);\n\n        state.renderPoses = [\n            plus(pos1, caculatePadding(matrix, [-left, -top], transformOrigin, absoluteOrigin, n)),\n            plus(pos2, caculatePadding(matrix, [right, -top], transformOrigin, absoluteOrigin, n)),\n            plus(pos3, caculatePadding(matrix, [-left, bottom], transformOrigin, absoluteOrigin, n)),\n            plus(pos4, caculatePadding(matrix, [right, bottom], transformOrigin, absoluteOrigin, n)),\n        ];\n    }\n    public checkUpdate() {\n        const { target, container, parentMoveable } = this.props;\n        const {\n            target: stateTarget,\n            container: stateContainer,\n        } = this.state;\n\n        if (!stateTarget && !target) {\n            return;\n        }\n        this.updateAbles();\n\n        const isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);\n\n        if (!isChanged) {\n            return;\n        }\n\n        this.updateState({ target, container });\n\n        if (!parentMoveable && (container || this.controlBox)) {\n            this.updateRect(\"End\", false, false);\n        }\n    }\n    public triggerEvent(name: string, e: any): any {\n        const callback = (this.props as any)[name];\n\n        return callback && callback(e);\n    }\n    protected unsetAbles() {\n        if (this.targetAbles.filter(able => {\n            if (able.unset) {\n                able.unset(this);\n                return true;\n            }\n            return false;\n        }).length) {\n            this.forceUpdate();\n        }\n    }\n    protected updateAbles(\n        ables: Able[] = this.props.ables!,\n        eventAffix: string = \"\",\n    ) {\n        const props = this.props as any;\n        const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        const enabledAbles = ables!.filter(able => able && props[able.name]);\n\n        const dragStart = `drag${eventAffix}Start` as \"dragStart\";\n        const pinchStart = `pinch${eventAffix}Start` as \"pinchStart\";\n        const dragControlStart = `drag${eventAffix}ControlStart` as \"dragControlStart\";\n\n        const targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);\n        const controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);\n\n        this.targetAbles = targetAbles;\n        this.controlAbles = controlAbles;\n    }\n    protected updateState(nextState: any, isSetState?: boolean) {\n        if (isSetState) {\n            this.setState(nextState);\n        } else {\n            const state = this.state as any;\n\n            for (const name in nextState) {\n                state[name] = nextState[name];\n            }\n        }\n    }\n    protected getEnabledAbles() {\n        const props = this.props as any;\n        const ables: Able[] = props.ables!;\n        return ables.filter(able => able && props[able.name]);\n    }\n    protected renderAbles() {\n        const props = this.props as any;\n        const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        const Renderer = { createElement: React.createElement };\n\n        return groupByMap(flat<any>(\n            filterAbles(this.getEnabledAbles(), [\"render\"], triggerAblesSimultaneously).map(({ render }) => {\n                return render!(this, Renderer) || [];\n            })).filter(el => el), ({ key }) => key).map(group => group[0]);\n    }\n    protected updateCheckInput() {\n        this.targetDragger && (this.targetDragger.options.checkInput = this.props.checkInput);\n    }\n}\n\n/**\n * The target to indicate Moveable Control Box.\n * @name Moveable#target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n */\n/**\n * Zooms in the elements of a moveable. (default: 1)\n * @name Moveable#zoom\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.zoom = 2;\n */\n\n/**\n * Resize, Scale Events at edges\n * @name Moveable#edge\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.edge = true;\n */\n\n/**\n * You can specify the className of the moveable controlbox. (default: \"\")\n * @name Moveable#className\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   className: \"\",\n * });\n *\n * moveable.className = \"moveable1\";\n */\n\n/**\n * The target(s) to drag Moveable target(s) (default: target)\n * @name Moveable#dragTarget\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n * moveable.dragTarget = document.querySelector(\".dragTarget\");\n */\n\n/**\n * `renderStart` event occurs at the first start of all events.\n * @memberof Moveable\n * @event renderStart\n * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderStart\", ({ target }) => {\n *     console.log(\"onRenderStart\", target);\n * });\n */\n\n/**\n * `render` event occurs before the target is drawn on the screen.\n * @memberof Moveable\n * @event render\n * @param {Moveable.OnRender} - Parameters for the `render` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"render\", ({ target }) => {\n *     console.log(\"onRender\", target);\n * });\n */\n\n/**\n * `renderEnd` event occurs at the end of all events.\n * @memberof Moveable\n * @event renderEnd\n * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderEnd\", ({ target }) => {\n *     console.log(\"onRenderEnd\", target);\n * });\n */\n\n/**\n * `renderGroupStart` event occurs at the first start of all events in group.\n * @memberof Moveable\n * @event renderGroupStart\n * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupStart\", ({ targets }) => {\n *     console.log(\"onRenderGroupStart\", targets);\n * });\n */\n\n/**\n * `renderGroup` event occurs before the target is drawn on the screen in group.\n * @memberof Moveable\n * @event renderGroup\n * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroup\", ({ targets }) => {\n *     console.log(\"onRenderGroup\", targets);\n * });\n */\n\n/**\n * `renderGroupEnd` event occurs at the end of all events in group.\n * @memberof Moveable\n * @event renderGroupEnd\n * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupEnd\", ({ targets }) => {\n *     console.log(\"onRenderGroupEnd\", targets);\n * });\n */\n","import MoveableManager from \"./MoveableManager\";\nimport { GroupableProps, MoveableManagerProps } from \"./types\";\nimport ChildrenDiffer from \"@egjs/children-differ\";\nimport { getAbleDragger, getTargetAbleDragger } from \"./getAbleDragger\";\nimport Groupable from \"./ables/Groupable\";\nimport { MIN_NUM, MAX_NUM, TINY_NUM } from \"./consts\";\nimport { getTargetInfo, throttle, getAbsolutePosesByState, equals } from \"./utils\";\nimport { plus, rotate } from \"./matrix\";\n\nfunction getMaxPos(poses: number[][][], index: number) {\n    return Math.max(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getMinPos(poses: number[][][], index: number) {\n    return Math.min(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getGroupRect(moveables: MoveableManager[], rotation: number) {\n    if (!moveables.length) {\n        return [0, 0, 0, 0];\n    }\n\n    const moveablePoses = moveables.map(({ state }) => getAbsolutePosesByState(state));\n    let minX = MAX_NUM;\n    let minY = MAX_NUM;\n    let groupWidth = 0;\n    let groupHeight = 0;\n    const fixedRotation = throttle(rotation, TINY_NUM);\n\n    if (fixedRotation % 90) {\n        const rad = rotation / 180 * Math.PI;\n        const a1 = Math.tan(rad);\n        const a2 = -1 / a1;\n        const b1s = [MIN_NUM, MAX_NUM];\n        const b2s = [MIN_NUM, MAX_NUM];\n\n        moveablePoses.forEach(poses => {\n            poses.forEach(pos => {\n                // ax + b = y\n                // ㅠ = y - ax\n                const b1 = pos[1] - a1 * pos[0];\n                const b2 = pos[1] - a2 * pos[0];\n\n                b1s[0] = Math.max(b1s[0], b1);\n                b1s[1] = Math.min(b1s[1], b1);\n                b2s[0] = Math.max(b2s[0], b2);\n                b2s[1] = Math.min(b2s[1], b2);\n            });\n        });\n\n        b1s.forEach(b1 => {\n            // a1x + b1 = a2x + b2\n            b2s.forEach(b2 => {\n                // (a1 - a2)x = b2 - b1\n                const x = (b2 - b1) / (a1 - a2);\n                const y = a1 * x + b1;\n\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n            });\n        });\n        const rotatePoses = moveablePoses.map(([pos1, pos2, pos3, pos4]) => {\n\n            return [\n                rotate(pos1, -rad),\n                rotate(pos2, -rad),\n                rotate(pos3, -rad),\n                rotate(pos4, -rad),\n            ];\n        });\n        groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);\n        groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);\n\n    } else {\n        minX = getMinPos(moveablePoses, 0);\n        minY = getMinPos(moveablePoses, 1);\n        groupWidth = getMaxPos(moveablePoses, 0) - minX;\n        groupHeight = getMaxPos(moveablePoses, 1) - minY;\n\n        if (fixedRotation % 180) {\n            const changedWidth = groupWidth;\n\n            groupWidth = groupHeight;\n            groupHeight = changedWidth;\n        }\n    }\n    return [minX, minY, groupWidth, groupHeight];\n}\n/**\n * @namespace Moveable.Group\n * @description You can make targets moveable.\n */\nclass MoveableGroup extends MoveableManager<GroupableProps> {\n    public static defaultProps = {\n        ...MoveableManager.defaultProps,\n        transformOrigin: [\"50%\", \"50%\"],\n        groupable: true,\n        dragArea: true,\n        keepRatio: true,\n        targets: [],\n        defaultGroupRotate: 0,\n        defaultGroupOrigin: \"50% 50%\",\n    };\n    public differ: ChildrenDiffer<HTMLElement | SVGElement> = new ChildrenDiffer();\n    public moveables: MoveableManager[] = [];\n    public transformOrigin = \"50% 50%\";\n\n    public updateEvent(prevProps: MoveableManagerProps<GroupableProps>) {\n        const state = this.state;\n        const props = this.props;\n\n        if (!state.target) {\n            state.target = this.areaElement;\n\n            this.controlBox.getElement().style.display = \"block\";\n            this.targetDragger = getTargetAbleDragger(this, state.target, \"Group\");\n            this.controlDragger = getAbleDragger(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\");\n        }\n        const isContainerChanged = !equals(prevProps.container, props.container);\n\n        if (isContainerChanged) {\n            state.container = props.container;\n        }\n        const { added, changed, removed } = this.differ.update(props.targets!);\n\n        if (isContainerChanged || added.length || changed.length || removed.length) {\n            this.updateRect();\n        }\n    }\n    public checkUpdate() {\n        this.updateAbles();\n    }\n\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        if (!this.controlBox) {\n            return;\n        }\n        this.moveables.forEach(moveable => {\n            moveable.updateRect(type, false, false);\n        });\n\n        const state = this.state;\n        const props = this.props;\n        const target = state.target! || props.target!;\n\n        if (!isTarget || (type !== \"\" && props.updateGroup)) {\n            // reset rotataion\n            this.rotation = props.defaultGroupRotate!;\n            this.transformOrigin = props.defaultGroupOrigin || \"50% 50%\";\n            this.scale = [1, 1];\n\n        }\n        const rotation = this.rotation;\n        const scale = this.scale;\n        const [left, top, width, height] = getGroupRect(this.moveables, rotation);\n\n        // tslint:disable-next-line: max-line-length\n        target.style.cssText += `left:0px;top:0px; transform-origin: ${this.transformOrigin}; width:${width}px; height:${height}px;transform:rotate(${rotation}deg)`\n            + ` scale(${scale[0] >= 0 ? 1 : -1}, ${scale[1] >= 0 ? 1 : -1})`;\n        state.width = width;\n        state.height = height;\n\n        const container = this.getContainer();\n        const info = getTargetInfo(\n            this.controlBox.getElement(),\n            target,\n            this.controlBox.getElement(),\n            this.getContainer(),\n            this.props.rootContainer || container,\n            state,\n        );\n        const pos = [info.left!, info.top!];\n        [\n            info.pos1,\n            info.pos2,\n            info.pos3,\n            info.pos4,\n        ] = getAbsolutePosesByState(info as Required<typeof info>);\n        info.origin = plus(pos, info.origin!);\n        info.beforeOrigin = plus(pos, info.beforeOrigin!);\n\n        const clientRect = info.targetClientRect!;\n\n        clientRect.top += (top - info.top!) - state.top;\n        clientRect.left += (left - info.left!) - state.left;\n\n        const direction = scale[0] * scale[1] > 0 ? 1 : -1;\n        this.updateState(\n            {\n                ...info,\n                direction,\n                beforeDirection: direction,\n                left: left - info.left!,\n                top: top - info.top!,\n            },\n            isSetState,\n        );\n    }\n    public triggerEvent(name: string, e: any): any {\n        if (name.indexOf(\"Group\") > -1) {\n            return super.triggerEvent(name as any, e);\n        }\n    }\n    protected updateAbles() {\n        super.updateAbles([...this.props.ables!, Groupable], \"Group\");\n    }\n}\n\n/**\n * Sets the initial rotation of the group. (default 0)\n * @name Moveable.Group#defaultGroupRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupRotate: 0,\n * });\n *\n * moveable.defaultGroupRotate = 40;\n */\n\n/**\n * Sets the initial origin of the group. (default 0)\n * @name Moveable.Group#defaultGroupOrigin\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupOrigin: \"50% 50%\",\n * });\n *\n * moveable.defaultGroupOrigin = \"20% 40%\";\n */\nexport default MoveableGroup;\n","import * as React from \"react\";\nimport { MoveableProps, Able, MoveableInterface, GroupableProps } from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport { MOVEABLE_ABLES } from \"./ables/consts\";\nimport MoveableGroup from \"./MoveableGroup\";\nimport { ref, withMethods } from \"framework-utils\";\nimport { isArray } from \"@daybrush/utils\";\nimport Groupable from \"./ables/Groupable\";\nimport { MOVEABLE_METHODS } from \"./consts\";\n\nexport default class Moveable<T = {}> extends React.PureComponent<MoveableProps & GroupableProps & T> {\n    @withMethods(MOVEABLE_METHODS)\n    public moveable!: MoveableManager | MoveableGroup;\n\n    public render() {\n        const props = this.props;\n        const ables: Able[] = props.ables as Able[] || [];\n        const target = this.props.target || this.props.targets;\n        const isArr = isArray(target);\n        const isGroup = isArr && (target as any[]).length > 1;\n\n        if (isGroup) {\n            const nextProps = {\n                ...this.props,\n                target: null,\n                targets: target as any[],\n                ables: [...MOVEABLE_ABLES, Groupable, ...ables],\n            } as any;\n            return <MoveableGroup key=\"group\" ref={ref(this, \"moveable\")}\n                {...nextProps} />;\n        } else {\n            const moveableTarget = isArr ? (target as any[])[0] : target;\n\n            return <MoveableManager<any> key=\"single\" ref={ref(this, \"moveable\")}\n                {...{ ...this.props, target: moveableTarget, ables: [...MOVEABLE_ABLES, ...ables] }} />;\n        }\n    }\n}\nexport default interface Moveable<T = {}>\n    extends React.PureComponent<MoveableProps & GroupableProps & T>, MoveableInterface {\n    setState(state: any, callback?: () => any): any;\n}\n","import Moveable, * as others from \"./index.esm\";\n\nfor (const name in others) {\n    (Moveable as any)[name] = (others as any)[name];\n}\nexport default Moveable;\n"],"names":["getSVGCursor","scale","degree","getCursorCSS","x1","x2","degree45","Math","round","defaultCursor","agent","getAgent","navigator","userAgent","IS_WEBKIT","os","name","indexOf","browser","PREFIX","MOVEABLE_CSS","map","join","NEARBY_POS","TINY_NUM","MIN_SCALE","MAX_NUM","pow","MIN_NUM","DIRECTIONS","DIRECTION_INDEXES","n","s","w","e","nw","ne","sw","se","DIRECTION_ROTATIONS","MOVEABLE_METHODS","add","matrix","inverseMatrix","startIndex","fromIndex","k","i","x","fromX","swap","v","iv","divide","ignoreDimension","m","sqrt","length","newMatrix","slice","invert","createIdentityMatrix","identityIndex","j","targetStartIndex","targetIndex","target","transpose","getRad","pos1","pos2","distX","distY","rad","atan2","PI","getOrigin","originMatrix","convertPositionMatrix","convertDimension","min","multiplies","_i","matrixes","forEach","multiply","matrix2","l","average","nums","total","plus","nextPos","minus","convertCSStoMatrix","a","is2d","convertMatrixtoCSS","caculate","result","rotate","pos","createRotateMatrix","cos","sin","createScaleMatrix","createOriginMatrix","origin","createWarpMatrix","pos0","pos3","nextPos0","nextPos1","nextPos2","nextPos3","x0","y0","y1","y2","x3","y3","u0","v0","u1","v1","u2","v2","u3","v3","h","setDragStart","moveable","_a","datas","_b","beforeMatrix","is3d","left","top","offsetMatrix","targetMatrix","transformOrigin","inverseBeforeMatrix","absoluteOrigin","startDragBeforeDist","startDragDist","getDragDist","isBefore","getInverseDragDist","caculateTransformOrigin","width","height","prevWidth","prevHeight","prevOrigin","value","unit","prevSize","size","isNaN","measureRatio","getPosIndexesByDirection","direction","indexes","push","getPosesByDirection","poses","index","getPosByDirection","nextPoses","getPosByReverseDirection","dir","getDist","startPos","caculatePoses","getNextMatrix","getAbsoluteMatrix","scaleMatrix","state","getScaleDist","fixedPosition","groupable","props","nextMatrix","groupLeft","groupTop","dist","getResizeDist","nextOrigin","getStartDirection","baseDirection","getAbsoluteFixedPosition","getAbsolutePosesByState","multiply2","prefix","classNames","prefixNames","createIdentityMatrix3","getTransformMatrix","transform","isObject","splitBracket","split","parseFloat","measureSVGSize","el","isHorizontal","viewBox","getSVGViewBox","ownerSVGElement","getBeforeTransformOrigin","relativeOrigin","getTransformOrigin","getComputedStyle","o","style","getOffsetInfo","lastParent","isParent","body","document","parentElement","isEnd","position","isStatic","offsetParent","getOffsetPosInfo","container","isFixed","tagName","toLowerCase","offsetLeft","offsetTop","containerClientRect","documentElement","getBoundingClientRect","isSVG","isUndefined","hasOffset","targetOrigin","offset","getMatrixStackInfo","prevMatrix","targetTransformOrigin","offsetContainer","matrixesLength","offsetPos","getSVGMatrix","isOffsetEnd","parentClientLeft","parentClientTop","clientLeft","clientTop","scrollLeft","scrollTop","caculateMatrixStack","rootContainer","prevRootMatrix","prevN","prevTargetMatrix","rootMatrixes","isRoot3d","isSVGGraphicElement","originalContainer","allMatrix","rootMatrix","endContainer","reverse","isMatrix3d","makeMatrixCSS","clientWidth","clientHeight","baseVal","y","viewBoxWidth","viewBoxHeight","scaleX","scaleY","preserveAspectRatio","align","meetOrSlice","svgOrigin","translate","xAlign","yAlign","floor","scaleDimension","max","getSVGGraphicsOffset","getBBox","bbox","caculatePosition","getRect","posesX","posesY","right","bottom","rectWidth","rectHeight","caculateRect","getSVGOffset","absoluteMatrix","rect","rectLeft","rectTop","mat","_c","prevLeft","prevTop","posOrigin","rectOrigin","count","mat2","_d","nextLeft","nextTop","distLeft","distTop","abs","p","caculateMoveablePosition","_e","x4","y4","_f","originX","originY","center","pos1Rad","pos2Rad","getDistSize","vec","getDiagonalSize","getLineStyle","getControlTransform","rotation","reduce","prev","getCSSSize","window","getSize","isOffset","isBoxSizing","boxSizing","offsetWidth","offsetHeight","borderLeft","borderLeftWidth","borderRight","borderRightWidth","borderTop","borderTopWidth","borderBottom","borderBottomWidth","paddingLeft","paddingRight","paddingTop","paddingBottom","getRotationRad","getTargetInfo","moveableElement","parentContainer","beforeDirection","targetTransform","beforeOrigin","targetClientRect","resetClientRect","moveableClientRect","undefined","beforePos","getClientRect","pos4","scrollWidth","scrollHeight","isExtends","getDirection","direciton","getAttribute","getAbsolutePoses","roundSign","num","throttle","throttleArray","_","unset","self","getOrientationDirection","isInside","k1","k2","k3","k4","k5","k6","signs1","signs2","every","sign","fillParams","params","nextParams","tslib_1","clientX","clientY","inputEvent","currentTarget","isStartEvent","lastEvent","fillEndParams","isDrag","isDouble","triggerEvent","isManager","MoveableManager","prototype","call","pseudoElt","filterAbles","ables","methods","triggerAblesSimultaneously","enabledAbles","ableGroups","filter","able","some","method","ableGroup","getKeepRatioHeight","isWidth","ratio","getKeepRatioWidth","equals","a1","a2","selectValue","values","groupBy","arr","func","groups","groupKeys","groupKey","keyIndex","group","groupByMap","flat","cur","concat","maxOffset","args","sort","b","minOffset","caculateInversePosition","convertDragDist","caculatePadding","checkSize","targetSize","compareSize","isMax","caculateBoundSize","minSize","maxSize","keepRatio","minWidth","minHeight","maxWidth","maxHeight","getUnitSize","convertCSSSize","isRelative","moveControlPos","controlPoses","horizontal","vertical","sub","isVertical","controlPose","dirDir","dirHorizontal","dirVertical","controlPos","caculatePointerDist","posX","posY","getTinyDist","triggerRenderStart","isGroup","isPinch","eventAffix","targets","triggerRender","triggerRenderEnd","sPinch","triggerAble","ableType","eventOperation","eventType","requestInstant","isStart","isRequest","areaElement","eventName","conditionName","isAfter","isFirstStart","targetDragger","controlDragger","isFlag","updateRect","requestAble_1","requestAble","events","renderDatas","render","renderEvent","originalDatas","results","hasCondition","ableName","nextDatas","isUpdate","dragger","moveables","childeMoveable","isUnmounted","forceUpdate","getTargetAbleDragger","moveableTarget","controlBox","getElement","dragArea","startFunc","eventTarget","isMoveableElement","className","getAbleDragger","dragstart","pinchstart","conditionFunctions","pinchOutside","pinchThreshold","options","Dragger","pinchable","Boolean","onPinchStart","onPinch","onPinchEnd","onPinchGroupStart","onPinchGroup","onPinchGroupEnd","pinchStart","angle","controlEventName","pinchAbles","controlAbles","canPinch","ableEvent","parentRotate","snapRenderInfo","request","pinch","pinchScale","distance","parentDistance","pinchEnd","pinchGroupStart","pinchGroup","pinchGroupEnd","setCustomDrag","delta","isConvert","move","draggableDatas","draggable","parentEvent","client","type","prevX","prevY","startX","startY","deltaX","deltaY","parentDragger","triggerChildDragger","match","childs","child","childEvent","CustomDragger","dragStart","childDraggers","parentFlag","triggerChildAble","eachEvent","callback","ableDatas","childDatas","isFunction","directionCondition","parentDirection","hasClass","obj","nextObj","getGapGuidelines","guidelines","snapThreshold","start","end","otherStart","otherEnd","totalGuidelines","otherIndex","otherType","elementGuidelines","guidelineType","element","sizes","guideline1","elementStart","elementEnd","guideline2Pos","guideline2Sizes","guideline2Element","targetStart","targetEnd","gap","canSnap","gapGuidelines","centerPos","getTotalGuidelines","containerHeight","containerWidth","snapHorizontal","snapVertical","snapGap","verticalGuidelines","horizontalGuidelines","_g","checkSnapPoses","snapCenter","customSnapThreshold","snapElement","checkSnap","checkSnapKeepRatio","endPos","endX","endY","dx","dy","isBottom","isRight","verticalInfo","isSnap","horizontalInfo","verticalSnapInfo","horizontalSnapInfo","posInfos","isVerticalSnap","verticalGuideline","isHorizontalSnap","horizontalGuideline","horizontalPos","verticalPos","checkSnaps","isCenter","isSnapCenter","verticalNames","horizontalNames","getNearestSnapGuidelineInfo","snapInfo","guideline","posInfo","guidelineInfo","guidelineInfos","targetType","targetPoses","posType","snapPosInfos","targetPos","snapPosInfo","getSnapInfosByDirection","snapDirection","alignPoses","getNearOffsetInfo","offsets","aSign","bSign","aOffset","bOffset","aDist","bDist","isBound","isStartLine","dot","line","cx","cy","hitTestLine","test1","test2","isSameStartLine","dots","error","centerSign","checkInnerBoundDot","threshold","checkInnerBound","bounds","innerBounds","isAllBound","isVerticalBound","isHorizontalBound","leftLine","topLine","rightLine","bottomLine","isHorizontalStart","isVerticalStart","topBoundInfo","checkLineBoundCollision","bottomBoundInfo","leftBoundInfo","rightBoundInfo","isAllVerticalBound","isAllHorizontalBound","verticalOffset","horizontalOffset","boundLine","isRender","dot1","dot2","boundDot1","boundDot2","dy1","dx1","dy2","dx2","getInnerBoundInfo","lines","multiple","sizeOffset","getInnerBoundDragInfo","getCheckSnapLines","innerBoundInfo","widthOffsetInfo","heightOffsetInfo","getCheckSnapLineDirections","lineDirections","dir1","dir2","isBoundRotate","relativePoses","boundDots","getDistPointLine","solveReverseLine","checkRotateInnerBounds","prevPoses","relativeLeft","relativeRight","relativeTop","relativeBottom","dotInfos","lineRad","lineDist","dotDist","dotRad","distRad","acos","nextRad1","nextRad2","nextRad","checkInnerBoundPoses","horizontalPoses","verticalPoses","boundMap","checkBoundPoses","checkBound","checkBoundKeepRatio","startBoundPos","endBoundPos","minPos","maxPos","boundRect","boundRotate","boundPos","r","checkRotateBounds","relativeRad1","relativeRad2","caculateContainerPos","containerRect","clientPos","snapStart","containerLeft","containerTop","targetLeft","targetTop","elementLeft","elementTop","elementRight","elementBottom","enableSnap","hasGuidelines","snappable","solveNextOffset","solveEquation","widthOffset","heightOffset","getNextFixedPoses","fixedPos","getSnapBoundOffset","boundInfo","getSnapBound","checkSnapBoundsKeepRatio","horizontalBoundInfo","verticalBoundInfo","horizontalDist","verticalDist","checkSnapBounds","boundPoses","normalized","checkMaxBounds","fixedDirection","Infinity","directions","left_1","top_1","right_1","bottom_1","otherDirection","isCheckVertical","isCheckHorizontal","otherPos","verticalDirection","horizontalDirection","deg","nextOtherPos","getSnapBoundInfo","startDirection","endDirection","otherStartPos","otherEndPos","snapBoundInfo","otherHorizontalDist","otherHorizontalOffset","isOtherHorizontalBound","isOtherHorizontalSnap","otherVerticalDist","otherVerticalOffset","isOtherVerticalBound","isOtherVerticalSnap","getCheckSnapDirections","getSizeOffsetInfo","recheckSizeByTwoDirection","snapPos","nextWidthOffset","nextHeightOffset","nextWidth","nextHeight","checkSizeDist","getNextPoses","isWidthBound","isHeightBound","widthDist","heightDist","isGetWidthOffset","checkSnapRotate","checkSnapSize","checkSnapScale","sizeDist","snapOffset","startCheckSnapDrag","absolutePoses","checkThrottleDragRotate","throttleDragRotate","offsetX","offsetY","adjustPoses","adjustPos","prevDistY","checkSnapDrag","snapPoses","verticalSnapBoundInfo","horizontalSnapBoundInfo","verticalInnerBoundInfo","horizontalInnerBoundInfo","getSnapGuidelines","getElementGuidelineDist","elementPos","elementSize","relativePos","groupByElementGuidelines","groupInfos","groupInfo","find","groupElement","groupPos","renderElementGroup","clientSize","isDisplaySnapDigit","snapDigit","snapDistFormat","React","directionName","posName1","posName2","sizeName","isFirstRenderSize","linePos","lineSize","isRenderSize","snapSize","toFixed","key","renderSnapPoses","renderGuidelines","targetPos1","targetPos2","getGapGuidelinesToStart","targetSizes","guidelinePos","absGap","gapPos","aPos","bPos","gapSizes","gapGuideline","renderPos","getGapGuidelinesToEnd","renderGapGuidelines","addBoundGuidelines","verticalSnapPoses","horizontalSnapPoses","verticalBoundPos","horizontalBoundPos","verticalInnerBoundPoses","horizontalInnerBoundPoses","innerPos","findIndex","Array","Number","Object","Function","onSnap","css","minLeft","minTop","containerPos","_h","snapInfos","snap","middle","verticalPosInfos","horizontalPosInfos","elementHorizontalGroup","elementVerticalGroup","gapVerticalGuidelines","gapHorizontalGuidelines","allGuidelines","elements","gaps","dragEnd","dragControlCondition","rotatableDragControlCondtion","dragControlStart","dragControlEnd","dragGroupStart","dragGroupEnd","dragGroupControlStart","dragGroupControlEnd","throttleDrag","startDragRotate","onDragStart","onDrag","onDragEnd","onDragGroupStart","onDragGroup","onDragGroupEnd","dragInfo","startTranslate","prevDist","prevBeforeDist","set","startRect","drag","parentMoveable","dragRotateRad","ry","rx","passDeltaX","passDistX","passDeltaY","passDistY","beforeTranslate","beforeDist","beforeDelta","nextTransform","dragGroup","isControl","requestStart","requestEnd","setRotateStartInfo","startAbsoluteOrigin","prevDeg","prevSnapDeg","startDeg","loop","getParentDeg","moveableRect","parentDist","startRotate","getDeg","throttleRotate","prevLoop","absolutePrevSnapDeg","absoluteDeg","getRotateInfo","getPositions","rotationPosition","radPoses","isReverse","rotatable","String","onRotateStart","onRotate","onRotateEnd","onRotateGroupStart","onRotateGroup","onRotateGroupEnd","renderPoses","rotationRad","externalRotate","beforeInfo","afterInfo","controlRect","rotatation","isRotate","dragControl","beforeRotate","dragGroupControlCondition","parentLeft","parentTop","parentBeforeOrigin","eventParams","childClient","prevClient","Draggable","dragGroupControl","dragResult","distRotate","startRotation","getRotation","deltaRotate","renderControls","defaultDirections","directionMap","directionRotation","renderAllDirections","renderDiagonalDirections","resizable","throttleResize","renderDirections","onResizeStart","onResize","onResizeEnd","onResizeGroupStart","onResizeGroup","onResizeGroupEnd","edge","startOffsetWidth","startOffsetHeight","padding","startWidth","startHeight","isString","fixedOriginalPosition","setMin","setMax","setOrigin","isResize","parentScale","parentKeepRatio","dragClient","sizeDirection","distWidth","distHeight","standardRad","ratioRad","signSize","snapDist","isNoSnap","inverseDelta","dragControlAfter","errorWidth","errorHeight","isErrorWidth","isErrorHeight","originalX","originalY","deltaWidth","deltaHeight","scalable","throttleScale","onScaleStart","onScale","onScaleEnd","onScaleGroupStart","onScaleGroup","onScaleGroupEnd","startScale","isScale","nowDist","stateDirection","isArray","snapHeight","snapWidth","moveableScale","getMiddleLinePos","getTriangleRad","rad1","rad2","isValidPos","poses1","poses2","pi","warpable","onWarpStart","onWarp","onWarpEnd","linePosFrom1","linePosFrom2","linePosFrom3","linePosFrom4","linePosTo1","linePosTo2","linePosTo3","linePosTo4","inputTarget","warpTargetMatrix","targetInverseMatrix","startMatrix","posIndexes","isWarp","selectedPoses","nearByPoses","AREA","AREA_PIECES","AREA_PIECE","AVOID","restoreStyle","removeClass","cssText","renderPieces","onClick","onClickGroup","ref","isDragArea","rects","children","nextElementSibling","addClass","containsTarget","contains","isTarget","prevInputTarget","parentTarget","getDefaultScrollPosition","scrollContainer","scrollable","scrollThreshold","getScrollPosition","onScroll","onScrollGroup","dragScroll","DragScroll","draggerName","on","scrollBy","checkScroll","ev","dragGroupContro","dragGroupControEnd","dragTarget","zoom","checkInput","cspNonce","onRenderStart","onRender","onRenderEnd","onRenderGroupStart","onRenderGroup","onRenderGroupEnd","paddingDirections","paddingPos1","paddingPos2","paddingPos3","paddingPos4","RADIUS_DIRECTIONS","caculateRatio","sumSize","sumRatio","HORIZONTAL_RADIUS_ORDER","VERTICAL_RADIUS_ORDER","HORIZONTAL_RADIUS_DIRECTIONS","VERTICAL_RADIUS_DIRECTIONS","getRadiusStyles","clipStyles","raws","rawPos","styles","getRadiusRange","horizontalRange","verticalRange","clipPose","getRadiusValues","splitIndex","splitLength","horizontalValues","verticalValues","nwValue","neValue","seValue","swValue","_j","wnValue","_k","enValue","_l","esValue","_m","wsValue","horizontalRawPoses","verticalRawPoses","nextHorizontalPoses","nextVerticalPoses","raw","removeRadiusPos","radiuslIndex","deleteCount","splice","addRadiusPos","horizontalIndex","verticalIndex","radiusX","radiusY","startVerticalIndex","splitRadiusPoses","horizontals","verticals","CLIP_DIRECTIONS","CLIP_RECT_DIRECTIONS","getClipStyles","clipPath","clipRelative","clipType","clipPoses","isRect","isCircle","subWidth","subHeight","getRectPoses","xs","ys","dirx","diry","getClipPath","defaultClip","customClip","clipText","clip","clipPrefix","splitter","splitComma","xPos","yPos","radiusX_1","radiusY_1","splitSpace","radius","xRadius","yRadius","centerPos_1","roundIndex","rectLength","radiusValues","topValue","rightValue","_o","bottomValue","_p","leftValue","_q","_r","nextRight","nextBottom","radiusPoses","_s","addClipPath","clipEventType","clipStyle","removeClipPath","clippable","defaultClipPath","customClipPath","clipArea","dragWithClip","onClipStart","onClip","onClipEnd","clipPathState","caculatedPos","controls","isInset","isPolygon","linePoses_1","to","from","clipLeft","clipTop","ellipseClipPath","piece","areaPoses","allWidth","allHeight","allLeft_1","allTop_1","isClipStart","isLine","isArea","parseInt","draggableData","isDragWithTarget","isAll","nextClipStyles","originDraggable","originRelative","onDragOriginStart","onDragOrigin","onDragOriginEnd","startOrigin","startTargetOrigin","isDragOrigin","distOrigin","nextRect","dragDelta","deltaOrigin","addBorderRadius","lineIndex","horizontalsLength","verticalsLength","getBorderRadius","borderRadius","triggerRoundEvent","borderRadiusState","roundable","roundRelative","onRoundStart","onRound","onRoundEnd","controlIndex","isRound","defaultGroupRotate","defaultGroupOrigin","refs","parentPosition","MOVEABLE_ABLES","Default","Snappable","Pinchable","Rotatable","Resizable","Scalable","Warpable","Scrollable","DragArea","Padding","Origin","OriginDraggable","Clippable","Roundable","Groupable","MOVEABLE_EVENTS_PROPS_MAP","current","MOVEABLE_PROPS_MAP","MOVEABLE_EVENTS_MAP","MOVEABLE_EVENTS","keys","MOVEABLE_PROPS","cssMap","text","ABLE_CSS","ControlBoxElement","styled","prefixCSS","renderLine","_this","propsTarget","checkUpdate","updateRenderPoses","stateTarget","groupTargets","isDisplay","isDragging","ableAttributes","getEnabledAbles","renderAbles","updateEvent","updateCheckInput","prevProps","getContainer","triggerDragStart","Element","clientRect","rectRight","rectBottom","testLeft","testRight","testTop","testBottom","rectSize","isSetState","updateState","controlBoxElement","hasTargetAble","targetAbles","hasControlAble","prevTarget","prevDragArea","isTargetChanged","isUnset","unsetAbles","statePos","param","isInstant","requsetAble","ableRequester","requester","ableParam","componentWillUnmount","stateLeft","stateTop","stateContainer","updateAbles","isChanged","nextState","setState","Renderer","createElement","getMaxPos","getMinPos","getGroupRect","moveablePoses","minX","minY","groupWidth","groupHeight","fixedRotation","rad_1","a1_1","tan","a2_1","b1s_1","b2s_1","b1","b2","rotatePoses","changedWidth","ChildrenDiffer","display","isContainerChanged","added","changed","removed","updateGroup","info","_super","MoveableGroup","defaultProps","isArr","nextProps","withMethods","others","Moveable"],"mappings":"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"}